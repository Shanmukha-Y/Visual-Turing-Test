/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_sanity_groq-store_dist_browser_groq-store_js"],{

/***/ "./node_modules/@sanity/groq-store/dist/browser/groq-store.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/groq-store/dist/browser/groq-store.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var e=__webpack_require__(/*! groq */ \"./node_modules/groq/lib/groq.js\"),r=__webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\"),t=__webpack_require__(/*! throttle-debounce */ \"./node_modules/throttle-debounce/cjs/index.js\"),n=__webpack_require__(/*! groq-js */ \"./node_modules/groq-js/dist/1.umd.cjs\"),o=__webpack_require__(/*! mendoza */ \"./node_modules/mendoza/lib/esm/index.js\");function i(e){return e&&\"object\"==typeof e&&\"default\"in e?e:{default:e}}var u=/*#__PURE__*/i(e),s=/*#__PURE__*/i(r);function a(){return a=Object.assign?Object.assign.bind():function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},a.apply(this,arguments)}var c,f=function(e,r,t){(function(e){return\"undefined\"!=typeof window&&e.addEventListener===window.EventSource.prototype.addEventListener})(e)&&e.addEventListener(r,t,!1),e.addEventListener(r,t)};function d(e,r,t){var n,o=r.token,i=new e(\"https://\"+r.projectId+\".api.sanity.io/v1/data/listen/\"+r.dataset+\"?query=*&effectFormat=mendoza\",{withCredentials:!0,headers:o?{Authorization:\"Bearer \"+o}:void 0});return f(i,\"welcome\",t.open),f(i,\"mutation\",(n=t.next,function(e){var r;try{r=JSON.parse(e.data)}catch(e){return}n(r)})),f(i,\"channelError\",function(e){var r;i.close();try{r=JSON.parse(e.data)}catch(e){return void t.error(new Error(\"Unknown error parsing listener message\"))}t.error(new Error(r.message||r.error||\"Listener returned HTTP \"+r.statusCode))}),f(i,\"error\",function(e){var r=\"undefined\"!=typeof window&&window.location.origin,n=r?\", and that the CORS-origin (\"+r+\") is allowed\":\"\",o=function(e){return\"object\"==typeof e&&null!==e&&\"message\"in e}(e)?\" (\"+e.message+\")\":\"\";t.error(new Error(\"Error establishing listener - check that the project ID and dataset are correct\"+n+o))}),{unsubscribe:function(){return Promise.resolve(i.close())}}}function v(e){return e._id.startsWith(\"drafts.\")?e._id.slice(7):e._id}function l(e,r){var t=a({},e);return delete t._rev,o.applyPatch(t,r)}function h(){return Promise.resolve()}function m(e,r,t){if(!e.s){if(t instanceof p){if(!t.s)return void(t.o=m.bind(null,e,r));1&r&&(r=t.s),t=t.v}if(t&&t.then)return void t.then(m.bind(null,e,r),m.bind(null,e,2));e.s=r,e.v=t;const n=e.o;n&&n(e)}}var p=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(r,t){var n=new e,o=this.s;if(o){var i=1&o?r:t;if(i){try{m(n,1,i(this.v))}catch(e){m(n,2,e)}return n}return this}return this.o=function(e){try{var o=e.v;1&e.s?m(n,1,r?r(o):o):t?m(n,1,t(o)):m(n,2,o)}catch(e){m(n,2,e)}},n},e}();function w(e){return e instanceof p&&1&e.s}var b=function(e){var r=e.projectId,t=e.dataset,n=e.token,o=e.documentLimit;try{return Promise.resolve(fetch(\"https://\"+r+\".api.sanity.io/v1/data/export/\"+t,{credentials:\"include\",headers:n?{Authorization:\"Bearer \"+n}:void 0})).then(function(e){function r(r){var t,n,i=function(e){if(!e)throw new Error(\"Failed to read body from response\");var r,t=!1;function n(){t=!0,r&&r.cancel()}return new ReadableStream({start:function(o){r=e.getReader();var i=new TextDecoder,u=\"\";r.read().then(function e(s){try{if(s.done)return t?Promise.resolve():0===(u=u.trim()).length?(o.close(),Promise.resolve()):(o.enqueue(JSON.parse(u)),o.close(),Promise.resolve());for(var a=(u+=i.decode(s.value,{stream:!0})).split(\"\\n\"),c=0;c<a.length-1;++c){var f=a[c].trim();if(0!==f.length)try{o.enqueue(JSON.parse(f))}catch(e){return o.error(e),n(),Promise.resolve()}}if(u=a[a.length-1],!r)return Promise.resolve();var d=function(t,n){try{var o=Promise.resolve(r.read()).then(function(r){e(r)})}catch(e){return n(e)}return o&&o.then?o.then(void 0,n):o}(0,function(e){o.error(e)});return Promise.resolve(d&&d.then?d.then(function(){}):void 0)}catch(e){return Promise.reject(e)}}).catch(function(e){return o.error(e)})},cancel:n})}(e.body),u=i.getReader(),s=[],a=function(e,r){var t;do{var n=e();if(n&&n.then){if(!w(n)){t=!0;break}n=n.v}var o=r();if(w(o)&&(o=o.v),!o)return n}while(!o.then);var i=new p,u=m.bind(null,i,2);return(t?n.then(s):o.then(a)).then(void 0,u),i;function s(t){for(n=t;w(o=r())&&(o=o.v),o;){if(o.then)return void o.then(a).then(void 0,u);if((n=e())&&n.then){if(!w(n))return void n.then(s).then(void 0,u);n=n.v}}m(i,1,n)}function a(t){if(t){do{if((n=e())&&n.then){if(!w(n))return void n.then(s).then(void 0,u);n=n.v}if(w(t=r())&&(t=t.v),!t)return void m(i,1,n)}while(!t.then);t.then(a).then(void 0,u)}else m(i,1,n)}}(function(){return Promise.resolve(u.read()).then(function(e){if(function(e){return!!e&&\"error\"in e&&\"object\"==typeof e.error&&null!==e.error&&\"description\"in e.error&&\"string\"==typeof e.error.description&&!(\"_id\"in e)}(n=(t=e).value))throw new Error(\"Error streaming dataset: \"+n.error);if(n&&!n._id.startsWith(\"_.\")&&s.push(n),o&&s.length>o)throw u.cancel(\"Reached document limit\"),new Error(\"Error streaming dataset: Reached limit of \"+o+\" documents\")})},function(){return!t.done});return a&&a.then?a.then(function(e){return s}):s}var t=function(){if(200!==e.status)return Promise.resolve(e.json()).then(function(e){throw new Error(\"Error streaming dataset: \"+(\"object\"==typeof(r=e)&&\"error\"in r&&\"message\"in r?r.message||r.error:\"<unknown error>\"));var r})}();return t&&t.then?t.then(r):r()})}catch(e){return Promise.reject(e)}};Object.defineProperty(exports, \"groq\", ({enumerable:!0,get:function(){return u.default}})),exports.groqStore=function(e){var r;!function(){var e=[\"EventSource\",\"ReadableStream\",\"fetch\"].filter(function(e){return!(e in window)});if(e.length>0)throw new Error(\"Browser not supported. Missing browser APIs: \"+e.join(\", \"))}();var o=null!=(r=e.EventSource)?r:window.EventSource;if(e.token&&o===window.EventSource)throw new Error(\"When`token` option is used, `EventSource` option must also be provided. EventSource cannot be `window.EventSource`, as it does not support passing a token.\");return function(e,r){var o,i=function(e,r){return Promise.resolve(f()).then(function(){var t=n.parse(e,{params:r});return Promise.resolve(n.evaluate(t,{dataset:m,params:r})).then(function(e){return e.get()})})},f=function(){try{return o||(o=function(e,r,t){var n=t.getDocuments,o=t.EventSource,i=e.projectId,u=e.dataset,s=e.overlayDrafts,c=e.documentLimit,f=e.token;if(!e.listen)return{unsubscribe:h,loaded:n({projectId:i,dataset:u,documentLimit:c,token:f}).then(S).then(h)};var m,p,w,b,g,y,E=new Map,P=[],j=new Promise(function(e,r){p=e,w=r});return{unsubscribe:d(o,e,{next:function(e){m?(function(e){if(e.effects&&!e.documentId.startsWith(\"_.\")){var r=E.get(e.documentId)||null;!function(e,r){var t=E.get(e),n=m||[],o=t?n.indexOf(t):-1;-1===o&&r?(n.push(r),E.set(e,r)):r?(n.splice(o,1,r),E.set(e,r)):(n.splice(o,1),E.delete(e))}(e.documentId,l(r,e.effects.apply))}}(e),function(e,r){clearTimeout(y),g!==r.transactionId&&b?(S(b),g=void 0):(g=r.transactionId,b=e.slice()),y=setTimeout(S,25,e.slice())}(m,e)):P.push(e)},open:function(){try{return Promise.resolve(n({projectId:i,dataset:u,documentLimit:c,token:f})).then(function(e){(m=function(e,r){var t=new Map;return r.forEach(function(e){var r=t.get(e.documentId)||[];r.push(e),t.set(e.documentId,r)}),t.forEach(function(r,t){var n=e.find(function(e){return e._id===t});if(n){var o=!1,i=n;r.forEach(function(e){(o=o||e.previousRev===n._rev)&&e.effects&&(i=l(i,e.effects.apply))}),e.splice(e.indexOf(n),1,i)}else console.warn(\"Received mutation for missing document %s\",t)}),e}(e,P)).forEach(function(e){return E.set(e._id,e)}),S(m),p()})}catch(e){return Promise.reject(e)}},error:function(e){return w(e)}}).unsubscribe,loaded:j};function S(e){b=void 0,y=void 0,g=void 0,r(s?function(e){var r=new Map;return e.forEach(function(e){var t=r.get(v(e));e._id.startsWith(\"drafts.\")?r.set(v(e),function(e){return a({},e,{_id:v(e)})}(e)):t||r.set(e._id,e)}),Array.from(r.values())}(e):e)}}(e,function(e){m=e,p()},r)),Promise.resolve(o.loaded).then(function(){})}catch(e){return Promise.reject(e)}},m=[],p=t.throttle(e.subscriptionThrottleMs||50,function(){w.forEach(b)}),w=[];function b(e){return i(e.query,e.params).then(function(r){\"previousResult\"in e&&s.default(e.previousResult,r)||(e.previousResult=r,e.callback(void 0,r))}).catch(function(r){e.callback(r)})}return{query:i,getDocument:function(e){return Promise.resolve(f()).then(function(){return i(u.default(c||(r=[\"*[_id == $id][0]\"],t||(t=r.slice(0)),r.raw=t,c=r)),{id:e});var r,t})},getDocuments:function(e){return Promise.resolve(f()).then(function(){var r=e.map(function(e){return'*[_id == \"'+e+'\"][0]'}).join(\",\\n\");return i(\"[\"+r+\"]\")})},subscribe:function(r,t,n){if(!e.listen)throw new Error(\"Cannot use `subscribe()` without `listen: true`\");var o={query:r,params:t,callback:n};w.push(o);var i=!1;return b(o),{unsubscribe:function(){return i||(i=!0,w.splice(w.indexOf(o),1)),Promise.resolve()}}},close:function(){return p.cancel(),o?o.unsubscribe():Promise.resolve()}}}(e,{EventSource:o,getDocuments:b})};\r\n//# sourceMappingURL=groq-store.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ncm9xLXN0b3JlL2Rpc3QvYnJvd3Nlci9ncm9xLXN0b3JlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sbUJBQU8sQ0FBQyw2Q0FBTSxJQUFJLG1CQUFPLENBQUMsZ0VBQWlCLElBQUksbUJBQU8sQ0FBQyx3RUFBbUIsSUFBSSxtQkFBTyxDQUFDLHNEQUFTLElBQUksbUJBQU8sQ0FBQyx3REFBUyxFQUFFLGNBQWMsK0NBQStDLFdBQVcsNENBQTRDLGFBQWEsd0RBQXdELFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHlCQUF5Qix3QkFBd0IsYUFBYSxxR0FBcUcsMERBQTBELGtCQUFrQiwySEFBMkgsOEJBQThCLDBCQUEwQixRQUFRLEVBQUUsa0VBQWtFLE1BQU0sSUFBSSxxQkFBcUIsU0FBUyxPQUFPLEtBQUssa0NBQWtDLE1BQU0sVUFBVSxJQUFJLHFCQUFxQixTQUFTLHlFQUF5RSwrRUFBK0UsMEJBQTBCLDhIQUE4SCxrREFBa0QsMEJBQTBCLDBHQUEwRyxHQUFHLHVCQUF1QixvQ0FBb0MsY0FBYyx3REFBd0QsZ0JBQWdCLFVBQVUsSUFBSSx1Q0FBdUMsYUFBYSx5QkFBeUIsa0JBQWtCLFNBQVMsbUJBQW1CLDBDQUEwQyxtQkFBbUIsbUVBQW1FLFlBQVksWUFBWSxTQUFTLDhCQUE4QixjQUFjLHNDQUFzQyxxQkFBcUIsTUFBTSxjQUFjLE1BQU0sSUFBSSxpQkFBaUIsU0FBUyxTQUFTLFNBQVMsWUFBWSwwQkFBMEIsSUFBSSxVQUFVLDZDQUE2QyxTQUFTLFVBQVUsR0FBRyxHQUFHLEdBQUcsY0FBYyw2QkFBNkIsa0JBQWtCLDBEQUEwRCxJQUFJLDhFQUE4RSxpQ0FBaUMsMEJBQTBCLFFBQVEsb0JBQW9CLGNBQWMsc0JBQXNCLDJEQUEyRCxXQUFXLGFBQWEsbUJBQW1CLDJCQUEyQixrQkFBa0IsZ0JBQWdCLDJCQUEyQiw0QkFBNEIsSUFBSSxrSkFBa0osZ0NBQWdDLFVBQVUsbUJBQW1CLGFBQWEsS0FBSyxrQkFBa0Isb0JBQW9CLHlCQUF5QixTQUFTLHlDQUF5QywrQ0FBK0Msb0JBQW9CLElBQUksaURBQWlELEtBQUssRUFBRSxTQUFTLFlBQVksb0NBQW9DLGVBQWUsV0FBVyxFQUFFLG9EQUFvRCxVQUFVLFNBQVMsMEJBQTBCLG9CQUFvQixrQkFBa0IsRUFBRSxVQUFVLEVBQUUsOENBQThDLE1BQU0sR0FBRyxVQUFVLGNBQWMsVUFBVSxLQUFLLE1BQU0sTUFBTSxVQUFVLDZCQUE2QixlQUFlLCtCQUErQiwrQ0FBK0MsY0FBYyxRQUFRLG9CQUFvQixFQUFFLCtDQUErQyxvQkFBb0IsOENBQThDLE9BQU8sU0FBUyxjQUFjLE1BQU0sR0FBRyxvQkFBb0IsOENBQThDLE1BQU0sNkNBQTZDLGVBQWUseUJBQXlCLGVBQWUsWUFBWSxrREFBa0QsZUFBZSw4SUFBOEkscUVBQXFFLHVLQUF1SyxFQUFFLFlBQVksY0FBYyxFQUFFLG9DQUFvQyxTQUFTLElBQUksaUJBQWlCLG9FQUFvRSxzSUFBc0ksTUFBTSxFQUFFLEdBQUcsK0JBQStCLEVBQUUsU0FBUywyQkFBMkIsd0NBQXFDLENBQUMsNkJBQTZCLGtCQUFrQixFQUFDLENBQUMsaUJBQWlCLGFBQWEsTUFBTSxZQUFZLGtFQUFrRSxxQkFBcUIsRUFBRSw0RkFBNEYsR0FBRyxtREFBbUQsa05BQWtOLHFCQUFxQixzQkFBc0IsNENBQTRDLGlCQUFpQixTQUFTLEVBQUUscUNBQXFDLG1CQUFtQixvQkFBb0IsZUFBZSxFQUFFLEVBQUUsY0FBYyxJQUFJLDZCQUE2Qiw2R0FBNkcsb0JBQW9CLHdCQUF3Qiw4Q0FBOEMsbUJBQW1CLDJEQUEyRCxRQUFRLEVBQUUsT0FBTyxtQkFBbUIsaUJBQWlCLGVBQWUsOENBQThDLGdDQUFnQyxlQUFlLDJDQUEyQyw0RkFBNEYscUNBQXFDLGtCQUFrQixvSEFBb0gsaUJBQWlCLGlCQUFpQixJQUFJLDBCQUEwQiw4Q0FBOEMsb0JBQW9CLGlCQUFpQixjQUFjLDZCQUE2Qiw4QkFBOEIsZ0NBQWdDLDBCQUEwQix5QkFBeUIsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLHNCQUFzQixtRUFBbUUsNkJBQTZCLGlFQUFpRSxJQUFJLDJCQUEyQixzQkFBc0IsV0FBVyxFQUFFLFNBQVMsMEJBQTBCLG1CQUFtQixhQUFhLHdCQUF3QixjQUFjLDJDQUEyQyxjQUFjLDZCQUE2QixrQkFBa0IsbURBQW1ELFdBQVcsSUFBSSxTQUFTLEVBQUUsdUJBQXVCLHlCQUF5QixRQUFRLGVBQWUsUUFBUSxnREFBZ0QsRUFBRSxTQUFTLDBCQUEwQiwyREFBMkQsYUFBYSxPQUFPLGNBQWMsNENBQTRDLCtGQUErRixvQkFBb0IsY0FBYyxFQUFFLE9BQU8sZ0NBQWdDLDRDQUE0QywrRUFBK0UsS0FBSyxFQUFFLFFBQVEsRUFBRSwwQkFBMEIsNENBQTRDLHdCQUF3Qiw2QkFBNkIsY0FBYyxvQkFBb0IsRUFBRSwyQkFBMkIsZ0ZBQWdGLE9BQU8sNkJBQTZCLFVBQVUsU0FBUyxhQUFhLHVCQUF1Qiw4REFBOEQsa0JBQWtCLHdEQUF3RCxJQUFJLDZCQUE2QjtBQUN6NFEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZ3JvcS1zdG9yZS9kaXN0L2Jyb3dzZXIvZ3JvcS1zdG9yZS5qcz9iOTExIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlPXJlcXVpcmUoXCJncm9xXCIpLHI9cmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKSx0PXJlcXVpcmUoXCJ0aHJvdHRsZS1kZWJvdW5jZVwiKSxuPXJlcXVpcmUoXCJncm9xLWpzXCIpLG89cmVxdWlyZShcIm1lbmRvemFcIik7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lOntkZWZhdWx0OmV9fXZhciB1PS8qI19fUFVSRV9fKi9pKGUpLHM9LyojX19QVVJFX18qL2kocik7ZnVuY3Rpb24gYSgpe3JldHVybiBhPU9iamVjdC5hc3NpZ24/T2JqZWN0LmFzc2lnbi5iaW5kKCk6ZnVuY3Rpb24oZSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dmFyIHQ9YXJndW1lbnRzW3JdO2Zvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKX1yZXR1cm4gZX0sYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGMsZj1mdW5jdGlvbihlLHIsdCl7KGZ1bmN0aW9uKGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJmUuYWRkRXZlbnRMaXN0ZW5lcj09PXdpbmRvdy5FdmVudFNvdXJjZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcn0pKGUpJiZlLmFkZEV2ZW50TGlzdGVuZXIocix0LCExKSxlLmFkZEV2ZW50TGlzdGVuZXIocix0KX07ZnVuY3Rpb24gZChlLHIsdCl7dmFyIG4sbz1yLnRva2VuLGk9bmV3IGUoXCJodHRwczovL1wiK3IucHJvamVjdElkK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9saXN0ZW4vXCIrci5kYXRhc2V0K1wiP3F1ZXJ5PSomZWZmZWN0Rm9ybWF0PW1lbmRvemFcIix7d2l0aENyZWRlbnRpYWxzOiEwLGhlYWRlcnM6bz97QXV0aG9yaXphdGlvbjpcIkJlYXJlciBcIitvfTp2b2lkIDB9KTtyZXR1cm4gZihpLFwid2VsY29tZVwiLHQub3BlbiksZihpLFwibXV0YXRpb25cIiwobj10Lm5leHQsZnVuY3Rpb24oZSl7dmFyIHI7dHJ5e3I9SlNPTi5wYXJzZShlLmRhdGEpfWNhdGNoKGUpe3JldHVybn1uKHIpfSkpLGYoaSxcImNoYW5uZWxFcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByO2kuY2xvc2UoKTt0cnl7cj1KU09OLnBhcnNlKGUuZGF0YSl9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgdC5lcnJvcihuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yIHBhcnNpbmcgbGlzdGVuZXIgbWVzc2FnZVwiKSl9dC5lcnJvcihuZXcgRXJyb3Ioci5tZXNzYWdlfHxyLmVycm9yfHxcIkxpc3RlbmVyIHJldHVybmVkIEhUVFAgXCIrci5zdGF0dXNDb2RlKSl9KSxmKGksXCJlcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5sb2NhdGlvbi5vcmlnaW4sbj1yP1wiLCBhbmQgdGhhdCB0aGUgQ09SUy1vcmlnaW4gKFwiK3IrXCIpIGlzIGFsbG93ZWRcIjpcIlwiLG89ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm1lc3NhZ2VcImluIGV9KGUpP1wiIChcIitlLm1lc3NhZ2UrXCIpXCI6XCJcIjt0LmVycm9yKG5ldyBFcnJvcihcIkVycm9yIGVzdGFibGlzaGluZyBsaXN0ZW5lciAtIGNoZWNrIHRoYXQgdGhlIHByb2plY3QgSUQgYW5kIGRhdGFzZXQgYXJlIGNvcnJlY3RcIituK28pKX0pLHt1bnN1YnNjcmliZTpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoaS5jbG9zZSgpKX19fWZ1bmN0aW9uIHYoZSl7cmV0dXJuIGUuX2lkLnN0YXJ0c1dpdGgoXCJkcmFmdHMuXCIpP2UuX2lkLnNsaWNlKDcpOmUuX2lkfWZ1bmN0aW9uIGwoZSxyKXt2YXIgdD1hKHt9LGUpO3JldHVybiBkZWxldGUgdC5fcmV2LG8uYXBwbHlQYXRjaCh0LHIpfWZ1bmN0aW9uIGgoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9ZnVuY3Rpb24gbShlLHIsdCl7aWYoIWUucyl7aWYodCBpbnN0YW5jZW9mIHApe2lmKCF0LnMpcmV0dXJuIHZvaWQodC5vPW0uYmluZChudWxsLGUscikpOzEmciYmKHI9dC5zKSx0PXQudn1pZih0JiZ0LnRoZW4pcmV0dXJuIHZvaWQgdC50aGVuKG0uYmluZChudWxsLGUsciksbS5iaW5kKG51bGwsZSwyKSk7ZS5zPXIsZS52PXQ7Y29uc3Qgbj1lLm87biYmbihlKX19dmFyIHA9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihyLHQpe3ZhciBuPW5ldyBlLG89dGhpcy5zO2lmKG8pe3ZhciBpPTEmbz9yOnQ7aWYoaSl7dHJ5e20obiwxLGkodGhpcy52KSl9Y2F0Y2goZSl7bShuLDIsZSl9cmV0dXJuIG59cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMubz1mdW5jdGlvbihlKXt0cnl7dmFyIG89ZS52OzEmZS5zP20obiwxLHI/cihvKTpvKTp0P20obiwxLHQobykpOm0obiwyLG8pfWNhdGNoKGUpe20obiwyLGUpfX0sbn0sZX0oKTtmdW5jdGlvbiB3KGUpe3JldHVybiBlIGluc3RhbmNlb2YgcCYmMSZlLnN9dmFyIGI9ZnVuY3Rpb24oZSl7dmFyIHI9ZS5wcm9qZWN0SWQsdD1lLmRhdGFzZXQsbj1lLnRva2VuLG89ZS5kb2N1bWVudExpbWl0O3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZldGNoKFwiaHR0cHM6Ly9cIityK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9leHBvcnQvXCIrdCx7Y3JlZGVudGlhbHM6XCJpbmNsdWRlXCIsaGVhZGVyczpuP3tBdXRob3JpemF0aW9uOlwiQmVhcmVyIFwiK259OnZvaWQgMH0pKS50aGVuKGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIocil7dmFyIHQsbixpPWZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZWFkIGJvZHkgZnJvbSByZXNwb25zZVwiKTt2YXIgcix0PSExO2Z1bmN0aW9uIG4oKXt0PSEwLHImJnIuY2FuY2VsKCl9cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7c3RhcnQ6ZnVuY3Rpb24obyl7cj1lLmdldFJlYWRlcigpO3ZhciBpPW5ldyBUZXh0RGVjb2Rlcix1PVwiXCI7ci5yZWFkKCkudGhlbihmdW5jdGlvbiBlKHMpe3RyeXtpZihzLmRvbmUpcmV0dXJuIHQ/UHJvbWlzZS5yZXNvbHZlKCk6MD09PSh1PXUudHJpbSgpKS5sZW5ndGg/KG8uY2xvc2UoKSxQcm9taXNlLnJlc29sdmUoKSk6KG8uZW5xdWV1ZShKU09OLnBhcnNlKHUpKSxvLmNsb3NlKCksUHJvbWlzZS5yZXNvbHZlKCkpO2Zvcih2YXIgYT0odSs9aS5kZWNvZGUocy52YWx1ZSx7c3RyZWFtOiEwfSkpLnNwbGl0KFwiXFxuXCIpLGM9MDtjPGEubGVuZ3RoLTE7KytjKXt2YXIgZj1hW2NdLnRyaW0oKTtpZigwIT09Zi5sZW5ndGgpdHJ5e28uZW5xdWV1ZShKU09OLnBhcnNlKGYpKX1jYXRjaChlKXtyZXR1cm4gby5lcnJvcihlKSxuKCksUHJvbWlzZS5yZXNvbHZlKCl9fWlmKHU9YVthLmxlbmd0aC0xXSwhcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7dmFyIGQ9ZnVuY3Rpb24odCxuKXt0cnl7dmFyIG89UHJvbWlzZS5yZXNvbHZlKHIucmVhZCgpKS50aGVuKGZ1bmN0aW9uKHIpe2Uocil9KX1jYXRjaChlKXtyZXR1cm4gbihlKX1yZXR1cm4gbyYmby50aGVuP28udGhlbih2b2lkIDAsbik6b30oMCxmdW5jdGlvbihlKXtvLmVycm9yKGUpfSk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShkJiZkLnRoZW4/ZC50aGVuKGZ1bmN0aW9uKCl7fSk6dm9pZCAwKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSkuY2F0Y2goZnVuY3Rpb24oZSl7cmV0dXJuIG8uZXJyb3IoZSl9KX0sY2FuY2VsOm59KX0oZS5ib2R5KSx1PWkuZ2V0UmVhZGVyKCkscz1bXSxhPWZ1bmN0aW9uKGUscil7dmFyIHQ7ZG97dmFyIG49ZSgpO2lmKG4mJm4udGhlbil7aWYoIXcobikpe3Q9ITA7YnJlYWt9bj1uLnZ9dmFyIG89cigpO2lmKHcobykmJihvPW8udiksIW8pcmV0dXJuIG59d2hpbGUoIW8udGhlbik7dmFyIGk9bmV3IHAsdT1tLmJpbmQobnVsbCxpLDIpO3JldHVybih0P24udGhlbihzKTpvLnRoZW4oYSkpLnRoZW4odm9pZCAwLHUpLGk7ZnVuY3Rpb24gcyh0KXtmb3Iobj10O3cobz1yKCkpJiYobz1vLnYpLG87KXtpZihvLnRoZW4pcmV0dXJuIHZvaWQgby50aGVuKGEpLnRoZW4odm9pZCAwLHUpO2lmKChuPWUoKSkmJm4udGhlbil7aWYoIXcobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fX1tKGksMSxuKX1mdW5jdGlvbiBhKHQpe2lmKHQpe2Rve2lmKChuPWUoKSkmJm4udGhlbil7aWYoIXcobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fWlmKHcodD1yKCkpJiYodD10LnYpLCF0KXJldHVybiB2b2lkIG0oaSwxLG4pfXdoaWxlKCF0LnRoZW4pO3QudGhlbihhKS50aGVuKHZvaWQgMCx1KX1lbHNlIG0oaSwxLG4pfX0oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUucmVhZCgpKS50aGVuKGZ1bmN0aW9uKGUpe2lmKGZ1bmN0aW9uKGUpe3JldHVybiEhZSYmXCJlcnJvclwiaW4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUuZXJyb3ImJm51bGwhPT1lLmVycm9yJiZcImRlc2NyaXB0aW9uXCJpbiBlLmVycm9yJiZcInN0cmluZ1wiPT10eXBlb2YgZS5lcnJvci5kZXNjcmlwdGlvbiYmIShcIl9pZFwiaW4gZSl9KG49KHQ9ZSkudmFsdWUpKXRocm93IG5ldyBFcnJvcihcIkVycm9yIHN0cmVhbWluZyBkYXRhc2V0OiBcIituLmVycm9yKTtpZihuJiYhbi5faWQuc3RhcnRzV2l0aChcIl8uXCIpJiZzLnB1c2gobiksbyYmcy5sZW5ndGg+byl0aHJvdyB1LmNhbmNlbChcIlJlYWNoZWQgZG9jdW1lbnQgbGltaXRcIiksbmV3IEVycm9yKFwiRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6IFJlYWNoZWQgbGltaXQgb2YgXCIrbytcIiBkb2N1bWVudHNcIil9KX0sZnVuY3Rpb24oKXtyZXR1cm4hdC5kb25lfSk7cmV0dXJuIGEmJmEudGhlbj9hLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHN9KTpzfXZhciB0PWZ1bmN0aW9uKCl7aWYoMjAwIT09ZS5zdGF0dXMpcmV0dXJuIFByb21pc2UucmVzb2x2ZShlLmpzb24oKSkudGhlbihmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBzdHJlYW1pbmcgZGF0YXNldDogXCIrKFwib2JqZWN0XCI9PXR5cGVvZihyPWUpJiZcImVycm9yXCJpbiByJiZcIm1lc3NhZ2VcImluIHI/ci5tZXNzYWdlfHxyLmVycm9yOlwiPHVua25vd24gZXJyb3I+XCIpKTt2YXIgcn0pfSgpO3JldHVybiB0JiZ0LnRoZW4/dC50aGVuKHIpOnIoKX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiZ3JvcVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmRlZmF1bHR9fSksZXhwb3J0cy5ncm9xU3RvcmU9ZnVuY3Rpb24oZSl7dmFyIHI7IWZ1bmN0aW9uKCl7dmFyIGU9W1wiRXZlbnRTb3VyY2VcIixcIlJlYWRhYmxlU3RyZWFtXCIsXCJmZXRjaFwiXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIShlIGluIHdpbmRvdyl9KTtpZihlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgbm90IHN1cHBvcnRlZC4gTWlzc2luZyBicm93c2VyIEFQSXM6IFwiK2Uuam9pbihcIiwgXCIpKX0oKTt2YXIgbz1udWxsIT0ocj1lLkV2ZW50U291cmNlKT9yOndpbmRvdy5FdmVudFNvdXJjZTtpZihlLnRva2VuJiZvPT09d2luZG93LkV2ZW50U291cmNlKXRocm93IG5ldyBFcnJvcihcIldoZW5gdG9rZW5gIG9wdGlvbiBpcyB1c2VkLCBgRXZlbnRTb3VyY2VgIG9wdGlvbiBtdXN0IGFsc28gYmUgcHJvdmlkZWQuIEV2ZW50U291cmNlIGNhbm5vdCBiZSBgd2luZG93LkV2ZW50U291cmNlYCwgYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBwYXNzaW5nIGEgdG9rZW4uXCIpO3JldHVybiBmdW5jdGlvbihlLHIpe3ZhciBvLGk9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbigpe3ZhciB0PW4ucGFyc2UoZSx7cGFyYW1zOnJ9KTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4uZXZhbHVhdGUodCx7ZGF0YXNldDptLHBhcmFtczpyfSkpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0KCl9KX0pfSxmPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBvfHwobz1mdW5jdGlvbihlLHIsdCl7dmFyIG49dC5nZXREb2N1bWVudHMsbz10LkV2ZW50U291cmNlLGk9ZS5wcm9qZWN0SWQsdT1lLmRhdGFzZXQscz1lLm92ZXJsYXlEcmFmdHMsYz1lLmRvY3VtZW50TGltaXQsZj1lLnRva2VuO2lmKCFlLmxpc3RlbilyZXR1cm57dW5zdWJzY3JpYmU6aCxsb2FkZWQ6bih7cHJvamVjdElkOmksZGF0YXNldDp1LGRvY3VtZW50TGltaXQ6Yyx0b2tlbjpmfSkudGhlbihTKS50aGVuKGgpfTt2YXIgbSxwLHcsYixnLHksRT1uZXcgTWFwLFA9W10saj1uZXcgUHJvbWlzZShmdW5jdGlvbihlLHIpe3A9ZSx3PXJ9KTtyZXR1cm57dW5zdWJzY3JpYmU6ZChvLGUse25leHQ6ZnVuY3Rpb24oZSl7bT8oZnVuY3Rpb24oZSl7aWYoZS5lZmZlY3RzJiYhZS5kb2N1bWVudElkLnN0YXJ0c1dpdGgoXCJfLlwiKSl7dmFyIHI9RS5nZXQoZS5kb2N1bWVudElkKXx8bnVsbDshZnVuY3Rpb24oZSxyKXt2YXIgdD1FLmdldChlKSxuPW18fFtdLG89dD9uLmluZGV4T2YodCk6LTE7LTE9PT1vJiZyPyhuLnB1c2gociksRS5zZXQoZSxyKSk6cj8obi5zcGxpY2UobywxLHIpLEUuc2V0KGUscikpOihuLnNwbGljZShvLDEpLEUuZGVsZXRlKGUpKX0oZS5kb2N1bWVudElkLGwocixlLmVmZmVjdHMuYXBwbHkpKX19KGUpLGZ1bmN0aW9uKGUscil7Y2xlYXJUaW1lb3V0KHkpLGchPT1yLnRyYW5zYWN0aW9uSWQmJmI/KFMoYiksZz12b2lkIDApOihnPXIudHJhbnNhY3Rpb25JZCxiPWUuc2xpY2UoKSkseT1zZXRUaW1lb3V0KFMsMjUsZS5zbGljZSgpKX0obSxlKSk6UC5wdXNoKGUpfSxvcGVuOmZ1bmN0aW9uKCl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUobih7cHJvamVjdElkOmksZGF0YXNldDp1LGRvY3VtZW50TGltaXQ6Yyx0b2tlbjpmfSkpLnRoZW4oZnVuY3Rpb24oZSl7KG09ZnVuY3Rpb24oZSxyKXt2YXIgdD1uZXcgTWFwO3JldHVybiByLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHI9dC5nZXQoZS5kb2N1bWVudElkKXx8W107ci5wdXNoKGUpLHQuc2V0KGUuZG9jdW1lbnRJZCxyKX0pLHQuZm9yRWFjaChmdW5jdGlvbihyLHQpe3ZhciBuPWUuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gZS5faWQ9PT10fSk7aWYobil7dmFyIG89ITEsaT1uO3IuZm9yRWFjaChmdW5jdGlvbihlKXsobz1vfHxlLnByZXZpb3VzUmV2PT09bi5fcmV2KSYmZS5lZmZlY3RzJiYoaT1sKGksZS5lZmZlY3RzLmFwcGx5KSl9KSxlLnNwbGljZShlLmluZGV4T2YobiksMSxpKX1lbHNlIGNvbnNvbGUud2FybihcIlJlY2VpdmVkIG11dGF0aW9uIGZvciBtaXNzaW5nIGRvY3VtZW50ICVzXCIsdCl9KSxlfShlLFApKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBFLnNldChlLl9pZCxlKX0pLFMobSkscCgpfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sZXJyb3I6ZnVuY3Rpb24oZSl7cmV0dXJuIHcoZSl9fSkudW5zdWJzY3JpYmUsbG9hZGVkOmp9O2Z1bmN0aW9uIFMoZSl7Yj12b2lkIDAseT12b2lkIDAsZz12b2lkIDAscihzP2Z1bmN0aW9uKGUpe3ZhciByPW5ldyBNYXA7cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1yLmdldCh2KGUpKTtlLl9pZC5zdGFydHNXaXRoKFwiZHJhZnRzLlwiKT9yLnNldCh2KGUpLGZ1bmN0aW9uKGUpe3JldHVybiBhKHt9LGUse19pZDp2KGUpfSl9KGUpKTp0fHxyLnNldChlLl9pZCxlKX0pLEFycmF5LmZyb20oci52YWx1ZXMoKSl9KGUpOmUpfX0oZSxmdW5jdGlvbihlKXttPWUscCgpfSxyKSksUHJvbWlzZS5yZXNvbHZlKG8ubG9hZGVkKS50aGVuKGZ1bmN0aW9uKCl7fSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sbT1bXSxwPXQudGhyb3R0bGUoZS5zdWJzY3JpcHRpb25UaHJvdHRsZU1zfHw1MCxmdW5jdGlvbigpe3cuZm9yRWFjaChiKX0pLHc9W107ZnVuY3Rpb24gYihlKXtyZXR1cm4gaShlLnF1ZXJ5LGUucGFyYW1zKS50aGVuKGZ1bmN0aW9uKHIpe1wicHJldmlvdXNSZXN1bHRcImluIGUmJnMuZGVmYXVsdChlLnByZXZpb3VzUmVzdWx0LHIpfHwoZS5wcmV2aW91c1Jlc3VsdD1yLGUuY2FsbGJhY2sodm9pZCAwLHIpKX0pLmNhdGNoKGZ1bmN0aW9uKHIpe2UuY2FsbGJhY2socil9KX1yZXR1cm57cXVlcnk6aSxnZXREb2N1bWVudDpmdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBpKHUuZGVmYXVsdChjfHwocj1bXCIqW19pZCA9PSAkaWRdWzBdXCJdLHR8fCh0PXIuc2xpY2UoMCkpLHIucmF3PXQsYz1yKSkse2lkOmV9KTt2YXIgcix0fSl9LGdldERvY3VtZW50czpmdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbigpe3ZhciByPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybicqW19pZCA9PSBcIicrZSsnXCJdWzBdJ30pLmpvaW4oXCIsXFxuXCIpO3JldHVybiBpKFwiW1wiK3IrXCJdXCIpfSl9LHN1YnNjcmliZTpmdW5jdGlvbihyLHQsbil7aWYoIWUubGlzdGVuKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYHN1YnNjcmliZSgpYCB3aXRob3V0IGBsaXN0ZW46IHRydWVgXCIpO3ZhciBvPXtxdWVyeTpyLHBhcmFtczp0LGNhbGxiYWNrOm59O3cucHVzaChvKTt2YXIgaT0hMTtyZXR1cm4gYihvKSx7dW5zdWJzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm4gaXx8KGk9ITAsdy5zcGxpY2Uody5pbmRleE9mKG8pLDEpKSxQcm9taXNlLnJlc29sdmUoKX19fSxjbG9zZTpmdW5jdGlvbigpe3JldHVybiBwLmNhbmNlbCgpLG8/by51bnN1YnNjcmliZSgpOlByb21pc2UucmVzb2x2ZSgpfX19KGUse0V2ZW50U291cmNlOm8sZ2V0RG9jdW1lbnRzOmJ9KX07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3Etc3RvcmUuanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@sanity/groq-store/dist/browser/groq-store.js\n"));

/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\n\r\n// do not edit .js files directly - edit src/index.jst\r\n\r\n\r\n\r\nmodule.exports = function equal(a, b) {\r\n  if (a === b) return true;\r\n\r\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\r\n    if (a.constructor !== b.constructor) return false;\r\n\r\n    var length, i, keys;\r\n    if (Array.isArray(a)) {\r\n      length = a.length;\r\n      if (length != b.length) return false;\r\n      for (i = length; i-- !== 0;)\r\n        if (!equal(a[i], b[i])) return false;\r\n      return true;\r\n    }\r\n\r\n\r\n\r\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\r\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\r\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\r\n\r\n    keys = Object.keys(a);\r\n    length = keys.length;\r\n    if (length !== Object.keys(b).length) return false;\r\n\r\n    for (i = length; i-- !== 0;)\r\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\r\n\r\n    for (i = length; i-- !== 0;) {\r\n      var key = keys[i];\r\n\r\n      if (!equal(a[key], b[key])) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // true if both NaN, false otherwise\r\n  return a!==a && b!==b;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanM/MGJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XHJcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xyXG5cclxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XHJcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xyXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcclxuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXHJcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcclxuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcclxuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XHJcblxyXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXHJcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XHJcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG5cclxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxyXG4gIHJldHVybiBhIT09YSAmJiBiIT09YjtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fast-deep-equal/index.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/incremental-patcher.js":
/*!*************************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/incremental-patcher.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; },\n/* harmony export */   \"getType\": function() { return /* binding */ getType; },\n/* harmony export */   \"rebaseValue\": function() { return /* binding */ rebaseValue; },\n/* harmony export */   \"unwrap\": function() { return /* binding */ unwrap; },\n/* harmony export */   \"wrap\": function() { return /* binding */ wrap; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\r\n\r\nvar Model = /** @class */ (function () {\r\n    function Model(meta) {\r\n        this.meta = meta;\r\n    }\r\n    Model.prototype.wrap = function (data) {\r\n        return this.wrapWithMeta(data, this.meta, this.meta);\r\n    };\r\n    Model.prototype.wrapWithMeta = function (data, startMeta, endMeta) {\r\n        if (endMeta === void 0) { endMeta = this.meta; }\r\n        return { data: data, startMeta: startMeta, endMeta: endMeta };\r\n    };\r\n    Model.prototype.asObject = function (value) {\r\n        if (!value.content) {\r\n            var fields = {};\r\n            for (var _i = 0, _a = Object.entries(value.data); _i < _a.length; _i++) {\r\n                var _b = _a[_i], key = _b[0], val = _b[1];\r\n                fields[key] = this.wrapWithMeta(val, value.startMeta);\r\n            }\r\n            value.content = { type: 'object', fields: fields };\r\n        }\r\n        return value.content;\r\n    };\r\n    Model.prototype.asArray = function (value) {\r\n        var _this = this;\r\n        if (!value.content) {\r\n            var elements = value.data.map(function (item) { return _this.wrapWithMeta(item, value.startMeta); });\r\n            var metas = elements.map(function () { return _this.meta; });\r\n            value.content = { type: 'array', elements: elements, metas: metas };\r\n        }\r\n        return value.content;\r\n    };\r\n    Model.prototype.asString = function (value) {\r\n        if (!value.content) {\r\n            var str = value.data;\r\n            var part = {\r\n                value: str,\r\n                utf8size: (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(str),\r\n                uses: [],\r\n                startMeta: value.startMeta,\r\n                endMeta: value.endMeta\r\n            };\r\n            value.content = this.stringFromParts([part]);\r\n        }\r\n        return value.content;\r\n    };\r\n    Model.prototype.stringFromParts = function (parts) {\r\n        var str = {\r\n            type: 'string',\r\n            parts: parts\r\n        };\r\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\r\n            var part = parts_1[_i];\r\n            part.uses.push(str);\r\n        }\r\n        return str;\r\n    };\r\n    Model.prototype.objectGetKeys = function (value) {\r\n        if (value.content) {\r\n            return Object.keys(value.content.fields);\r\n        }\r\n        else {\r\n            return Object.keys(value.data);\r\n        }\r\n    };\r\n    Model.prototype.objectGetField = function (value, key) {\r\n        var obj = this.asObject(value);\r\n        return obj.fields[key];\r\n    };\r\n    Model.prototype.arrayGetElement = function (value, idx) {\r\n        var arr = this.asArray(value);\r\n        return arr.elements[idx];\r\n    };\r\n    Model.prototype.finalize = function (content) {\r\n        this.updateEndMeta(content);\r\n        return { content: content, startMeta: this.meta, endMeta: this.meta };\r\n    };\r\n    Model.prototype.markChanged = function (value) {\r\n        return this.wrap(unwrap(value));\r\n    };\r\n    Model.prototype.updateEndMeta = function (content) {\r\n        if (content.type == 'string') {\r\n            for (var _i = 0, _a = content.parts; _i < _a.length; _i++) {\r\n                var part = _a[_i];\r\n                part.endMeta = this.meta;\r\n            }\r\n        }\r\n        else {\r\n            if (content.type === 'array') {\r\n                for (var _b = 0, _c = content.elements; _b < _c.length; _b++) {\r\n                    var val = _c[_b];\r\n                    if (val.content && val.endMeta !== this.meta) {\r\n                        this.updateEndMeta(val.content);\r\n                    }\r\n                    val.endMeta = this.meta;\r\n                }\r\n            }\r\n            else {\r\n                for (var _d = 0, _e = Object.values(content.fields); _d < _e.length; _d++) {\r\n                    var val = _e[_d];\r\n                    if (val.content && val.endMeta !== this.meta) {\r\n                        this.updateEndMeta(val.content);\r\n                    }\r\n                    val.endMeta = this.meta;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Model.prototype.copyString = function (value) {\r\n        if (value) {\r\n            var other = this.asString(value);\r\n            return this.stringFromParts(other.parts.slice());\r\n        }\r\n        else {\r\n            return {\r\n                type: 'string',\r\n                parts: []\r\n            };\r\n        }\r\n    };\r\n    Model.prototype.copyObject = function (value) {\r\n        var obj = {\r\n            type: 'object',\r\n            fields: {}\r\n        };\r\n        if (value) {\r\n            var other = this.asObject(value);\r\n            Object.assign(obj.fields, other.fields);\r\n        }\r\n        return obj;\r\n    };\r\n    Model.prototype.copyArray = function (value) {\r\n        var arr = value ? this.asArray(value) : null;\r\n        var elements = arr ? arr.elements : [];\r\n        var metas = arr ? arr.metas : [];\r\n        return {\r\n            type: 'array',\r\n            elements: elements,\r\n            metas: metas\r\n        };\r\n    };\r\n    Model.prototype.objectSetField = function (target, key, value) {\r\n        target.fields[key] = value;\r\n    };\r\n    Model.prototype.objectDeleteField = function (target, key) {\r\n        delete target.fields[key];\r\n    };\r\n    Model.prototype.arrayAppendValue = function (target, value) {\r\n        target.elements.push(value);\r\n        target.metas.push(this.meta);\r\n    };\r\n    Model.prototype.arrayAppendSlice = function (target, source, left, right) {\r\n        var _a, _b;\r\n        var arr = this.asArray(source);\r\n        var samePosition = arr.elements.length === left;\r\n        (_a = target.elements).push.apply(_a, arr.elements.slice(left, right));\r\n        if (samePosition) {\r\n            (_b = target.metas).push.apply(_b, arr.metas.slice(left, right));\r\n        }\r\n        else {\r\n            for (var i = left; i < right; i++) {\r\n                target.metas.push(this.meta);\r\n            }\r\n        }\r\n    };\r\n    Model.prototype.stringAppendValue = function (target, value) {\r\n        var str = this.asString(value);\r\n        for (var _i = 0, _a = str.parts; _i < _a.length; _i++) {\r\n            var part = _a[_i];\r\n            this.stringAppendPart(target, part);\r\n        }\r\n    };\r\n    Model.prototype.stringAppendPart = function (target, part) {\r\n        target.parts.push(part);\r\n        part.uses.push(target);\r\n    };\r\n    Model.prototype.resolveStringPart = function (str, from, len) {\r\n        if (len === 0)\r\n            return from;\r\n        for (var i = from; i < str.parts.length; i++) {\r\n            var part = str.parts[i];\r\n            if (len === part.utf8size) {\r\n                // Matches perfect!\r\n                return i + 1;\r\n            }\r\n            if (len < part.utf8size) {\r\n                // It's a part of this chunk. We now need to split it up.\r\n                this.splitString(part, len);\r\n                return i + 1;\r\n            }\r\n            len -= part.utf8size;\r\n        }\r\n        throw new Error('splitting string out of bounds');\r\n    };\r\n    Model.prototype.splitString = function (part, idx) {\r\n        var leftValue;\r\n        var rightValue;\r\n        var leftSize = idx;\r\n        var rightSize = part.utf8size - leftSize;\r\n        // idx is here in UTF-8 index, not codepoint index.\r\n        // This means we might to adjust for multi-byte characters.\r\n        if (part.utf8size !== part.value.length) {\r\n            var byteCount = 0;\r\n            for (idx = 0; byteCount < leftSize; idx++) {\r\n                var code = part.value.codePointAt(idx);\r\n                var size = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8charSize)(code);\r\n                if (size === 4)\r\n                    idx++; // Surrogate pair.\r\n                byteCount += size;\r\n            }\r\n        }\r\n        leftValue = part.value.slice(0, idx);\r\n        rightValue = part.value.slice(idx);\r\n        var newPart = {\r\n            value: rightValue,\r\n            utf8size: rightSize,\r\n            uses: part.uses.slice(),\r\n            startMeta: part.startMeta,\r\n            endMeta: part.endMeta\r\n        };\r\n        part.value = leftValue;\r\n        part.utf8size = leftSize;\r\n        for (var _i = 0, _a = part.uses; _i < _a.length; _i++) {\r\n            var use = _a[_i];\r\n            // Insert the new part.\r\n            var idx_1 = use.parts.indexOf(part);\r\n            if (idx_1 === -1)\r\n                throw new Error('bug: mismatch between string parts and use.');\r\n            use.parts.splice(idx_1 + 1, 0, newPart);\r\n        }\r\n    };\r\n    Model.prototype.stringAppendSlice = function (target, source, left, right) {\r\n        var str = this.asString(source);\r\n        var firstPart = this.resolveStringPart(str, 0, left);\r\n        var lastPart = this.resolveStringPart(str, firstPart, right - left);\r\n        for (var i = firstPart; i < lastPart; i++) {\r\n            var part = str.parts[i];\r\n            this.stringAppendPart(target, part);\r\n        }\r\n    };\r\n    return Model;\r\n}());\r\n// Turns a native JavaScript object into a Value with a given origin.\r\nfunction wrap(data, meta) {\r\n    return { data: data, startMeta: meta, endMeta: meta };\r\n}\r\n// Converts a Value into a native JavaScript type.\r\nfunction unwrap(value) {\r\n    if (typeof value.data !== 'undefined')\r\n        return value.data;\r\n    var result;\r\n    var content = value.content;\r\n    switch (content.type) {\r\n        case 'string':\r\n            result = content.parts.map(function (part) { return part.value; }).join('');\r\n            break;\r\n        case 'array':\r\n            result = content.elements.map(function (val) { return unwrap(val); });\r\n            break;\r\n        case 'object': {\r\n            result = {};\r\n            for (var _i = 0, _a = Object.entries(content.fields); _i < _a.length; _i++) {\r\n                var _b = _a[_i], key = _b[0], val = _b[1];\r\n                result[key] = unwrap(val);\r\n            }\r\n        }\r\n    }\r\n    value.data = result;\r\n    return result;\r\n}\r\n// Returns the type of a Value.\r\nfunction getType(value) {\r\n    if (value.content)\r\n        return value.content.type;\r\n    if (Array.isArray(value.data))\r\n        return 'array';\r\n    if (value.data === null)\r\n        return 'null';\r\n    return typeof value.data;\r\n}\r\n// Updates the `right` value such that it reuses as much as possible from the `left` value.\r\nfunction rebaseValue(left, right) {\r\n    var leftType = getType(left);\r\n    var rightType = getType(right);\r\n    if (leftType !== rightType)\r\n        return right;\r\n    var leftModel = new Model(left.endMeta);\r\n    var rightModel = new Model(right.endMeta);\r\n    switch (leftType) {\r\n        case 'object': {\r\n            var leftObj = leftModel.asObject(left);\r\n            var rightObj = rightModel.asObject(right);\r\n            // Number of fields which are identical in left and right.\r\n            var identicalFieldCount = 0;\r\n            var leftFieldCount = Object.keys(leftObj.fields).length;\r\n            var rightFieldCount = Object.keys(rightObj.fields).length;\r\n            for (var _i = 0, _a = Object.entries(rightObj.fields); _i < _a.length; _i++) {\r\n                var _b = _a[_i], key = _b[0], rightVal = _b[1];\r\n                var leftVal = leftObj.fields[key];\r\n                if (leftVal) {\r\n                    rightObj.fields[key] = rebaseValue(leftVal, rightVal);\r\n                    if (rightObj.fields[key] === leftVal) {\r\n                        identicalFieldCount++;\r\n                    }\r\n                }\r\n            }\r\n            var isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\r\n            return isIdentical ? left : right;\r\n        }\r\n        case 'array': {\r\n            var leftArr = leftModel.asArray(left);\r\n            var rightArr = rightModel.asArray(right);\r\n            if (leftArr.elements.length !== rightArr.elements.length) {\r\n                break;\r\n            }\r\n            var numRebased = 0;\r\n            for (var i = 0; i < rightArr.elements.length; i++) {\r\n                rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\r\n                if (rightArr.elements[i] !== leftArr.elements[i]) {\r\n                    numRebased++;\r\n                }\r\n            }\r\n            return numRebased === 0 ? left : right;\r\n        }\r\n        case 'null':\r\n        case 'boolean':\r\n        case 'number': {\r\n            if (unwrap(left) === unwrap(right))\r\n                return left;\r\n            break;\r\n        }\r\n        case 'string': {\r\n            var leftRaw = unwrap(left);\r\n            var rightRaw = unwrap(right);\r\n            if (leftRaw === rightRaw)\r\n                return left;\r\n            var result = rightModel.copyString(null);\r\n            var prefix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonPrefix)(leftRaw, rightRaw);\r\n            var suffix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonSuffix)(leftRaw, rightRaw, prefix);\r\n            var rightLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(rightRaw);\r\n            var leftLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(leftRaw);\r\n            if (0 < prefix) {\r\n                rightModel.stringAppendSlice(result, left, 0, prefix);\r\n            }\r\n            if (prefix < rightLen - suffix) {\r\n                rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\r\n            }\r\n            if (leftLen - suffix < leftLen) {\r\n                rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\r\n            }\r\n            var value = rightModel.finalize(result);\r\n            if (unwrap(value) !== rightRaw)\r\n                throw new Error('incorrect string rebase');\r\n            return value;\r\n        }\r\n    }\r\n    return right;\r\n}\r\nfunction applyPatch(left, patch, startMeta) {\r\n    var model = new Model(startMeta);\r\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(model, left, patch);\r\n    return patcher.process();\r\n}\r\n//# sourceMappingURL=incremental-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2QztBQUNxQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtREFBbUQ7QUFDL0csbURBQW1ELG9CQUFvQjtBQUN2RSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxnQkFBZ0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0EsMkJBQTJCLG1EQUFZO0FBQ3ZDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1EQUFZO0FBQ3JDLHlCQUF5QixtREFBWTtBQUNyQywyQkFBMkIscURBQWM7QUFDekMsMEJBQTBCLHFEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanM/ZTZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRjaGVyIH0gZnJvbSAnLi9pbnRlcm5hbC1wYXRjaGVyJztcclxuaW1wb3J0IHsgdXRmOGNoYXJTaXplLCB1dGY4c3RyaW5nU2l6ZSwgY29tbW9uUHJlZml4LCBjb21tb25TdWZmaXggfSBmcm9tICcuL3V0ZjgnO1xyXG52YXIgTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb2RlbChtZXRhKSB7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53cmFwV2l0aE1ldGEoZGF0YSwgdGhpcy5tZXRhLCB0aGlzLm1ldGEpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwV2l0aE1ldGEgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnRNZXRhLCBlbmRNZXRhKSB7XHJcbiAgICAgICAgaWYgKGVuZE1ldGEgPT09IHZvaWQgMCkgeyBlbmRNZXRhID0gdGhpcy5tZXRhOyB9XHJcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSwgc3RhcnRNZXRhOiBzdGFydE1ldGEsIGVuZE1ldGE6IGVuZE1ldGEgfTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModmFsdWUuZGF0YSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGtleSA9IF9iWzBdLCB2YWwgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gdGhpcy53cmFwV2l0aE1ldGEodmFsLCB2YWx1ZS5zdGFydE1ldGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB7IHR5cGU6ICdvYmplY3QnLCBmaWVsZHM6IGZpZWxkcyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHZhbHVlLmRhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBfdGhpcy53cmFwV2l0aE1ldGEoaXRlbSwgdmFsdWUuc3RhcnRNZXRhKTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBtZXRhcyA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXRhOyB9KTtcclxuICAgICAgICAgICAgdmFsdWUuY29udGVudCA9IHsgdHlwZTogJ2FycmF5JywgZWxlbWVudHM6IGVsZW1lbnRzLCBtZXRhczogbWV0YXMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFzU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSB2YWx1ZS5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcbiAgICAgICAgICAgICAgICB1dGY4c2l6ZTogdXRmOHN0cmluZ1NpemUoc3RyKSxcclxuICAgICAgICAgICAgICAgIHVzZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRNZXRhOiB2YWx1ZS5zdGFydE1ldGEsXHJcbiAgICAgICAgICAgICAgICBlbmRNZXRhOiB2YWx1ZS5lbmRNZXRhXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhbcGFydF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RyaW5nRnJvbVBhcnRzID0gZnVuY3Rpb24gKHBhcnRzKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICAgICAgICAgIHBhcnRzOiBwYXJ0c1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYXJ0c18xID0gcGFydHM7IF9pIDwgcGFydHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c18xW19pXTtcclxuICAgICAgICAgICAgcGFydC51c2VzLnB1c2goc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0R2V0S2V5cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5jb250ZW50LmZpZWxkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3RHZXRGaWVsZCA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuYXNPYmplY3QodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBvYmouZmllbGRzW2tleV07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5R2V0RWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XHJcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuYXNBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGFyci5lbGVtZW50c1tpZHhdO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKGNvbnRlbnQpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnRlbnQ6IGNvbnRlbnQsIHN0YXJ0TWV0YTogdGhpcy5tZXRhLCBlbmRNZXRhOiB0aGlzLm1ldGEgfTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUubWFya0NoYW5nZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKHVud3JhcCh2YWx1ZSkpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS51cGRhdGVFbmRNZXRhID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICBpZiAoY29udGVudC50eXBlID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZW50LnBhcnRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmVuZE1ldGEgPSB0aGlzLm1ldGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50LnR5cGUgPT09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBjb250ZW50LmVsZW1lbnRzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gT2JqZWN0LnZhbHVlcyhjb250ZW50LmZpZWxkcyk7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9lW19kXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmNvbnRlbnQgJiYgdmFsLmVuZE1ldGEgIT09IHRoaXMubWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWwuZW5kTWV0YSA9IHRoaXMubWV0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nRnJvbVBhcnRzKG90aGVyLnBhcnRzLnNsaWNlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgICAgICAgICAgICAgcGFydHM6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5T2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXHJcbiAgICAgICAgICAgIGZpZWxkczoge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvYmouZmllbGRzLCBvdGhlci5maWVsZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5QXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgYXJyID0gdmFsdWUgPyB0aGlzLmFzQXJyYXkodmFsdWUpIDogbnVsbDtcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSBhcnIgPyBhcnIuZWxlbWVudHMgOiBbXTtcclxuICAgICAgICB2YXIgbWV0YXMgPSBhcnIgPyBhcnIubWV0YXMgOiBbXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxyXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXHJcbiAgICAgICAgICAgIG1ldGFzOiBtZXRhc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdFNldEZpZWxkID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRhcmdldC5maWVsZHNba2V5XSA9IHZhbHVlO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3REZWxldGVGaWVsZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGRlbGV0ZSB0YXJnZXQuZmllbGRzW2tleV07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5QXBwZW5kVmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xyXG4gICAgICAgIHRhcmdldC5lbGVtZW50cy5wdXNoKHZhbHVlKTtcclxuICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUFwcGVuZFNsaWNlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuYXNBcnJheShzb3VyY2UpO1xyXG4gICAgICAgIHZhciBzYW1lUG9zaXRpb24gPSBhcnIuZWxlbWVudHMubGVuZ3RoID09PSBsZWZ0O1xyXG4gICAgICAgIChfYSA9IHRhcmdldC5lbGVtZW50cykucHVzaC5hcHBseShfYSwgYXJyLmVsZW1lbnRzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XHJcbiAgICAgICAgaWYgKHNhbWVQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAoX2IgPSB0YXJnZXQubWV0YXMpLnB1c2guYXBwbHkoX2IsIGFyci5tZXRhcy5zbGljZShsZWZ0LCByaWdodCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlZnQ7IGkgPCByaWdodDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdHIucGFydHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0FwcGVuZFBhcnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJ0KSB7XHJcbiAgICAgICAgdGFyZ2V0LnBhcnRzLnB1c2gocGFydCk7XHJcbiAgICAgICAgcGFydC51c2VzLnB1c2godGFyZ2V0KTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUucmVzb2x2ZVN0cmluZ1BhcnQgPSBmdW5jdGlvbiAoc3RyLCBmcm9tLCBsZW4pIHtcclxuICAgICAgICBpZiAobGVuID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbTtcclxuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHN0ci5wYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IHN0ci5wYXJ0c1tpXTtcclxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gcGFydC51dGY4c2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlcyBwZXJmZWN0IVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZW4gPCBwYXJ0LnV0ZjhzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgcGFydCBvZiB0aGlzIGNodW5rLiBXZSBub3cgbmVlZCB0byBzcGxpdCBpdCB1cC5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRTdHJpbmcocGFydCwgbGVuKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW4gLT0gcGFydC51dGY4c2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdHRpbmcgc3RyaW5nIG91dCBvZiBib3VuZHMnKTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuc3BsaXRTdHJpbmcgPSBmdW5jdGlvbiAocGFydCwgaWR4KSB7XHJcbiAgICAgICAgdmFyIGxlZnRWYWx1ZTtcclxuICAgICAgICB2YXIgcmlnaHRWYWx1ZTtcclxuICAgICAgICB2YXIgbGVmdFNpemUgPSBpZHg7XHJcbiAgICAgICAgdmFyIHJpZ2h0U2l6ZSA9IHBhcnQudXRmOHNpemUgLSBsZWZ0U2l6ZTtcclxuICAgICAgICAvLyBpZHggaXMgaGVyZSBpbiBVVEYtOCBpbmRleCwgbm90IGNvZGVwb2ludCBpbmRleC5cclxuICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIG1pZ2h0IHRvIGFkanVzdCBmb3IgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGlmIChwYXJ0LnV0ZjhzaXplICE9PSBwYXJ0LnZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgYnl0ZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yIChpZHggPSAwOyBieXRlQ291bnQgPCBsZWZ0U2l6ZTsgaWR4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gcGFydC52YWx1ZS5jb2RlUG9pbnRBdChpZHgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gNClcclxuICAgICAgICAgICAgICAgICAgICBpZHgrKzsgLy8gU3Vycm9nYXRlIHBhaXIuXHJcbiAgICAgICAgICAgICAgICBieXRlQ291bnQgKz0gc2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZWZ0VmFsdWUgPSBwYXJ0LnZhbHVlLnNsaWNlKDAsIGlkeCk7XHJcbiAgICAgICAgcmlnaHRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoaWR4KTtcclxuICAgICAgICB2YXIgbmV3UGFydCA9IHtcclxuICAgICAgICAgICAgdmFsdWU6IHJpZ2h0VmFsdWUsXHJcbiAgICAgICAgICAgIHV0ZjhzaXplOiByaWdodFNpemUsXHJcbiAgICAgICAgICAgIHVzZXM6IHBhcnQudXNlcy5zbGljZSgpLFxyXG4gICAgICAgICAgICBzdGFydE1ldGE6IHBhcnQuc3RhcnRNZXRhLFxyXG4gICAgICAgICAgICBlbmRNZXRhOiBwYXJ0LmVuZE1ldGFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBhcnQudmFsdWUgPSBsZWZ0VmFsdWU7XHJcbiAgICAgICAgcGFydC51dGY4c2l6ZSA9IGxlZnRTaXplO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBwYXJ0LnVzZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1c2UgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbmV3IHBhcnQuXHJcbiAgICAgICAgICAgIHZhciBpZHhfMSA9IHVzZS5wYXJ0cy5pbmRleE9mKHBhcnQpO1xyXG4gICAgICAgICAgICBpZiAoaWR4XzEgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWc6IG1pc21hdGNoIGJldHdlZW4gc3RyaW5nIHBhcnRzIGFuZCB1c2UuJyk7XHJcbiAgICAgICAgICAgIHVzZS5wYXJ0cy5zcGxpY2UoaWR4XzEgKyAxLCAwLCBuZXdQYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0FwcGVuZFNsaWNlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmFzU3RyaW5nKHNvdXJjZSk7XHJcbiAgICAgICAgdmFyIGZpcnN0UGFydCA9IHRoaXMucmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCAwLCBsZWZ0KTtcclxuICAgICAgICB2YXIgbGFzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgZmlyc3RQYXJ0LCByaWdodCAtIGxlZnQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBmaXJzdFBhcnQ7IGkgPCBsYXN0UGFydDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gc3RyLnBhcnRzW2ldO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vZGVsO1xyXG59KCkpO1xyXG4vLyBUdXJucyBhIG5hdGl2ZSBKYXZhU2NyaXB0IG9iamVjdCBpbnRvIGEgVmFsdWUgd2l0aCBhIGdpdmVuIG9yaWdpbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXAoZGF0YSwgbWV0YSkge1xyXG4gICAgcmV0dXJuIHsgZGF0YTogZGF0YSwgc3RhcnRNZXRhOiBtZXRhLCBlbmRNZXRhOiBtZXRhIH07XHJcbn1cclxuLy8gQ29udmVydHMgYSBWYWx1ZSBpbnRvIGEgbmF0aXZlIEphdmFTY3JpcHQgdHlwZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcCh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5kYXRhICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICByZXR1cm4gdmFsdWUuZGF0YTtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICB2YXIgY29udGVudCA9IHZhbHVlLmNvbnRlbnQ7XHJcbiAgICBzd2l0Y2ggKGNvbnRlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRlbnQucGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnZhbHVlOyB9KS5qb2luKCcnKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYXJyYXknOlxyXG4gICAgICAgICAgICByZXN1bHQgPSBjb250ZW50LmVsZW1lbnRzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiB1bndyYXAodmFsKTsgfSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhjb250ZW50LmZpZWxkcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGtleSA9IF9iWzBdLCB2YWwgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdW53cmFwKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YWx1ZS5kYXRhID0gcmVzdWx0O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgVmFsdWUuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUuY29udGVudClcclxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudC50eXBlO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpXHJcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XHJcbiAgICBpZiAodmFsdWUuZGF0YSA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gJ251bGwnO1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5kYXRhO1xyXG59XHJcbi8vIFVwZGF0ZXMgdGhlIGByaWdodGAgdmFsdWUgc3VjaCB0aGF0IGl0IHJldXNlcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGBsZWZ0YCB2YWx1ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlYmFzZVZhbHVlKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICB2YXIgbGVmdFR5cGUgPSBnZXRUeXBlKGxlZnQpO1xyXG4gICAgdmFyIHJpZ2h0VHlwZSA9IGdldFR5cGUocmlnaHQpO1xyXG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpXHJcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgdmFyIGxlZnRNb2RlbCA9IG5ldyBNb2RlbChsZWZ0LmVuZE1ldGEpO1xyXG4gICAgdmFyIHJpZ2h0TW9kZWwgPSBuZXcgTW9kZWwocmlnaHQuZW5kTWV0YSk7XHJcbiAgICBzd2l0Y2ggKGxlZnRUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xyXG4gICAgICAgICAgICB2YXIgbGVmdE9iaiA9IGxlZnRNb2RlbC5hc09iamVjdChsZWZ0KTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0T2JqID0gcmlnaHRNb2RlbC5hc09iamVjdChyaWdodCk7XHJcbiAgICAgICAgICAgIC8vIE51bWJlciBvZiBmaWVsZHMgd2hpY2ggYXJlIGlkZW50aWNhbCBpbiBsZWZ0IGFuZCByaWdodC5cclxuICAgICAgICAgICAgdmFyIGlkZW50aWNhbEZpZWxkQ291bnQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgbGVmdEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhsZWZ0T2JqLmZpZWxkcykubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMocmlnaHRPYmouZmllbGRzKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhyaWdodE9iai5maWVsZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgcmlnaHRWYWwgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0VmFsID0gbGVmdE9iai5maWVsZHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRPYmouZmllbGRzW2tleV0gPSByZWJhc2VWYWx1ZShsZWZ0VmFsLCByaWdodFZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0T2JqLmZpZWxkc1trZXldID09PSBsZWZ0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWNhbEZpZWxkQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzSWRlbnRpY2FsID0gbGVmdEZpZWxkQ291bnQgPT09IHJpZ2h0RmllbGRDb3VudCAmJiBsZWZ0RmllbGRDb3VudCA9PT0gaWRlbnRpY2FsRmllbGRDb3VudDtcclxuICAgICAgICAgICAgcmV0dXJuIGlzSWRlbnRpY2FsID8gbGVmdCA6IHJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdhcnJheSc6IHtcclxuICAgICAgICAgICAgdmFyIGxlZnRBcnIgPSBsZWZ0TW9kZWwuYXNBcnJheShsZWZ0KTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0QXJyID0gcmlnaHRNb2RlbC5hc0FycmF5KHJpZ2h0KTtcclxuICAgICAgICAgICAgaWYgKGxlZnRBcnIuZWxlbWVudHMubGVuZ3RoICE9PSByaWdodEFyci5lbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBudW1SZWJhc2VkID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaWdodEFyci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRBcnIuZWxlbWVudHNbaV0gPSByZWJhc2VWYWx1ZShsZWZ0QXJyLmVsZW1lbnRzW2ldLCByaWdodEFyci5lbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRBcnIuZWxlbWVudHNbaV0gIT09IGxlZnRBcnIuZWxlbWVudHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBudW1SZWJhc2VkKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bVJlYmFzZWQgPT09IDAgPyBsZWZ0IDogcmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ251bGwnOlxyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgIGNhc2UgJ251bWJlcic6IHtcclxuICAgICAgICAgICAgaWYgKHVud3JhcChsZWZ0KSA9PT0gdW53cmFwKHJpZ2h0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xyXG4gICAgICAgICAgICB2YXIgbGVmdFJhdyA9IHVud3JhcChsZWZ0KTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0UmF3ID0gdW53cmFwKHJpZ2h0KTtcclxuICAgICAgICAgICAgaWYgKGxlZnRSYXcgPT09IHJpZ2h0UmF3KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByaWdodE1vZGVsLmNvcHlTdHJpbmcobnVsbCk7XHJcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjb21tb25QcmVmaXgobGVmdFJhdywgcmlnaHRSYXcpO1xyXG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29tbW9uU3VmZml4KGxlZnRSYXcsIHJpZ2h0UmF3LCBwcmVmaXgpO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRMZW4gPSB1dGY4c3RyaW5nU2l6ZShyaWdodFJhdyk7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0TGVuID0gdXRmOHN0cmluZ1NpemUobGVmdFJhdyk7XHJcbiAgICAgICAgICAgIGlmICgwIDwgcHJlZml4KSB7XHJcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgMCwgcHJlZml4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJlZml4IDwgcmlnaHRMZW4gLSBzdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0TW9kZWwuc3RyaW5nQXBwZW5kU2xpY2UocmVzdWx0LCByaWdodCwgcHJlZml4LCByaWdodExlbiAtIHN1ZmZpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnRMZW4gLSBzdWZmaXggPCBsZWZ0TGVuKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgbGVmdExlbiAtIHN1ZmZpeCwgbGVmdExlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmlnaHRNb2RlbC5maW5hbGl6ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICBpZiAodW53cmFwKHZhbHVlKSAhPT0gcmlnaHRSYXcpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29ycmVjdCBzdHJpbmcgcmViYXNlJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmlnaHQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2gobGVmdCwgcGF0Y2gsIHN0YXJ0TWV0YSkge1xyXG4gICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKHN0YXJ0TWV0YSk7XHJcbiAgICB2YXIgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKG1vZGVsLCBsZWZ0LCBwYXRjaCk7XHJcbiAgICByZXR1cm4gcGF0Y2hlci5wcm9jZXNzKCk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5jcmVtZW50YWwtcGF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/incremental-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* reexport safe */ _simple_patcher__WEBPACK_IMPORTED_MODULE_1__.applyPatch; },\n/* harmony export */   \"incremental\": function() { return /* reexport module object */ _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./incremental-patcher */ \"./node_modules/mendoza/lib/esm/incremental-patcher.js\");\n/* harmony import */ var _simple_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-patcher */ \"./node_modules/mendoza/lib/esm/simple-patcher.js\");\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUQ7QUFDZjtBQUNNO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vaW5kZXguanM/NGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBpbmNyZW1lbnRhbF8xIGZyb20gJy4vaW5jcmVtZW50YWwtcGF0Y2hlcic7XHJcbmV4cG9ydCB7IGluY3JlbWVudGFsXzEgYXMgaW5jcmVtZW50YWwgfTtcclxuZXhwb3J0IHsgYXBwbHlQYXRjaCB9IGZyb20gJy4vc2ltcGxlLXBhdGNoZXInO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/internal-patcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/internal-patcher.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Patcher\": function() { return /* binding */ Patcher; }\n/* harmony export */ });\nvar OPS = [\r\n    'Value',\r\n    'Copy',\r\n    'Blank',\r\n    'ReturnIntoArray',\r\n    'ReturnIntoObject',\r\n    'ReturnIntoObjectSameKey',\r\n    'PushField',\r\n    'PushElement',\r\n    'PushParent',\r\n    'Pop',\r\n    'PushFieldCopy',\r\n    'PushFieldBlank',\r\n    'PushElementCopy',\r\n    'PushElementBlank',\r\n    'ReturnIntoObjectPop',\r\n    'ReturnIntoObjectSameKeyPop',\r\n    'ReturnIntoArrayPop',\r\n    'ObjectSetFieldValue',\r\n    'ObjectCopyField',\r\n    'ObjectDeleteField',\r\n    'ArrayAppendValue',\r\n    'ArrayAppendSlice',\r\n    'StringAppendString',\r\n    'StringAppendSlice'\r\n];\r\nvar Patcher = /** @class */ (function () {\r\n    function Patcher(model, root, patch) {\r\n        this.i = 0;\r\n        this.inputStack = [];\r\n        this.outputStack = [];\r\n        this.model = model;\r\n        this.root = root;\r\n        this.patch = patch;\r\n    }\r\n    Patcher.prototype.read = function () {\r\n        return this.patch[this.i++];\r\n    };\r\n    Patcher.prototype.process = function () {\r\n        this.inputStack.push({ value: this.root });\r\n        this.outputStack.push({ value: this.root });\r\n        for (; this.i < this.patch.length;) {\r\n            var opcode = this.read();\r\n            var op = OPS[opcode];\r\n            if (!op)\r\n                throw new Error(\"Unknown opcode: \" + opcode);\r\n            var processor = \"process\" + op;\r\n            this[processor].apply(this);\r\n        }\r\n        var entry = this.outputStack.pop();\r\n        return this.finalizeOutput(entry);\r\n    };\r\n    Patcher.prototype.inputEntry = function () {\r\n        return this.inputStack[this.inputStack.length - 1];\r\n    };\r\n    Patcher.prototype.inputKey = function (entry, idx) {\r\n        if (!entry.keys) {\r\n            entry.keys = this.model.objectGetKeys(entry.value).sort();\r\n        }\r\n        return entry.keys[idx];\r\n    };\r\n    Patcher.prototype.outputEntry = function () {\r\n        return this.outputStack[this.outputStack.length - 1];\r\n    };\r\n    Patcher.prototype.outputArray = function () {\r\n        var entry = this.outputEntry();\r\n        if (!entry.writeValue) {\r\n            entry.writeValue = this.model.copyArray(entry.value);\r\n        }\r\n        return entry.writeValue;\r\n    };\r\n    Patcher.prototype.outputObject = function () {\r\n        var entry = this.outputEntry();\r\n        if (!entry.writeValue) {\r\n            entry.writeValue = this.model.copyObject(entry.value);\r\n        }\r\n        return entry.writeValue;\r\n    };\r\n    Patcher.prototype.outputString = function () {\r\n        var entry = this.outputEntry();\r\n        if (!entry.writeValue) {\r\n            entry.writeValue = this.model.copyString(entry.value);\r\n        }\r\n        return entry.writeValue;\r\n    };\r\n    Patcher.prototype.finalizeOutput = function (entry) {\r\n        if (entry.writeValue) {\r\n            return this.model.finalize(entry.writeValue);\r\n        }\r\n        else {\r\n            return entry.value;\r\n        }\r\n    };\r\n    // Processors:\r\n    Patcher.prototype.processValue = function () {\r\n        var value = this.model.wrap(this.read());\r\n        this.outputStack.push({ value: value });\r\n    };\r\n    Patcher.prototype.processCopy = function () {\r\n        var input = this.inputEntry();\r\n        this.outputStack.push({ value: input.value });\r\n    };\r\n    Patcher.prototype.processBlank = function () {\r\n        this.outputStack.push({ value: null });\r\n    };\r\n    Patcher.prototype.processReturnIntoArray = function () {\r\n        var entry = this.outputStack.pop();\r\n        var result = this.finalizeOutput(entry);\r\n        var arr = this.outputArray();\r\n        this.model.arrayAppendValue(arr, result);\r\n    };\r\n    Patcher.prototype.processReturnIntoObject = function () {\r\n        var key = this.read();\r\n        var entry = this.outputStack.pop();\r\n        var result = this.finalizeOutput(entry);\r\n        result = this.model.markChanged(result);\r\n        var obj = this.outputObject();\r\n        this.model.objectSetField(obj, key, result);\r\n    };\r\n    Patcher.prototype.processReturnIntoObjectSameKey = function () {\r\n        var input = this.inputEntry();\r\n        var entry = this.outputStack.pop();\r\n        var result = this.finalizeOutput(entry);\r\n        var obj = this.outputObject();\r\n        this.model.objectSetField(obj, input.key, result);\r\n    };\r\n    Patcher.prototype.processPushField = function () {\r\n        var idx = this.read();\r\n        var entry = this.inputEntry();\r\n        var key = this.inputKey(entry, idx);\r\n        var value = this.model.objectGetField(entry.value, key);\r\n        this.inputStack.push({ value: value, key: key });\r\n    };\r\n    Patcher.prototype.processPushElement = function () {\r\n        var idx = this.read();\r\n        var entry = this.inputEntry();\r\n        var value = this.model.arrayGetElement(entry.value, idx);\r\n        this.inputStack.push({ value: value });\r\n    };\r\n    Patcher.prototype.processPop = function () {\r\n        this.inputStack.pop();\r\n    };\r\n    Patcher.prototype.processPushFieldCopy = function () {\r\n        this.processPushField();\r\n        this.processCopy();\r\n    };\r\n    Patcher.prototype.processPushFieldBlank = function () {\r\n        this.processPushField();\r\n        this.processBlank();\r\n    };\r\n    Patcher.prototype.processPushElementCopy = function () {\r\n        this.processPushElement();\r\n        this.processCopy();\r\n    };\r\n    Patcher.prototype.processPushElementBlank = function () {\r\n        this.processPushElement();\r\n        this.processBlank();\r\n    };\r\n    Patcher.prototype.processReturnIntoObjectPop = function () {\r\n        this.processReturnIntoObject();\r\n        this.processPop();\r\n    };\r\n    Patcher.prototype.processReturnIntoObjectSameKeyPop = function () {\r\n        this.processReturnIntoObjectSameKey();\r\n        this.processPop();\r\n    };\r\n    Patcher.prototype.processReturnIntoArrayPop = function () {\r\n        this.processReturnIntoArray();\r\n        this.processPop();\r\n    };\r\n    Patcher.prototype.processObjectSetFieldValue = function () {\r\n        this.processValue();\r\n        this.processReturnIntoObject();\r\n    };\r\n    Patcher.prototype.processObjectCopyField = function () {\r\n        this.processPushField();\r\n        this.processCopy();\r\n        this.processReturnIntoObjectSameKey();\r\n        this.processPop();\r\n    };\r\n    Patcher.prototype.processObjectDeleteField = function () {\r\n        var idx = this.read();\r\n        var entry = this.inputEntry();\r\n        var key = this.inputKey(entry, idx);\r\n        var obj = this.outputObject();\r\n        this.model.objectDeleteField(obj, key);\r\n    };\r\n    Patcher.prototype.processArrayAppendValue = function () {\r\n        var value = this.model.wrap(this.read());\r\n        var arr = this.outputArray();\r\n        this.model.arrayAppendValue(arr, value);\r\n    };\r\n    Patcher.prototype.processArrayAppendSlice = function () {\r\n        var left = this.read();\r\n        var right = this.read();\r\n        var str = this.outputArray();\r\n        var val = this.inputEntry().value;\r\n        this.model.arrayAppendSlice(str, val, left, right);\r\n    };\r\n    Patcher.prototype.processStringAppendString = function () {\r\n        var value = this.model.wrap(this.read());\r\n        var str = this.outputString();\r\n        this.model.stringAppendValue(str, value);\r\n    };\r\n    Patcher.prototype.processStringAppendSlice = function () {\r\n        var left = this.read();\r\n        var right = this.read();\r\n        var str = this.outputString();\r\n        var val = this.inputEntry().value;\r\n        this.model.stringAppendSlice(str, val, left, right);\r\n    };\r\n    return Patcher;\r\n}());\r\n\r\n//# sourceMappingURL=internal-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQsZ0NBQWdDLGtCQUFrQjtBQUNsRCxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNrQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanM/YjYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgT1BTID0gW1xyXG4gICAgJ1ZhbHVlJyxcclxuICAgICdDb3B5JyxcclxuICAgICdCbGFuaycsXHJcbiAgICAnUmV0dXJuSW50b0FycmF5JyxcclxuICAgICdSZXR1cm5JbnRvT2JqZWN0JyxcclxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleScsXHJcbiAgICAnUHVzaEZpZWxkJyxcclxuICAgICdQdXNoRWxlbWVudCcsXHJcbiAgICAnUHVzaFBhcmVudCcsXHJcbiAgICAnUG9wJyxcclxuICAgICdQdXNoRmllbGRDb3B5JyxcclxuICAgICdQdXNoRmllbGRCbGFuaycsXHJcbiAgICAnUHVzaEVsZW1lbnRDb3B5JyxcclxuICAgICdQdXNoRWxlbWVudEJsYW5rJyxcclxuICAgICdSZXR1cm5JbnRvT2JqZWN0UG9wJyxcclxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCcsXHJcbiAgICAnUmV0dXJuSW50b0FycmF5UG9wJyxcclxuICAgICdPYmplY3RTZXRGaWVsZFZhbHVlJyxcclxuICAgICdPYmplY3RDb3B5RmllbGQnLFxyXG4gICAgJ09iamVjdERlbGV0ZUZpZWxkJyxcclxuICAgICdBcnJheUFwcGVuZFZhbHVlJyxcclxuICAgICdBcnJheUFwcGVuZFNsaWNlJyxcclxuICAgICdTdHJpbmdBcHBlbmRTdHJpbmcnLFxyXG4gICAgJ1N0cmluZ0FwcGVuZFNsaWNlJ1xyXG5dO1xyXG52YXIgUGF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhdGNoZXIobW9kZWwsIHJvb3QsIHBhdGNoKSB7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgICAgICB0aGlzLmlucHV0U3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLm91dHB1dFN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XHJcbiAgICAgICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xyXG4gICAgfVxyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRjaFt0aGlzLmkrK107XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IHRoaXMucm9vdCB9KTtcclxuICAgICAgICBmb3IgKDsgdGhpcy5pIDwgdGhpcy5wYXRjaC5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgIHZhciBvcGNvZGUgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICAgICAgdmFyIG9wID0gT1BTW29wY29kZV07XHJcbiAgICAgICAgICAgIGlmICghb3ApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wY29kZTogXCIgKyBvcGNvZGUpO1xyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc29yID0gXCJwcm9jZXNzXCIgKyBvcDtcclxuICAgICAgICAgICAgdGhpc1twcm9jZXNzb3JdLmFwcGx5KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5pbnB1dEVudHJ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0U3RhY2tbdGhpcy5pbnB1dFN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLmlucHV0S2V5ID0gZnVuY3Rpb24gKGVudHJ5LCBpZHgpIHtcclxuICAgICAgICBpZiAoIWVudHJ5LmtleXMpIHtcclxuICAgICAgICAgICAgZW50cnkua2V5cyA9IHRoaXMubW9kZWwub2JqZWN0R2V0S2V5cyhlbnRyeS52YWx1ZSkuc29ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW50cnkua2V5c1tpZHhdO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dEVudHJ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dFN0YWNrW3RoaXMub3V0cHV0U3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0QXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xyXG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5QXJyYXkoZW50cnkudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5vdXRwdXRPYmplY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xyXG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5T2JqZWN0KGVudHJ5LnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcclxuICAgICAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcclxuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weVN0cmluZyhlbnRyeS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLmZpbmFsaXplT3V0cHV0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKGVudHJ5LndyaXRlVmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZmluYWxpemUoZW50cnkud3JpdGVWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFByb2Nlc3NvcnM6XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcclxuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0NvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IGlucHV0LnZhbHVlIH0pO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NCbGFuayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogbnVsbCB9KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xyXG4gICAgICAgIHZhciBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgcmVzdWx0KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIga2V5ID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XHJcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5tYXJrQ2hhbmdlZChyZXN1bHQpO1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBrZXksIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBpbnB1dC5rZXksIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5vYmplY3RHZXRGaWVsZChlbnRyeS52YWx1ZSwga2V5KTtcclxuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwga2V5OiBrZXkgfSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLmFycmF5R2V0RWxlbWVudChlbnRyeS52YWx1ZSwgaWR4KTtcclxuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wb3AoKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkQ29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZEJsYW5rID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50Q29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEVsZW1lbnRCbGFuayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1JldHVybkludG9PYmplY3RQb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXlQb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b0FycmF5KCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc09iamVjdFNldEZpZWxkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzVmFsdWUoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc09iamVjdENvcHlGaWVsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xyXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0RGVsZXRlRmllbGQob2JqLCBrZXkpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NBcnJheUFwcGVuZFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XHJcbiAgICAgICAgdmFyIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcclxuICAgICAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kVmFsdWUoYXJyLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0FycmF5QXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmlucHV0RW50cnkoKS52YWx1ZTtcclxuICAgICAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRWYWx1ZShzdHIsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRTbGljZShzdHIsIHZhbCwgbGVmdCwgcmlnaHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQYXRjaGVyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBQYXRjaGVyIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLXBhdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/internal-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/simple-patcher.js":
/*!********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/simple-patcher.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\r\n\r\nvar Model = {\r\n    wrap: function (data) {\r\n        return data;\r\n    },\r\n    finalize: function (b) {\r\n        if (Array.isArray(b)) {\r\n            return b;\r\n        }\r\n        else {\r\n            return b.data;\r\n        }\r\n    },\r\n    markChanged: function (value) {\r\n        return value;\r\n    },\r\n    objectGetKeys: function (value) {\r\n        return Object.keys(value);\r\n    },\r\n    objectGetField: function (value, key) {\r\n        return value[key];\r\n    },\r\n    arrayGetElement: function (value, idx) {\r\n        return value[idx];\r\n    },\r\n    copyObject: function (value) {\r\n        var res = {\r\n            type: 'object',\r\n            data: {}\r\n        };\r\n        if (value !== null) {\r\n            for (var _i = 0, _a = Object.entries(value); _i < _a.length; _i++) {\r\n                var _b = _a[_i], key = _b[0], val = _b[1];\r\n                res.data[key] = val;\r\n            }\r\n        }\r\n        return res;\r\n    },\r\n    copyArray: function (value) {\r\n        if (value === null)\r\n            return [];\r\n        return value.slice();\r\n    },\r\n    copyString: function (value) {\r\n        return {\r\n            type: 'string',\r\n            data: value === null ? '' : value\r\n        };\r\n    },\r\n    objectSetField: function (target, key, value) {\r\n        target.data[key] = value;\r\n    },\r\n    objectDeleteField: function (target, key) {\r\n        delete target.data[key];\r\n    },\r\n    arrayAppendValue: function (target, value) {\r\n        target.push(value);\r\n    },\r\n    arrayAppendSlice: function (target, source, left, right) {\r\n        target.push.apply(target, source.slice(left, right));\r\n    },\r\n    stringAppendSlice: function (target, source, left, right) {\r\n        var sourceString = source;\r\n        var leftPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, left);\r\n        var rightPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, right, leftPos);\r\n        target.data += sourceString.slice(leftPos, rightPos);\r\n    },\r\n    stringAppendValue: function (target, value) {\r\n        target.data += value;\r\n    }\r\n};\r\n// Applies a patch on a JavaScript object.\r\nfunction applyPatch(left, patch) {\r\n    var root = left; // No need to wrap because the representation is the same.\r\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(Model, root, patch);\r\n    return patcher.process();\r\n}\r\n//# sourceMappingURL=simple-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QztBQUNIO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQix1REFBZ0I7QUFDdEMsdUJBQXVCLHVEQUFnQjtBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQkFBcUI7QUFDckIsc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzPzY5YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGF0Y2hlciB9IGZyb20gJy4vaW50ZXJuYWwtcGF0Y2hlcic7XHJcbmltcG9ydCB7IHV0ZjhyZXNvbHZlSW5kZXggfSBmcm9tICcuL3V0ZjgnO1xyXG52YXIgTW9kZWwgPSB7XHJcbiAgICB3cmFwOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIuZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWFya0NoYW5nZWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBvYmplY3RHZXRLZXlzOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xyXG4gICAgfSxcclxuICAgIG9iamVjdEdldEZpZWxkOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xyXG4gICAgfSxcclxuICAgIGFycmF5R2V0RWxlbWVudDogZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVbaWR4XTtcclxuICAgIH0sXHJcbiAgICBjb3B5T2JqZWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgcmVzID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcclxuICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModmFsdWUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XHJcbiAgICAgICAgICAgICAgICByZXMuZGF0YVtrZXldID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LFxyXG4gICAgY29weUFycmF5OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcclxuICAgIH0sXHJcbiAgICBjb3B5U3RyaW5nOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcclxuICAgICAgICAgICAgZGF0YTogdmFsdWUgPT09IG51bGwgPyAnJyA6IHZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBvYmplY3RTZXRGaWVsZDogZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRhcmdldC5kYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBvYmplY3REZWxldGVGaWVsZDogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRhcmdldC5kYXRhW2tleV07XHJcbiAgICB9LFxyXG4gICAgYXJyYXlBcHBlbmRWYWx1ZTogZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcclxuICAgICAgICB0YXJnZXQucHVzaCh2YWx1ZSk7XHJcbiAgICB9LFxyXG4gICAgYXJyYXlBcHBlbmRTbGljZTogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHRhcmdldC5wdXNoLmFwcGx5KHRhcmdldCwgc291cmNlLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XHJcbiAgICB9LFxyXG4gICAgc3RyaW5nQXBwZW5kU2xpY2U6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB2YXIgc291cmNlU3RyaW5nID0gc291cmNlO1xyXG4gICAgICAgIHZhciBsZWZ0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIGxlZnQpO1xyXG4gICAgICAgIHZhciByaWdodFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCByaWdodCwgbGVmdFBvcyk7XHJcbiAgICAgICAgdGFyZ2V0LmRhdGEgKz0gc291cmNlU3RyaW5nLnNsaWNlKGxlZnRQb3MsIHJpZ2h0UG9zKTtcclxuICAgIH0sXHJcbiAgICBzdHJpbmdBcHBlbmRWYWx1ZTogZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcclxuICAgICAgICB0YXJnZXQuZGF0YSArPSB2YWx1ZTtcclxuICAgIH1cclxufTtcclxuLy8gQXBwbGllcyBhIHBhdGNoIG9uIGEgSmF2YVNjcmlwdCBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGxlZnQsIHBhdGNoKSB7XHJcbiAgICB2YXIgcm9vdCA9IGxlZnQ7IC8vIE5vIG5lZWQgdG8gd3JhcCBiZWNhdXNlIHRoZSByZXByZXNlbnRhdGlvbiBpcyB0aGUgc2FtZS5cclxuICAgIHZhciBwYXRjaGVyID0gbmV3IFBhdGNoZXIoTW9kZWwsIHJvb3QsIHBhdGNoKTtcclxuICAgIHJldHVybiBwYXRjaGVyLnByb2Nlc3MoKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGUtcGF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/simple-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/utf8.js":
/*!**********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/utf8.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"commonPrefix\": function() { return /* binding */ commonPrefix; },\n/* harmony export */   \"commonSuffix\": function() { return /* binding */ commonSuffix; },\n/* harmony export */   \"utf8charSize\": function() { return /* binding */ utf8charSize; },\n/* harmony export */   \"utf8resolveIndex\": function() { return /* binding */ utf8resolveIndex; },\n/* harmony export */   \"utf8stringSize\": function() { return /* binding */ utf8stringSize; }\n/* harmony export */ });\nfunction utf8charSize(code) {\r\n    if (code >> 16) {\r\n        return 4;\r\n    }\r\n    else if (code >> 11) {\r\n        return 3;\r\n    }\r\n    else if (code >> 7) {\r\n        return 2;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n}\r\nfunction utf8stringSize(str) {\r\n    var b = 0;\r\n    for (var i = 0; i < str.length; i++) {\r\n        var code = str.codePointAt(i);\r\n        var size = utf8charSize(code);\r\n        if (size == 4)\r\n            i++;\r\n        b += size;\r\n    }\r\n    return b;\r\n}\r\n/** Converts an UTF-8 byte index into a UCS-2 index. */\r\nfunction utf8resolveIndex(str, idx, start) {\r\n    if (start === void 0) { start = 0; }\r\n    var byteCount = start;\r\n    var ucsIdx = 0;\r\n    for (ucsIdx = start; byteCount < idx; ucsIdx++) {\r\n        var code = str.codePointAt(ucsIdx);\r\n        var size = utf8charSize(code);\r\n        if (size === 4)\r\n            ucsIdx++; // Surrogate pair.\r\n        byteCount += size;\r\n    }\r\n    return ucsIdx;\r\n}\r\nfunction commonPrefix(str, str2) {\r\n    var len = Math.min(str.length, str2.length);\r\n    var b = 0;\r\n    for (var i = 0; i < len;) {\r\n        var aPoint = str.codePointAt(i);\r\n        var bPoint = str2.codePointAt(i);\r\n        if (aPoint !== bPoint)\r\n            return b;\r\n        var size = utf8charSize(aPoint);\r\n        b += size;\r\n        i += size === 4 ? 2 : 1;\r\n    }\r\n    return b;\r\n}\r\nfunction commonSuffix(str, str2, prefix) {\r\n    if (prefix === void 0) { prefix = 0; }\r\n    var len = Math.min(str.length, str2.length) - prefix;\r\n    var b = 0;\r\n    for (var i = 0; i < len;) {\r\n        var aPoint = str.codePointAt(str.length - 1 - i);\r\n        var bPoint = str2.codePointAt(str2.length - 1 - i);\r\n        if (aPoint !== bPoint)\r\n            return b;\r\n        var size = utf8charSize(aPoint);\r\n        b += size;\r\n        i += size === 4 ? 2 : 1;\r\n    }\r\n    return b;\r\n}\r\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanM/ZWM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdXRmOGNoYXJTaXplKGNvZGUpIHtcclxuICAgIGlmIChjb2RlID4+IDE2KSB7XHJcbiAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID4+IDExKSB7XHJcbiAgICAgICAgcmV0dXJuIDM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID4+IDcpIHtcclxuICAgICAgICByZXR1cm4gMjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1dGY4c3RyaW5nU2l6ZShzdHIpIHtcclxuICAgIHZhciBiID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XHJcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XHJcbiAgICAgICAgaWYgKHNpemUgPT0gNClcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIGIgKz0gc2l6ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBiO1xyXG59XHJcbi8qKiBDb252ZXJ0cyBhbiBVVEYtOCBieXRlIGluZGV4IGludG8gYSBVQ1MtMiBpbmRleC4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhyZXNvbHZlSW5kZXgoc3RyLCBpZHgsIHN0YXJ0KSB7XHJcbiAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cclxuICAgIHZhciBieXRlQ291bnQgPSBzdGFydDtcclxuICAgIHZhciB1Y3NJZHggPSAwO1xyXG4gICAgZm9yICh1Y3NJZHggPSBzdGFydDsgYnl0ZUNvdW50IDwgaWR4OyB1Y3NJZHgrKykge1xyXG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNvZGVQb2ludEF0KHVjc0lkeCk7XHJcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XHJcbiAgICAgICAgaWYgKHNpemUgPT09IDQpXHJcbiAgICAgICAgICAgIHVjc0lkeCsrOyAvLyBTdXJyb2dhdGUgcGFpci5cclxuICAgICAgICBieXRlQ291bnQgKz0gc2l6ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB1Y3NJZHg7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblByZWZpeChzdHIsIHN0cjIpIHtcclxuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCk7XHJcbiAgICB2YXIgYiA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcclxuICAgICAgICB2YXIgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xyXG4gICAgICAgIHZhciBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KGkpO1xyXG4gICAgICAgIGlmIChhUG9pbnQgIT09IGJQb2ludClcclxuICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcclxuICAgICAgICBiICs9IHNpemU7XHJcbiAgICAgICAgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uU3VmZml4KHN0ciwgc3RyMiwgcHJlZml4KSB7XHJcbiAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHsgcHJlZml4ID0gMDsgfVxyXG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKSAtIHByZWZpeDtcclxuICAgIHZhciBiID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xyXG4gICAgICAgIHZhciBhUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoc3RyLmxlbmd0aCAtIDEgLSBpKTtcclxuICAgICAgICB2YXIgYlBvaW50ID0gc3RyMi5jb2RlUG9pbnRBdChzdHIyLmxlbmd0aCAtIDEgLSBpKTtcclxuICAgICAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGFQb2ludCk7XHJcbiAgICAgICAgYiArPSBzaXplO1xyXG4gICAgICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGI7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/utf8.js\n"));

/***/ }),

/***/ "./node_modules/groq-js/dist/1.umd.cjs":
/*!*********************************************!*\
  !*** ./node_modules/groq-js/dist/1.umd.cjs ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function(g,f){ true?f(exports):0;})(this,(function(exports){'use strict';/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}var MarkProcessor = /** @class */ (function () {\n    function MarkProcessor(string, marks, parseOptions) {\n        this.allowBoost = false;\n        this.string = string;\n        this.marks = marks;\n        this.index = 0;\n        this.parseOptions = parseOptions;\n    }\n    MarkProcessor.prototype.hasMark = function (pos) {\n        if (pos === void 0) { pos = 0; }\n        return this.index + pos < this.marks.length;\n    };\n    MarkProcessor.prototype.getMark = function (pos) {\n        if (pos === void 0) { pos = 0; }\n        return this.marks[this.index + pos];\n    };\n    MarkProcessor.prototype.shift = function () {\n        this.index += 1;\n    };\n    MarkProcessor.prototype.process = function (visitor) {\n        var mark = this.marks[this.index];\n        this.shift();\n        var func = visitor[mark.name];\n        if (!func) {\n            throw new Error(\"Unknown handler: \".concat(mark.name));\n        }\n        return func.call(visitor, this, mark);\n    };\n    MarkProcessor.prototype.processString = function () {\n        this.shift();\n        return this.processStringEnd();\n    };\n    MarkProcessor.prototype.processStringEnd = function () {\n        var prev = this.marks[this.index - 1];\n        var curr = this.marks[this.index];\n        this.shift();\n        return this.string.slice(prev.position, curr.position);\n    };\n    MarkProcessor.prototype.slice = function (len) {\n        var pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    };\n    return MarkProcessor;\n}());var RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    if (RFC3339_REGEX.test(str)) {\n        return new Date(str);\n    }\n    return null;\n}\nfunction formatRFC3339(d) {\n    var year = addLeadingZero(d.getUTCFullYear(), 4);\n    var month = addLeadingZero(d.getUTCMonth() + 1, 2);\n    var day = addLeadingZero(d.getUTCDate(), 2);\n    var hour = addLeadingZero(d.getUTCHours(), 2);\n    var minute = addLeadingZero(d.getUTCMinutes(), 2);\n    var second = addLeadingZero(d.getUTCSeconds(), 2);\n    var fractionalSecond = '';\n    var millis = d.getMilliseconds();\n    if (millis != 0) {\n        fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n    }\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n    var str = num.toString();\n    while (str.length < targetLength) {\n        str = \"0\".concat(str);\n    }\n    return str;\n}function escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction pathRegExp(pattern) {\n    var re = [];\n    for (var _i = 0, _a = pattern.split('.'); _i < _a.length; _i++) {\n        var part = _a[_i];\n        if (part === '*') {\n            re.push('[^.]+');\n        }\n        else if (part === '**') {\n            re.push('.*');\n        }\n        else {\n            re.push(escapeRegExp(part));\n        }\n    }\n    return new RegExp(\"^\".concat(re.join('.'), \"$\"));\n}\nvar Path = /** @class */ (function () {\n    function Path(pattern) {\n        this.pattern = pattern;\n        this.patternRe = pathRegExp(pattern);\n    }\n    Path.prototype.matches = function (str) {\n        return this.patternRe.test(str);\n    };\n    Path.prototype.toJSON = function () {\n        return this.pattern;\n    };\n    return Path;\n}());var StreamValue = /** @class */ (function () {\n    function StreamValue(generator) {\n        this.type = 'stream';\n        this.generator = generator;\n        this.ticker = null;\n        this.isDone = false;\n        this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    StreamValue.prototype.isArray = function () {\n        return true;\n    };\n    StreamValue.prototype.get = function () {\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _b, _c, value, _d, _e, e_1_1;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        result = [];\n                        _f.label = 1;\n                    case 1:\n                        _f.trys.push([1, 7, 8, 13]);\n                        _b = __asyncValues(this);\n                        _f.label = 2;\n                    case 2: return [4 /*yield*/, _b.next()];\n                    case 3:\n                        if (!(_c = _f.sent(), !_c.done)) return [3 /*break*/, 6];\n                        value = _c.value;\n                        _e = (_d = result).push;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _e.apply(_d, [_f.sent()]);\n                        _f.label = 5;\n                    case 5: return [3 /*break*/, 2];\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        e_1_1 = _f.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 13];\n                    case 8:\n                        _f.trys.push([8, , 11, 12]);\n                        if (!(_c && !_c.done && (_a = _b[\"return\"]))) return [3 /*break*/, 10];\n                        return [4 /*yield*/, _a.call(_b)];\n                    case 9:\n                        _f.sent();\n                        _f.label = 10;\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 12: return [7 /*endfinally*/];\n                    case 13: return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    StreamValue.prototype[Symbol.asyncIterator] = function () {\n        return __asyncGenerator(this, arguments, function _a() {\n            var i;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        _b.label = 2;\n                    case 2:\n                        if (!(i < this.data.length)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, __await(this.data[i])];\n                    case 3: return [4 /*yield*/, _b.sent()];\n                    case 4:\n                        _b.sent();\n                        _b.label = 5;\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 2];\n                    case 6:\n                        if (!this.isDone) return [3 /*break*/, 8];\n                        return [4 /*yield*/, __await(void 0)];\n                    case 7: return [2 /*return*/, _b.sent()];\n                    case 8: return [4 /*yield*/, __await(this._nextTick())];\n                    case 9:\n                        _b.sent();\n                        return [3 /*break*/, 1];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    StreamValue.prototype._nextTick = function () {\n        var _this = this;\n        if (this.ticker) {\n            return this.ticker;\n        }\n        var currentResolver;\n        var setupTicker = function () {\n            _this.ticker = new Promise(function (resolve) {\n                currentResolver = resolve;\n            });\n        };\n        var tick = function () {\n            currentResolver();\n            setupTicker();\n        };\n        var fetch = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a, _b, value, e_2_1;\n            var e_2, _c;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _d.trys.push([0, 5, 6, 11]);\n                        _a = __asyncValues(this.generator());\n                        _d.label = 1;\n                    case 1: return [4 /*yield*/, _a.next()];\n                    case 2:\n                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 4];\n                        value = _b.value;\n                        this.data.push(value);\n                        tick();\n                        _d.label = 3;\n                    case 3: return [3 /*break*/, 1];\n                    case 4: return [3 /*break*/, 11];\n                    case 5:\n                        e_2_1 = _d.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 11];\n                    case 6:\n                        _d.trys.push([6, , 9, 10]);\n                        if (!(_b && !_b.done && (_c = _a[\"return\"]))) return [3 /*break*/, 8];\n                        return [4 /*yield*/, _c.call(_a)];\n                    case 7:\n                        _d.sent();\n                        _d.label = 8;\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        if (e_2) throw e_2.error;\n                        return [7 /*endfinally*/];\n                    case 10: return [7 /*endfinally*/];\n                    case 11:\n                        this.isDone = true;\n                        tick();\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        setupTicker();\n        fetch();\n        return this.ticker;\n    };\n    return StreamValue;\n}());var StaticValue = /** @class */ (function () {\n    function StaticValue(data, type) {\n        this.data = data;\n        this.type = type;\n    }\n    StaticValue.prototype.isArray = function () {\n        return this.type === 'array';\n    };\n    // eslint-disable-next-line require-await\n    StaticValue.prototype.get = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.data];\n            });\n        });\n    };\n    StaticValue.prototype[Symbol.asyncIterator] = function () {\n        if (Array.isArray(this.data)) {\n            return (function (data) {\n                var _i, data_1, element;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            _i = 0, data_1 = data;\n                            _a.label = 1;\n                        case 1:\n                            if (!(_i < data_1.length)) return [3 /*break*/, 4];\n                            element = data_1[_i];\n                            return [4 /*yield*/, fromJS(element)];\n                        case 2:\n                            _a.sent();\n                            _a.label = 3;\n                        case 3:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 4: return [2 /*return*/];\n                    }\n                });\n            })(this.data);\n        }\n        throw new Error(\"Cannot iterate over: \".concat(this.type));\n    };\n    return StaticValue;\n}());\nvar NULL_VALUE = new StaticValue(null, 'null');\nvar TRUE_VALUE = new StaticValue(true, 'boolean');\nvar FALSE_VALUE = new StaticValue(false, 'boolean');\nvar DateTime = /** @class */ (function () {\n    function DateTime(date) {\n        this.date = date;\n    }\n    DateTime.parseToValue = function (str) {\n        var date = parseRFC3339(str);\n        if (date) {\n            return new StaticValue(new DateTime(date), 'datetime');\n        }\n        return NULL_VALUE;\n    };\n    DateTime.prototype.equals = function (other) {\n        return this.date.getTime() == other.date.getTime();\n    };\n    DateTime.prototype.add = function (secs) {\n        var copy = new Date(this.date.getTime());\n        copy.setTime(copy.getTime() + secs * 1000);\n        return new DateTime(copy);\n    };\n    DateTime.prototype.difference = function (other) {\n        return (this.date.getTime() - other.date.getTime()) / 1000;\n    };\n    DateTime.prototype.compareTo = function (other) {\n        return this.date.getTime() - other.date.getTime();\n    };\n    DateTime.prototype.toString = function () {\n        return formatRFC3339(this.date);\n    };\n    DateTime.prototype.toJSON = function () {\n        return this.toString();\n    };\n    return DateTime;\n}());\nfunction fromNumber(num) {\n    if (Number.isFinite(num)) {\n        return new StaticValue(num, 'number');\n    }\n    return NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, 'string');\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, 'datetime');\n}\nfunction fromPath(path) {\n    return new StaticValue(path, 'path');\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next === 'function';\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction fromJS(val) {\n    if (isIterator(val)) {\n        return new StreamValue(function () {\n            return __asyncGenerator(this, arguments, function () {\n                var val_1, val_1_1, value, e_1_1;\n                var e_1, _a;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _b.trys.push([0, 7, 8, 13]);\n                            val_1 = __asyncValues(val);\n                            _b.label = 1;\n                        case 1: return [4 /*yield*/, __await(val_1.next())];\n                        case 2:\n                            if (!(val_1_1 = _b.sent(), !val_1_1.done)) return [3 /*break*/, 6];\n                            value = val_1_1.value;\n                            return [4 /*yield*/, __await(fromJS(value))];\n                        case 3: return [4 /*yield*/, _b.sent()];\n                        case 4:\n                            _b.sent();\n                            _b.label = 5;\n                        case 5: return [3 /*break*/, 1];\n                        case 6: return [3 /*break*/, 13];\n                        case 7:\n                            e_1_1 = _b.sent();\n                            e_1 = { error: e_1_1 };\n                            return [3 /*break*/, 13];\n                        case 8:\n                            _b.trys.push([8, , 11, 12]);\n                            if (!(val_1_1 && !val_1_1.done && (_a = val_1[\"return\"]))) return [3 /*break*/, 10];\n                            return [4 /*yield*/, __await(_a.call(val_1))];\n                        case 9:\n                            _b.sent();\n                            _b.label = 10;\n                        case 10: return [3 /*break*/, 12];\n                        case 11:\n                            if (e_1) throw e_1.error;\n                            return [7 /*endfinally*/];\n                        case 12: return [7 /*endfinally*/];\n                        case 13: return [2 /*return*/];\n                    }\n                });\n            });\n        });\n    }\n    else if (val === null || val === undefined) {\n        return NULL_VALUE;\n    }\n    return new StaticValue(val, getType(val));\n}\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction getType(data) {\n    if (data === null || typeof data === 'undefined') {\n        return 'null';\n    }\n    if (Array.isArray(data)) {\n        return 'array';\n    }\n    if (data instanceof Path) {\n        return 'path';\n    }\n    if (data instanceof DateTime) {\n        return 'datetime';\n    }\n    return typeof data;\n}var TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction partialCompare(a, b) {\n    var aType = getType(a);\n    var bType = getType(b);\n    if (aType !== bType) {\n        return null;\n    }\n    switch (aType) {\n        case 'number':\n        case 'boolean':\n            return a - b;\n        case 'string':\n            if (a < b)\n                return -1;\n            if (a > b)\n                return 1;\n            return 0;\n        case 'datetime':\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction totalCompare(a, b) {\n    var aType = getType(a);\n    var bType = getType(b);\n    var aTypeOrder = TYPE_ORDER[aType] || 100;\n    var bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) {\n        return aTypeOrder - bTypeOrder;\n    }\n    var result = partialCompare(a, b);\n    if (result === null) {\n        result = 0;\n    }\n    return result;\n}var CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nvar CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nvar EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nvar MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n    if (tokens.length === 0 || patterns.length === 0) {\n        return false;\n    }\n    return patterns.every(function (pattern) { return pattern(tokens); });\n}\nfunction matchTokenize(text) {\n    return text.replace(EDGE_CHARS, '').match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n    var termsRe = matchPatternRegex(text);\n    return termsRe.map(function (re) { return function (tokens) { return tokens.some(function (token) { return re.test(token); }); }; });\n}\nfunction matchPatternRegex(text) {\n    var terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || [];\n    return terms.map(function (term) { return new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*'), \"$\"), 'i'); });\n}\nfunction gatherText(value, cb) {\n    var value_1, value_1_1;\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var success, part, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (value.type === 'string') {\n                        cb(value.data);\n                        return [2 /*return*/, true];\n                    }\n                    if (!value.isArray()) return [3 /*break*/, 13];\n                    success = true;\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 6, 7, 12]);\n                    value_1 = __asyncValues(value);\n                    _b.label = 2;\n                case 2: return [4 /*yield*/, value_1.next()];\n                case 3:\n                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 5];\n                    part = value_1_1.value;\n                    if (part.type === 'string') {\n                        cb(part.data);\n                    }\n                    else {\n                        success = false;\n                    }\n                    _b.label = 4;\n                case 4: return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 12];\n                case 6:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 12];\n                case 7:\n                    _b.trys.push([7, , 10, 11]);\n                    if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 9];\n                    return [4 /*yield*/, _a.call(value_1)];\n                case 8:\n                    _b.sent();\n                    _b.label = 9;\n                case 9: return [3 /*break*/, 11];\n                case 10:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 11: return [7 /*endfinally*/];\n                case 12: return [2 /*return*/, success];\n                case 13: return [2 /*return*/, false];\n            }\n        });\n    });\n}// BM25 similarity constants\nvar BM25k = 1.2;\nfunction evaluateScore(node, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var innerScore, boost, _a, leftScore, rightScore, leftScore, rightScore, res;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (node.type === 'OpCall' && node.op === 'match') {\n                        return [2 /*return*/, evaluateMatchScore(node.left, node.right, scope, execute)];\n                    }\n                    if (!(node.type === 'FuncCall' && node.name === 'boost')) return [3 /*break*/, 3];\n                    return [4 /*yield*/, evaluateScore(node.args[0], scope, execute)];\n                case 1:\n                    innerScore = _b.sent();\n                    return [4 /*yield*/, execute(node.args[1], scope)];\n                case 2:\n                    boost = _b.sent();\n                    if (boost.type === 'number' && innerScore > 0) {\n                        return [2 /*return*/, innerScore + boost.data];\n                    }\n                    return [2 /*return*/, 0];\n                case 3:\n                    _a = node.type;\n                    switch (_a) {\n                        case 'Or': return [3 /*break*/, 4];\n                        case 'And': return [3 /*break*/, 7];\n                    }\n                    return [3 /*break*/, 10];\n                case 4: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];\n                case 5:\n                    leftScore = _b.sent();\n                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];\n                case 6:\n                    rightScore = _b.sent();\n                    return [2 /*return*/, leftScore + rightScore];\n                case 7: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];\n                case 8:\n                    leftScore = _b.sent();\n                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];\n                case 9:\n                    rightScore = _b.sent();\n                    if (leftScore === 0 || rightScore === 0)\n                        return [2 /*return*/, 0];\n                    return [2 /*return*/, leftScore + rightScore];\n                case 10: return [4 /*yield*/, execute(node, scope)];\n                case 11:\n                    res = _b.sent();\n                    return [2 /*return*/, res.type === 'boolean' && res.data === true ? 1 : 0];\n            }\n        });\n    });\n}\nfunction evaluateMatchScore(left, right, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var text, pattern, tokens, terms, didSucceed, score, _loop_1, _i, terms_1, re;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(left, scope)];\n                case 1:\n                    text = _a.sent();\n                    return [4 /*yield*/, execute(right, scope)];\n                case 2:\n                    pattern = _a.sent();\n                    tokens = [];\n                    terms = [];\n                    return [4 /*yield*/, gatherText(text, function (part) {\n                            tokens = tokens.concat(matchTokenize(part));\n                        })];\n                case 3:\n                    _a.sent();\n                    return [4 /*yield*/, gatherText(pattern, function (part) {\n                            terms = terms.concat(matchPatternRegex(part));\n                        })];\n                case 4:\n                    didSucceed = _a.sent();\n                    if (!didSucceed) {\n                        return [2 /*return*/, 0];\n                    }\n                    if (tokens.length === 0 || terms.length === 0) {\n                        return [2 /*return*/, 0];\n                    }\n                    score = 0;\n                    _loop_1 = function (re) {\n                        var freq = tokens.reduce(function (c, token) { return c + (re.test(token) ? 1 : 0); }, 0);\n                        score += (freq * (BM25k + 1)) / (freq + BM25k);\n                    };\n                    for (_i = 0, terms_1 = terms; _i < terms_1.length; _i++) {\n                        re = terms_1[_i];\n                        _loop_1(re);\n                    }\n                    return [2 /*return*/, score];\n            }\n        });\n    });\n}function portableTextContent(value) {\n    return __awaiter(this, void 0, void 0, function () {\n        var texts;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(value.type === 'object')) return [3 /*break*/, 1];\n                    return [2 /*return*/, blockText(value.data)];\n                case 1:\n                    if (!value.isArray()) return [3 /*break*/, 3];\n                    return [4 /*yield*/, arrayText(value)];\n                case 2:\n                    texts = _a.sent();\n                    if (texts.length > 0) {\n                        return [2 /*return*/, texts.join('\\n\\n')];\n                    }\n                    _a.label = 3;\n                case 3: return [2 /*return*/, null];\n            }\n        });\n    });\n}\nfunction arrayText(value, result) {\n    var value_1, value_1_1;\n    var e_1, _a;\n    if (result === void 0) { result = []; }\n    return __awaiter(this, void 0, void 0, function () {\n        var block, text, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 7, 8, 13]);\n                    value_1 = __asyncValues(value);\n                    _b.label = 1;\n                case 1: return [4 /*yield*/, value_1.next()];\n                case 2:\n                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 6];\n                    block = value_1_1.value;\n                    if (!(block.type === 'object')) return [3 /*break*/, 3];\n                    text = blockText(block.data);\n                    if (text !== null)\n                        result.push(text);\n                    return [3 /*break*/, 5];\n                case 3:\n                    if (!block.isArray()) return [3 /*break*/, 5];\n                    return [4 /*yield*/, arrayText(block, result)];\n                case 4:\n                    _b.sent();\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 1];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(value_1)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, result];\n            }\n        });\n    });\n}\nfunction blockText(obj) {\n    if (typeof obj._type !== 'string')\n        return null;\n    var children = obj.children;\n    if (!Array.isArray(children))\n        return null;\n    var result = '';\n    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n        var child = children_1[_i];\n        if (child &&\n            typeof child === 'object' &&\n            typeof child._type === 'string' &&\n            child._type === 'span' &&\n            typeof child.text === 'string') {\n            result += child.text;\n        }\n    }\n    return result;\n}function hasReference(value, pathSet) {\n    switch (getType(value)) {\n        case 'array':\n            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n                var v = value_1[_i];\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n        case 'object':\n            if (value._ref) {\n                return pathSet.has(value._ref);\n            }\n            for (var _a = 0, _b = Object.values(value); _a < _b.length; _a++) {\n                var v = _b[_a];\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n    }\n    return false;\n}\nfunction countUTF8(str) {\n    var count = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        if (code >= 0xd800 && code <= 0xdbff) {\n            // High surrogate. Don't count this.\n            // By only counting the low surrogate we will correctly\n            // count the number of UTF-8 code points.\n            continue;\n        }\n        count++;\n    }\n    return count;\n}\nvar global = {};\nglobal.anywhere = function anywhere() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            throw new Error('not implemented');\n        });\n    });\n};\nglobal.anywhere.arity = 1;\nglobal.coalesce = function coalesce(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _i, args_1, arg, value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _i = 0, args_1 = args;\n                    _a.label = 1;\n                case 1:\n                    if (!(_i < args_1.length)) return [3 /*break*/, 4];\n                    arg = args_1[_i];\n                    return [4 /*yield*/, execute(arg, scope)];\n                case 2:\n                    value = _a.sent();\n                    if (value.type !== 'null') {\n                        return [2 /*return*/, value];\n                    }\n                    _a.label = 3;\n                case 3:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/, NULL_VALUE];\n            }\n        });\n    });\n};\nglobal.count = function count(args, scope, execute) {\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var inner, num, inner_1, inner_1_1, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _b.sent();\n                    if (!inner.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    num = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    inner_1 = __asyncValues(inner);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, inner_1.next()];\n                case 4:\n                    if (!(inner_1_1 = _b.sent(), !inner_1_1.done)) return [3 /*break*/, 6];\n                    inner_1_1.value;\n                    num++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(inner_1_1 && !inner_1_1.done && (_a = inner_1[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(inner_1)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromNumber(num)];\n            }\n        });\n    });\n};\nglobal.count.arity = 1;\nglobal.dateTime = function dateTime(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var val;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    val = _a.sent();\n                    if (val.type === 'datetime') {\n                        return [2 /*return*/, val];\n                    }\n                    if (val.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, DateTime.parseToValue(val.data)];\n            }\n        });\n    });\n};\nglobal.dateTime.arity = 1;\nglobal.defined = function defined(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var inner;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _a.sent();\n                    return [2 /*return*/, inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE];\n            }\n        });\n    });\n};\nglobal.defined.arity = 1;\n// eslint-disable-next-line require-await\nglobal.identity = function identity(args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, fromString(scope.context.identity)];\n        });\n    });\n};\nglobal.identity.arity = 0;\nglobal.length = function length(args, scope, execute) {\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var inner, num, inner_2, inner_2_1, e_2_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _b.sent();\n                    if (inner.type === 'string') {\n                        return [2 /*return*/, fromNumber(countUTF8(inner.data))];\n                    }\n                    if (!inner.isArray()) return [3 /*break*/, 14];\n                    num = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    inner_2 = __asyncValues(inner);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, inner_2.next()];\n                case 4:\n                    if (!(inner_2_1 = _b.sent(), !inner_2_1.done)) return [3 /*break*/, 6];\n                    inner_2_1.value;\n                    num++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_2_1 = _b.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(inner_2_1 && !inner_2_1.done && (_a = inner_2[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(inner_2)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_2) throw e_2.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromNumber(num)];\n                case 14: return [2 /*return*/, NULL_VALUE];\n            }\n        });\n    });\n};\nglobal.length.arity = 1;\nglobal.path = function path(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var inner;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _a.sent();\n                    if (inner.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromPath(new Path(inner.data))];\n            }\n        });\n    });\n};\nglobal.path.arity = 1;\nglobal.string = function string(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    switch (value.type) {\n                        case 'number':\n                        case 'string':\n                        case 'boolean':\n                        case 'datetime':\n                            return [2 /*return*/, fromString(\"\".concat(value.data))];\n                        default:\n                            return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n};\nglobal.string.arity = 1;\nglobal.references = function references(args, scope, execute) {\n    var e_3, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var pathSet, _i, args_2, arg, path, path_1, path_1_1, elem, e_3_1, scopeValue;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    pathSet = new Set();\n                    _i = 0, args_2 = args;\n                    _b.label = 1;\n                case 1:\n                    if (!(_i < args_2.length)) return [3 /*break*/, 16];\n                    arg = args_2[_i];\n                    return [4 /*yield*/, execute(arg, scope)];\n                case 2:\n                    path = _b.sent();\n                    if (!(path.type === 'string')) return [3 /*break*/, 3];\n                    pathSet.add(path.data);\n                    return [3 /*break*/, 15];\n                case 3:\n                    if (!path.isArray()) return [3 /*break*/, 15];\n                    _b.label = 4;\n                case 4:\n                    _b.trys.push([4, 9, 10, 15]);\n                    path_1 = (e_3 = void 0, __asyncValues(path));\n                    _b.label = 5;\n                case 5: return [4 /*yield*/, path_1.next()];\n                case 6:\n                    if (!(path_1_1 = _b.sent(), !path_1_1.done)) return [3 /*break*/, 8];\n                    elem = path_1_1.value;\n                    if (elem.type === 'string') {\n                        pathSet.add(elem.data);\n                    }\n                    _b.label = 7;\n                case 7: return [3 /*break*/, 5];\n                case 8: return [3 /*break*/, 15];\n                case 9:\n                    e_3_1 = _b.sent();\n                    e_3 = { error: e_3_1 };\n                    return [3 /*break*/, 15];\n                case 10:\n                    _b.trys.push([10, , 13, 14]);\n                    if (!(path_1_1 && !path_1_1.done && (_a = path_1[\"return\"]))) return [3 /*break*/, 12];\n                    return [4 /*yield*/, _a.call(path_1)];\n                case 11:\n                    _b.sent();\n                    _b.label = 12;\n                case 12: return [3 /*break*/, 14];\n                case 13:\n                    if (e_3) throw e_3.error;\n                    return [7 /*endfinally*/];\n                case 14: return [7 /*endfinally*/];\n                case 15:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 16:\n                    if (pathSet.size === 0) {\n                        return [2 /*return*/, FALSE_VALUE];\n                    }\n                    return [4 /*yield*/, scope.value.get()];\n                case 17:\n                    scopeValue = _b.sent();\n                    return [2 /*return*/, hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE];\n            }\n        });\n    });\n};\nglobal.references.arity = function (c) { return c >= 1; };\nglobal.round = function round(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, num, prec, precValue;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    num = value.data;\n                    prec = 0;\n                    if (!(args.length === 2)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    precValue = _a.sent();\n                    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    prec = precValue.data;\n                    _a.label = 3;\n                case 3:\n                    if (prec === 0) {\n                        if (num < 0) {\n                            // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n                            // The behavior we're interested in is to \"round half away from zero\".\n                            return [2 /*return*/, fromNumber(-Math.round(-num))];\n                        }\n                        return [2 /*return*/, fromNumber(Math.round(num))];\n                    }\n                    return [2 /*return*/, fromNumber(Number(num.toFixed(prec)))];\n            }\n        });\n    });\n};\nglobal.round.arity = function (count) { return count >= 1 && count <= 2; };\n// eslint-disable-next-line require-await\nglobal.now = function now(args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, fromString(scope.context.timestamp.toISOString())];\n        });\n    });\n};\nglobal.now.arity = 0;\n// eslint-disable-next-line require-await\nglobal.boost = function boost() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            // This should be handled by the scoring function.\n            throw new Error('unexpected boost call');\n        });\n    });\n};\nglobal.boost.arity = 2;\nvar string = {};\nstring.lower = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(value.data.toLowerCase())];\n            }\n        });\n    });\n};\nstring.lower.arity = 1;\nstring.upper = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(value.data.toUpperCase())];\n            }\n        });\n    });\n};\nstring.upper.arity = 1;\nstring.split = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var str, sep;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    str = _a.sent();\n                    if (str.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    sep = _a.sent();\n                    if (sep.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    if (str.data.length === 0) {\n                        return [2 /*return*/, fromJS([])];\n                    }\n                    if (sep.data.length === 0) {\n                        // This uses a Unicode codepoint splitting algorithm\n                        return [2 /*return*/, fromJS(Array.from(str.data))];\n                    }\n                    return [2 /*return*/, fromJS(str.data.split(sep.data))];\n            }\n        });\n    });\n};\nstring.split.arity = 2;\nglobal.lower = string.lower;\nglobal.upper = string.upper;\nstring.startsWith = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var str, prefix;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    str = _a.sent();\n                    if (str.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    prefix = _a.sent();\n                    if (prefix.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE];\n            }\n        });\n    });\n};\nstring.startsWith.arity = 2;\nvar array = {};\narray.join = function (args, scope, execute) {\n    var e_4, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, sep, buf, needSep, arr_1, arr_1_1, elem, e_4_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    sep = _b.sent();\n                    if (sep.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    buf = '';\n                    needSep = false;\n                    _b.label = 3;\n                case 3:\n                    _b.trys.push([3, 8, 9, 14]);\n                    arr_1 = __asyncValues(arr);\n                    _b.label = 4;\n                case 4: return [4 /*yield*/, arr_1.next()];\n                case 5:\n                    if (!(arr_1_1 = _b.sent(), !arr_1_1.done)) return [3 /*break*/, 7];\n                    elem = arr_1_1.value;\n                    if (needSep) {\n                        buf += sep.data;\n                    }\n                    switch (elem.type) {\n                        case 'number':\n                        case 'string':\n                        case 'boolean':\n                        case 'datetime':\n                            buf += \"\".concat(elem.data);\n                            break;\n                        default:\n                            return [2 /*return*/, NULL_VALUE];\n                    }\n                    needSep = true;\n                    _b.label = 6;\n                case 6: return [3 /*break*/, 4];\n                case 7: return [3 /*break*/, 14];\n                case 8:\n                    e_4_1 = _b.sent();\n                    e_4 = { error: e_4_1 };\n                    return [3 /*break*/, 14];\n                case 9:\n                    _b.trys.push([9, , 12, 13]);\n                    if (!(arr_1_1 && !arr_1_1.done && (_a = arr_1[\"return\"]))) return [3 /*break*/, 11];\n                    return [4 /*yield*/, _a.call(arr_1)];\n                case 10:\n                    _b.sent();\n                    _b.label = 11;\n                case 11: return [3 /*break*/, 13];\n                case 12:\n                    if (e_4) throw e_4.error;\n                    return [7 /*endfinally*/];\n                case 13: return [7 /*endfinally*/];\n                case 14: return [2 /*return*/, fromJS(buf)];\n            }\n        });\n    });\n};\narray.join.arity = 2;\narray.compact = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var arr;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _a.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, new StreamValue(function () {\n                            return __asyncGenerator(this, arguments, function () {\n                                var arr_2, arr_2_1, elem, e_5_1;\n                                var e_5, _a;\n                                return __generator(this, function (_b) {\n                                    switch (_b.label) {\n                                        case 0:\n                                            _b.trys.push([0, 7, 8, 13]);\n                                            arr_2 = __asyncValues(arr);\n                                            _b.label = 1;\n                                        case 1: return [4 /*yield*/, __await(arr_2.next())];\n                                        case 2:\n                                            if (!(arr_2_1 = _b.sent(), !arr_2_1.done)) return [3 /*break*/, 6];\n                                            elem = arr_2_1.value;\n                                            if (!(elem.type !== 'null')) return [3 /*break*/, 5];\n                                            return [4 /*yield*/, __await(elem)];\n                                        case 3: return [4 /*yield*/, _b.sent()];\n                                        case 4:\n                                            _b.sent();\n                                            _b.label = 5;\n                                        case 5: return [3 /*break*/, 1];\n                                        case 6: return [3 /*break*/, 13];\n                                        case 7:\n                                            e_5_1 = _b.sent();\n                                            e_5 = { error: e_5_1 };\n                                            return [3 /*break*/, 13];\n                                        case 8:\n                                            _b.trys.push([8, , 11, 12]);\n                                            if (!(arr_2_1 && !arr_2_1.done && (_a = arr_2[\"return\"]))) return [3 /*break*/, 10];\n                                            return [4 /*yield*/, __await(_a.call(arr_2))];\n                                        case 9:\n                                            _b.sent();\n                                            _b.label = 10;\n                                        case 10: return [3 /*break*/, 12];\n                                        case 11:\n                                            if (e_5) throw e_5.error;\n                                            return [7 /*endfinally*/];\n                                        case 12: return [7 /*endfinally*/];\n                                        case 13: return [2 /*return*/];\n                                    }\n                                });\n                            });\n                        })];\n            }\n        });\n    });\n};\narray.compact.arity = 1;\narray.unique = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (!value.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, new StreamValue(function () {\n                            return __asyncGenerator(this, arguments, function () {\n                                var added, value_2, value_2_1, iter, _a, e_6_1;\n                                var e_6, _b;\n                                return __generator(this, function (_c) {\n                                    switch (_c.label) {\n                                        case 0:\n                                            added = new Set();\n                                            _c.label = 1;\n                                        case 1:\n                                            _c.trys.push([1, 13, 14, 19]);\n                                            value_2 = __asyncValues(value);\n                                            _c.label = 2;\n                                        case 2: return [4 /*yield*/, __await(value_2.next())];\n                                        case 3:\n                                            if (!(value_2_1 = _c.sent(), !value_2_1.done)) return [3 /*break*/, 12];\n                                            iter = value_2_1.value;\n                                            _a = iter.type;\n                                            switch (_a) {\n                                                case 'number': return [3 /*break*/, 4];\n                                                case 'string': return [3 /*break*/, 4];\n                                                case 'boolean': return [3 /*break*/, 4];\n                                                case 'datetime': return [3 /*break*/, 4];\n                                            }\n                                            return [3 /*break*/, 8];\n                                        case 4:\n                                            if (!!added.has(iter.data)) return [3 /*break*/, 7];\n                                            added.add(iter.data);\n                                            return [4 /*yield*/, __await(iter)];\n                                        case 5: return [4 /*yield*/, _c.sent()];\n                                        case 6:\n                                            _c.sent();\n                                            _c.label = 7;\n                                        case 7: return [3 /*break*/, 11];\n                                        case 8: return [4 /*yield*/, __await(iter)];\n                                        case 9: return [4 /*yield*/, _c.sent()];\n                                        case 10:\n                                            _c.sent();\n                                            _c.label = 11;\n                                        case 11: return [3 /*break*/, 2];\n                                        case 12: return [3 /*break*/, 19];\n                                        case 13:\n                                            e_6_1 = _c.sent();\n                                            e_6 = { error: e_6_1 };\n                                            return [3 /*break*/, 19];\n                                        case 14:\n                                            _c.trys.push([14, , 17, 18]);\n                                            if (!(value_2_1 && !value_2_1.done && (_b = value_2[\"return\"]))) return [3 /*break*/, 16];\n                                            return [4 /*yield*/, __await(_b.call(value_2))];\n                                        case 15:\n                                            _c.sent();\n                                            _c.label = 16;\n                                        case 16: return [3 /*break*/, 18];\n                                        case 17:\n                                            if (e_6) throw e_6.error;\n                                            return [7 /*endfinally*/];\n                                        case 18: return [7 /*endfinally*/];\n                                        case 19: return [2 /*return*/];\n                                    }\n                                });\n                            });\n                        })];\n            }\n        });\n    });\n};\narray.unique.arity = 1;\nvar pt = {};\npt.text = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, text;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    return [4 /*yield*/, portableTextContent(value)];\n                case 2:\n                    text = _a.sent();\n                    if (text === null) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(text)];\n            }\n        });\n    });\n};\npt.text.arity = 1;\nvar sanity = {};\n// eslint-disable-next-line require-await\nsanity.projectId = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (scope.context.sanity) {\n                return [2 /*return*/, fromString(scope.context.sanity.projectId)];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\n// eslint-disable-next-line require-await\nsanity.dataset = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (scope.context.sanity) {\n                return [2 /*return*/, fromString(scope.context.sanity.dataset)];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\nvar pipeFunctions = {};\npipeFunctions.order = function order(base, args, scope, execute) {\n    var base_1, base_1_1;\n    var e_7, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var mappers, directions, n, _i, args_3, mapper, direction, aux, idx, value, newScope, tuple, i, result, _b, _c, e_7_1;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0: \n                // eslint-disable-next-line max-len\n                // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n                return [4 /*yield*/, true];\n                case 1:\n                    // eslint-disable-next-line max-len\n                    // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n                    _d.sent();\n                    if (!base.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    mappers = [];\n                    directions = [];\n                    n = 0;\n                    for (_i = 0, args_3 = args; _i < args_3.length; _i++) {\n                        mapper = args_3[_i];\n                        direction = 'asc';\n                        if (mapper.type === 'Desc') {\n                            direction = 'desc';\n                            mapper = mapper.base;\n                        }\n                        else if (mapper.type === 'Asc') {\n                            mapper = mapper.base;\n                        }\n                        mappers.push(mapper);\n                        directions.push(direction);\n                        n++;\n                    }\n                    aux = [];\n                    idx = 0;\n                    _d.label = 2;\n                case 2:\n                    _d.trys.push([2, 13, 14, 19]);\n                    base_1 = __asyncValues(base);\n                    _d.label = 3;\n                case 3: return [4 /*yield*/, base_1.next()];\n                case 4:\n                    if (!(base_1_1 = _d.sent(), !base_1_1.done)) return [3 /*break*/, 12];\n                    value = base_1_1.value;\n                    newScope = scope.createNested(value);\n                    return [4 /*yield*/, value.get()];\n                case 5:\n                    tuple = [_d.sent(), idx];\n                    i = 0;\n                    _d.label = 6;\n                case 6:\n                    if (!(i < n)) return [3 /*break*/, 10];\n                    return [4 /*yield*/, execute(mappers[i], newScope)];\n                case 7:\n                    result = _d.sent();\n                    _c = (_b = tuple).push;\n                    return [4 /*yield*/, result.get()];\n                case 8:\n                    _c.apply(_b, [_d.sent()]);\n                    _d.label = 9;\n                case 9:\n                    i++;\n                    return [3 /*break*/, 6];\n                case 10:\n                    aux.push(tuple);\n                    idx++;\n                    _d.label = 11;\n                case 11: return [3 /*break*/, 3];\n                case 12: return [3 /*break*/, 19];\n                case 13:\n                    e_7_1 = _d.sent();\n                    e_7 = { error: e_7_1 };\n                    return [3 /*break*/, 19];\n                case 14:\n                    _d.trys.push([14, , 17, 18]);\n                    if (!(base_1_1 && !base_1_1.done && (_a = base_1[\"return\"]))) return [3 /*break*/, 16];\n                    return [4 /*yield*/, _a.call(base_1)];\n                case 15:\n                    _d.sent();\n                    _d.label = 16;\n                case 16: return [3 /*break*/, 18];\n                case 17:\n                    if (e_7) throw e_7.error;\n                    return [7 /*endfinally*/];\n                case 18: return [7 /*endfinally*/];\n                case 19:\n                    aux.sort(function (aTuple, bTuple) {\n                        for (var i = 0; i < n; i++) {\n                            var c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n                            if (directions[i] === 'desc') {\n                                c = -c;\n                            }\n                            if (c !== 0) {\n                                return c;\n                            }\n                        }\n                        // Fallback to sorting on the original index for stable sorting.\n                        return aTuple[1] - bTuple[1];\n                    });\n                    return [2 /*return*/, fromJS(aux.map(function (v) { return v[0]; }))];\n            }\n        });\n    });\n};\npipeFunctions.order.arity = function (count) { return count >= 1; };\n// eslint-disable-next-line require-await\npipeFunctions.score = function score(base, args, scope, execute) {\n    var base_2, base_2_1;\n    var e_8, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var unknown, scored, value, _b, _c, newScope, valueScore, _i, args_4, arg, _d, newObject, e_8_1;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    if (!base.isArray())\n                        return [2 /*return*/, NULL_VALUE\n                            // Anything that isn't an object should be sorted first.\n                        ];\n                    unknown = [];\n                    scored = [];\n                    _e.label = 1;\n                case 1:\n                    _e.trys.push([1, 12, 13, 18]);\n                    base_2 = __asyncValues(base);\n                    _e.label = 2;\n                case 2: return [4 /*yield*/, base_2.next()];\n                case 3:\n                    if (!(base_2_1 = _e.sent(), !base_2_1.done)) return [3 /*break*/, 11];\n                    value = base_2_1.value;\n                    if (!(value.type !== 'object')) return [3 /*break*/, 5];\n                    _c = (_b = unknown).push;\n                    return [4 /*yield*/, value.get()];\n                case 4:\n                    _c.apply(_b, [_e.sent()]);\n                    return [3 /*break*/, 10];\n                case 5:\n                    newScope = scope.createNested(value);\n                    valueScore = typeof value.data._score === 'number' ? value.data._score : 0;\n                    _i = 0, args_4 = args;\n                    _e.label = 6;\n                case 6:\n                    if (!(_i < args_4.length)) return [3 /*break*/, 9];\n                    arg = args_4[_i];\n                    _d = valueScore;\n                    return [4 /*yield*/, evaluateScore(arg, newScope, execute)];\n                case 7:\n                    valueScore = _d + _e.sent();\n                    _e.label = 8;\n                case 8:\n                    _i++;\n                    return [3 /*break*/, 6];\n                case 9:\n                    newObject = Object.assign({}, value.data, { _score: valueScore });\n                    scored.push(newObject);\n                    _e.label = 10;\n                case 10: return [3 /*break*/, 2];\n                case 11: return [3 /*break*/, 18];\n                case 12:\n                    e_8_1 = _e.sent();\n                    e_8 = { error: e_8_1 };\n                    return [3 /*break*/, 18];\n                case 13:\n                    _e.trys.push([13, , 16, 17]);\n                    if (!(base_2_1 && !base_2_1.done && (_a = base_2[\"return\"]))) return [3 /*break*/, 15];\n                    return [4 /*yield*/, _a.call(base_2)];\n                case 14:\n                    _e.sent();\n                    _e.label = 15;\n                case 15: return [3 /*break*/, 17];\n                case 16:\n                    if (e_8) throw e_8.error;\n                    return [7 /*endfinally*/];\n                case 17: return [7 /*endfinally*/];\n                case 18:\n                    scored.sort(function (a, b) { return b._score - a._score; });\n                    return [2 /*return*/, fromJS(scored)];\n            }\n        });\n    });\n};\npipeFunctions.score.arity = function (count) { return count >= 1; };\nvar delta = {};\ndelta.operation = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        var hasBefore, hasAfter;\n        return __generator(this, function (_a) {\n            hasBefore = scope.context.before !== null;\n            hasAfter = scope.context.after !== null;\n            if (hasBefore && hasAfter) {\n                return [2 /*return*/, fromString('update')];\n            }\n            if (hasAfter) {\n                return [2 /*return*/, fromString('create')];\n            }\n            if (hasBefore) {\n                return [2 /*return*/, fromString('delete')];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\ndelta.changedAny = function () {\n    throw new Error('not implemented');\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = 'delta';\ndelta.changedOnly = function () {\n    throw new Error('not implemented');\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = 'delta';\nvar diff = {};\ndiff.changedAny = function () {\n    throw new Error('not implemented');\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = function () {\n    throw new Error('not implemented');\n};\ndiff.changedOnly.arity = 3;\nvar math = {};\nmath.min = function (args, scope, execute) {\n    var e_9, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, n, arr_3, arr_3_1, elem, e_9_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n = undefined;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    arr_3 = __asyncValues(arr);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, arr_3.next()];\n                case 4:\n                    if (!(arr_3_1 = _b.sent(), !arr_3_1.done)) return [3 /*break*/, 6];\n                    elem = arr_3_1.value;\n                    if (elem.type === 'null')\n                        return [3 /*break*/, 5];\n                    if (elem.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    if (n === undefined || elem.data < n) {\n                        n = elem.data;\n                    }\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_9_1 = _b.sent();\n                    e_9 = { error: e_9_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(arr_3_1 && !arr_3_1.done && (_a = arr_3[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(arr_3)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_9) throw e_9.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromJS(n)];\n            }\n        });\n    });\n};\nmath.min.arity = 1;\nmath.max = function (args, scope, execute) {\n    var e_10, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, n, arr_4, arr_4_1, elem, e_10_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n = undefined;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    arr_4 = __asyncValues(arr);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, arr_4.next()];\n                case 4:\n                    if (!(arr_4_1 = _b.sent(), !arr_4_1.done)) return [3 /*break*/, 6];\n                    elem = arr_4_1.value;\n                    if (elem.type === 'null')\n                        return [3 /*break*/, 5];\n                    if (elem.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    if (n === undefined || elem.data > n) {\n                        n = elem.data;\n                    }\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_10_1 = _b.sent();\n                    e_10 = { error: e_10_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(arr_4_1 && !arr_4_1.done && (_a = arr_4[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(arr_4)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_10) throw e_10.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromJS(n)];\n            }\n        });\n    });\n};\nmath.max.arity = 1;\nmath.sum = function (args, scope, execute) {\n    var e_11, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, n, arr_5, arr_5_1, elem, e_11_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    arr_5 = __asyncValues(arr);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, arr_5.next()];\n                case 4:\n                    if (!(arr_5_1 = _b.sent(), !arr_5_1.done)) return [3 /*break*/, 6];\n                    elem = arr_5_1.value;\n                    if (elem.type === 'null')\n                        return [3 /*break*/, 5];\n                    if (elem.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n += elem.data;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_11_1 = _b.sent();\n                    e_11 = { error: e_11_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(arr_5_1 && !arr_5_1.done && (_a = arr_5[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(arr_5)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_11) throw e_11.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromJS(n)];\n            }\n        });\n    });\n};\nmath.sum.arity = 1;\nmath.avg = function (args, scope, execute) {\n    var e_12, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var arr, n, c, arr_6, arr_6_1, elem, e_12_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    arr = _b.sent();\n                    if (!arr.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n = 0;\n                    c = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    arr_6 = __asyncValues(arr);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, arr_6.next()];\n                case 4:\n                    if (!(arr_6_1 = _b.sent(), !arr_6_1.done)) return [3 /*break*/, 6];\n                    elem = arr_6_1.value;\n                    if (elem.type === 'null')\n                        return [3 /*break*/, 5];\n                    if (elem.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    n += elem.data;\n                    c++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_12_1 = _b.sent();\n                    e_12 = { error: e_12_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(arr_6_1 && !arr_6_1.done && (_a = arr_6[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(arr_6)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_12) throw e_12.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13:\n                    if (c === 0) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromJS(n / c)];\n            }\n        });\n    });\n};\nmath.avg.arity = 1;\nvar namespaces = {\n    global: global,\n    string: string,\n    array: array,\n    pt: pt,\n    delta: delta,\n    diff: diff,\n    sanity: sanity,\n    math: math\n};const WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\n\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position);\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1;\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position;\n  delete result.failPosition;\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos;\n  let token = str[pos];\n  let marks;\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position);\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks);\n          pos = skipWS(str, pos + 1);\n          while (true) {\n            rhs = parseExpr(str, pos, 0);\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position);\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1);\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++;\n          marks.push({name: 'tuple_end', position: pos});\n          break\n        }\n        case ')': {\n          pos++;\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks);\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos);\n      if (result.type === 'error') return result\n      marks = result.marks;\n      pos = result.position;\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}];\n      pos = skipWS(str, pos + 1);\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos});\n            pos = skipWS(str, pos + 3);\n          }\n\n          let res = parseExpr(str, pos, 0);\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks);\n          pos = res.position;\n          pos = skipWS(str, pos);\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1);\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++;\n        marks.push({name: 'array_end', position: pos});\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === 'error') return result\n      marks = result.marks;\n      pos = result.position;\n      break\n    }\n    case '^': {\n      pos++;\n      marks = [];\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos});\n        pos += 2;\n      }\n      marks.push({name: 'parent', position: startPos});\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}];\n      pos++;\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}];\n      pos++;\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      if (identLen) {\n        pos += 1 + identLen;\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ];\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = 'integer';\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          if (fracLen) {\n            name = 'float';\n            pos += 1 + fracLen;\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci';\n          pos++;\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++;\n          }\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen;\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ];\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        pos += identLen;\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === 'error') return result\n            marks = result.marks;\n            pos = result.position;\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ];\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12;\n  let trav;\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break\n    }\n\n    trav = parseTraversal(str, innerPos);\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos});\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks);\n        pos = trav.position;\n        trav = parseTraversal(str, skipWS(str, pos));\n      }\n      marks.push({name: 'traversal_end', position: pos});\n      continue\n    }\n\n    let token = str[innerPos];\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1];\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks);\n            marks.unshift({name: 'pair', position: startPos});\n            pos = rhs.position;\n            lhsLevel = PREC_PAIR;\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos});\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n            marks = marks.concat(rhs.marks);\n            pos = rhs.position;\n            lhsLevel = PREC_COMP;\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'add', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_ADD;\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'sub', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_SUB;\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks);\n          marks.unshift({name: 'pow', position: startPos});\n          pos = rhs.position;\n          lhsLevel = PREC_POW;\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'mul', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_MUL;\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'div', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_DIV;\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'mod', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_MOD;\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1;\n        if (str[nextPos] === '=') {\n          nextPos++;\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos});\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos});\n        marks = marks.concat(rhs.marks);\n        pos = rhs.position;\n        lhsLevel = PREC_COMP;\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks);\n          marks.unshift({name: 'or', position: startPos});\n          pos = rhs.position;\n          lhsLevel = PREC_OR;\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1);\n          let identLen = parseRegex(str, identPos, IDENT);\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen;\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos);\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks);\n            marks.unshift({name: 'pipecall', position: startPos});\n            pos = result.position;\n            lhsLevel = 11;\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'and', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_AND;\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos});\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n        marks = marks.concat(rhs.marks);\n        pos = rhs.position;\n        lhsLevel = PREC_COMP;\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos});\n        pos = innerPos + 4;\n        lhsLevel = PREC_ORDER;\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos});\n        pos = innerPos + 3;\n        lhsLevel = PREC_ORDER;\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT);\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2);\n\n            let isGroup = false;\n\n            if (str[pos] === '(') {\n              isGroup = true;\n              pos = skipWS(str, pos + 1);\n            }\n\n            let rangePos = pos;\n            let result = parseExpr(str, pos, PREC_COMP + 1);\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position);\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range';\n              if (str[pos + 2] === '.') {\n                type = 'exc_range';\n                pos = skipWS(str, pos + 3);\n              } else {\n                pos = skipWS(str, pos + 2);\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1);\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos});\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks);\n              pos = rhs.position;\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos});\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n              marks = marks.concat(result.marks);\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos);\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++;\n            }\n\n            lhsLevel = PREC_COMP;\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos});\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5});\n            marks = marks.concat(rhs.marks);\n            pos = rhs.position;\n            lhsLevel = 4;\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position;\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1);\n      let identStart = pos;\n      let identLen = parseRegex(str, pos, IDENT);\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen;\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}];\n      pos += 2;\n\n      let identPos = skipWS(str, pos);\n      let identLen = parseRegex(str, identPos, IDENT);\n      if (identLen) {\n        pos = identPos + identLen;\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos}\n        );\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1);\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos;\n      let result = parseExpr(str, pos, 0);\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position);\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range';\n        if (str[pos + 2] === '.') {\n          type = 'exc_range';\n          pos += 3;\n        } else {\n          pos += 2;\n        }\n\n        pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position);\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos);\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos});\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos);\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos});\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n\n  marks.push({name: 'func_call', position: startPos});\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos});\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});\n    pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen});\n    pos = skipWS(str, pos + nameLen);\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++;\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});\n    pos = skipWS(str, pos + 1);\n  }\n\n  let lastPos = pos;\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks);\n      lastPos = result.position;\n      pos = skipWS(str, result.position);\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1);\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos});\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}];\n  pos = skipWS(str, pos + 1);\n\n  while (str[pos] !== '}') {\n    let pairPos = pos;\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3);\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos});\n        marks = marks.concat(expr.marks);\n        pos = expr.position;\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos});\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos});\n        marks = marks.concat(expr.marks, value.marks);\n        pos = value.position;\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks);\n        pos = expr.position;\n      }\n    }\n    pos = skipWS(str, pos);\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1);\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++;\n  marks.push({name: 'object_end', position: pos});\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{name: 'str', position: pos}];\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos});\n        pos++;\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos});\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3});\n            pos = str.indexOf('}', pos + 3);\n            marks.push({name: 'unicode_hex_end', position: pos});\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2});\n            marks.push({name: 'unicode_hex_end', position: pos + 6});\n            pos += 5;\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1});\n          pos += 1;\n        }\n        marks.push({name: 'str_start', position: pos + 1});\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null\n}/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a, b) {\n    return function (base) { return b(a(base)); };\n}\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner) {\n    return function (base) { return ({ type: 'Map', base: base, expr: inner({ type: 'This' }) }); };\n}\nfunction flatMap(inner) {\n    return function (base) { return ({ type: 'FlatMap', base: base, expr: inner({ type: 'This' }) }); };\n}\nfunction traverseArray(build, right) {\n    if (!right) {\n        return {\n            type: 'a-a',\n            build: build\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n            return {\n                type: 'a-a',\n                build: join(build, right.build)\n            };\n        case 'a-b':\n            return {\n                type: 'a-b',\n                build: join(build, right.build)\n            };\n        case 'b-b':\n            return {\n                type: 'a-a',\n                build: join(build, map(right.build))\n            };\n        case 'b-a':\n            return {\n                type: 'a-a',\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) {\n        return {\n            type: 'b-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n        case 'b-a':\n            return {\n                type: 'b-a',\n                build: join(mapper, right.build)\n            };\n        case 'a-b':\n        case 'b-b':\n            return {\n                type: 'b-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) {\n        return {\n            type: 'a-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n        case 'b-a':\n            return {\n                type: 'a-a',\n                build: join(mapper, right.build)\n            };\n        case 'a-b':\n        case 'b-b':\n            return {\n                type: 'a-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) {\n        return {\n            type: 'b-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n            return {\n                type: 'a-a',\n                build: join(map(mapper), right.build)\n            };\n        case 'a-b':\n            return {\n                type: 'a-b',\n                build: join(map(mapper), right.build)\n            };\n        case 'b-a':\n            return {\n                type: 'b-a',\n                build: join(mapper, right.build)\n            };\n        case 'b-b':\n            return {\n                type: 'b-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}var isEqual = equality;\nfunction equality(a, b) {\n    if ((a.type === 'string' && b.type === 'string') ||\n        (a.type === 'boolean' && b.type === 'boolean') ||\n        (a.type === 'null' && b.type === 'null') ||\n        (a.type === 'number' && b.type === 'number')) {\n        return a.data === b.data;\n    }\n    if (a.type === 'datetime' && b.type === 'datetime') {\n        return a.data.equals(b.data);\n    }\n    return false;\n}var operators = {\n    '==': function eq(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '!=': function neq(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    '>': function gt(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '>=': function gte(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '<': function lt(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '<=': function lte(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    \"in\": function inop(left, right) {\n        var right_1, right_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var b, e_1_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (right.type === 'path') {\n                            if (left.type !== 'string') {\n                                return [2 /*return*/, NULL_VALUE];\n                            }\n                            return [2 /*return*/, right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE];\n                        }\n                        if (!right.isArray()) return [3 /*break*/, 13];\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 6, 7, 12]);\n                        right_1 = __asyncValues(right);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, right_1.next()];\n                    case 3:\n                        if (!(right_1_1 = _b.sent(), !right_1_1.done)) return [3 /*break*/, 5];\n                        b = right_1_1.value;\n                        if (isEqual(left, b)) {\n                            return [2 /*return*/, TRUE_VALUE];\n                        }\n                        _b.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _b.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _b.trys.push([7, , 10, 11]);\n                        if (!(right_1_1 && !right_1_1.done && (_a = right_1[\"return\"]))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(right_1)];\n                    case 8:\n                        _b.sent();\n                        _b.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12: return [2 /*return*/, FALSE_VALUE];\n                    case 13: return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    match: function match(left, right) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokens, patterns, didSucceed, matched;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tokens = [];\n                        patterns = [];\n                        return [4 /*yield*/, gatherText(left, function (part) {\n                                tokens = tokens.concat(matchTokenize(part));\n                            })];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, gatherText(right, function (part) {\n                                patterns = patterns.concat(matchAnalyzePattern(part));\n                            })];\n                    case 2:\n                        didSucceed = _a.sent();\n                        if (!didSucceed) {\n                            return [2 /*return*/, FALSE_VALUE];\n                        }\n                        matched = matchText(tokens, patterns);\n                        return [2 /*return*/, matched ? TRUE_VALUE : FALSE_VALUE];\n                }\n            });\n        });\n    },\n    '+': function plus(left, right) {\n        if (left.type === 'datetime' && right.type === 'number') {\n            return fromDateTime(left.data.add(right.data));\n        }\n        if (left.type === 'number' && right.type === 'number') {\n            return fromNumber(left.data + right.data);\n        }\n        if (left.type === 'string' && right.type === 'string') {\n            return fromString(left.data + right.data);\n        }\n        if (left.type === 'object' && right.type === 'object') {\n            return fromJS(__assign(__assign({}, left.data), right.data));\n        }\n        if (left.type === 'array' && right.type === 'array') {\n            return fromJS(left.data.concat(right.data));\n        }\n        if (left.isArray() && right.isArray()) {\n            return new StreamValue(function () {\n                return __asyncGenerator(this, arguments, function () {\n                    var left_1, left_1_1, val, e_2_1, right_2, right_2_1, val, e_3_1;\n                    var e_2, _a, e_3, _b;\n                    return __generator(this, function (_c) {\n                        switch (_c.label) {\n                            case 0:\n                                _c.trys.push([0, 7, 8, 13]);\n                                left_1 = __asyncValues(left);\n                                _c.label = 1;\n                            case 1: return [4 /*yield*/, __await(left_1.next())];\n                            case 2:\n                                if (!(left_1_1 = _c.sent(), !left_1_1.done)) return [3 /*break*/, 6];\n                                val = left_1_1.value;\n                                return [4 /*yield*/, __await(val)];\n                            case 3: return [4 /*yield*/, _c.sent()];\n                            case 4:\n                                _c.sent();\n                                _c.label = 5;\n                            case 5: return [3 /*break*/, 1];\n                            case 6: return [3 /*break*/, 13];\n                            case 7:\n                                e_2_1 = _c.sent();\n                                e_2 = { error: e_2_1 };\n                                return [3 /*break*/, 13];\n                            case 8:\n                                _c.trys.push([8, , 11, 12]);\n                                if (!(left_1_1 && !left_1_1.done && (_a = left_1[\"return\"]))) return [3 /*break*/, 10];\n                                return [4 /*yield*/, __await(_a.call(left_1))];\n                            case 9:\n                                _c.sent();\n                                _c.label = 10;\n                            case 10: return [3 /*break*/, 12];\n                            case 11:\n                                if (e_2) throw e_2.error;\n                                return [7 /*endfinally*/];\n                            case 12: return [7 /*endfinally*/];\n                            case 13:\n                                _c.trys.push([13, 20, 21, 26]);\n                                right_2 = __asyncValues(right);\n                                _c.label = 14;\n                            case 14: return [4 /*yield*/, __await(right_2.next())];\n                            case 15:\n                                if (!(right_2_1 = _c.sent(), !right_2_1.done)) return [3 /*break*/, 19];\n                                val = right_2_1.value;\n                                return [4 /*yield*/, __await(val)];\n                            case 16: return [4 /*yield*/, _c.sent()];\n                            case 17:\n                                _c.sent();\n                                _c.label = 18;\n                            case 18: return [3 /*break*/, 14];\n                            case 19: return [3 /*break*/, 26];\n                            case 20:\n                                e_3_1 = _c.sent();\n                                e_3 = { error: e_3_1 };\n                                return [3 /*break*/, 26];\n                            case 21:\n                                _c.trys.push([21, , 24, 25]);\n                                if (!(right_2_1 && !right_2_1.done && (_b = right_2[\"return\"]))) return [3 /*break*/, 23];\n                                return [4 /*yield*/, __await(_b.call(right_2))];\n                            case 22:\n                                _c.sent();\n                                _c.label = 23;\n                            case 23: return [3 /*break*/, 25];\n                            case 24:\n                                if (e_3) throw e_3.error;\n                                return [7 /*endfinally*/];\n                            case 25: return [7 /*endfinally*/];\n                            case 26: return [2 /*return*/];\n                        }\n                    });\n                });\n            });\n        }\n        return NULL_VALUE;\n    },\n    '-': function minus(left, right) {\n        if (left.type === 'datetime' && right.type === 'number') {\n            return fromDateTime(left.data.add(-right.data));\n        }\n        if (left.type === 'datetime' && right.type === 'datetime') {\n            return fromNumber(left.data.difference(right.data));\n        }\n        if (left.type === 'number' && right.type === 'number') {\n            return fromNumber(left.data - right.data);\n        }\n        return NULL_VALUE;\n    },\n    '*': numericOperator(function (a, b) { return a * b; }),\n    '/': numericOperator(function (a, b) { return a / b; }),\n    '%': numericOperator(function (a, b) { return a % b; }),\n    '**': numericOperator(function (a, b) { return Math.pow(a, b); })\n};\nfunction numericOperator(impl) {\n    return function (left, right) {\n        if (left.type === 'number' && right.type === 'number') {\n            var result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}var Scope = /** @class */ (function () {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    function Scope(params, source, value, context, parent) {\n        this.isHidden = false;\n        this.params = params;\n        this.source = source;\n        this.value = value;\n        this.context = context;\n        this.parent = parent;\n    }\n    Scope.prototype.createNested = function (value) {\n        if (this.isHidden) {\n            return new Scope(this.params, this.source, value, this.context, this.parent);\n        }\n        return new Scope(this.params, this.source, value, this.context, this);\n    };\n    Scope.prototype.createHidden = function (value) {\n        var result = this.createNested(value);\n        result.isHidden = true;\n        return result;\n    };\n    return Scope;\n}());function evaluate(node, scope, execute) {\n    if (execute === void 0) { execute = evaluate; }\n    var func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(value, cb) {\n    if ('then' in value) {\n        return value.then(cb);\n    }\n    return cb(value);\n}\nvar EXECUTORS = {\n    This: function (_, scope) {\n        return scope.value;\n    },\n    Selector: function () {\n        // These should be evaluated separely using a different evaluator.\n        // At the mooment we haven't implemented this.\n        throw new Error('Selectors can not be evaluated');\n    },\n    Everything: function (_, scope) {\n        return scope.source;\n    },\n    Parameter: function (_a, scope) {\n        var name = _a.name;\n        return fromJS(scope.params[name]);\n    },\n    Context: function (_a, scope) {\n        var key = _a.key;\n        if (key === 'before' || key === 'after') {\n            var value = scope.context[key];\n            return value || NULL_VALUE;\n        }\n        throw new Error(\"unknown context key: \".concat(key));\n    },\n    Parent: function (_a, scope) {\n        var n = _a.n;\n        var current = scope;\n        for (var i = 0; i < n; i++) {\n            if (!current.parent) {\n                return NULL_VALUE;\n            }\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall: function (_a, scope, execute) {\n        var _this = this;\n        var op = _a.op, left = _a.left, right = _a.right;\n        var func = operators[op];\n        if (!func) {\n            throw new Error(\"Unknown operator: \".concat(op));\n        }\n        var leftValue = execute(left, scope);\n        var rightValue = execute(right, scope);\n        // Avoid uneccesary promises\n        // This is required for constant evaluation to work correctly.\n        if ('then' in leftValue || 'then' in rightValue) {\n            return (function () { return __awaiter(_this, void 0, void 0, function () { var _a, _b; return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = func;\n                        return [4 /*yield*/, leftValue];\n                    case 1:\n                        _b = [_c.sent()];\n                        return [4 /*yield*/, rightValue];\n                    case 2: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent()]))];\n                }\n            }); }); })();\n        }\n        return func(leftValue, rightValue);\n    },\n    Select: function (_a, scope, execute) {\n        var alternatives = _a.alternatives, fallback = _a.fallback;\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, alternatives_1, alt, altCond;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _i = 0, alternatives_1 = alternatives;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < alternatives_1.length)) return [3 /*break*/, 4];\n                        alt = alternatives_1[_i];\n                        return [4 /*yield*/, execute(alt.condition, scope)];\n                    case 2:\n                        altCond = _b.sent();\n                        if (altCond.type === 'boolean' && altCond.data === true) {\n                            return [2 /*return*/, execute(alt.value, scope)];\n                        }\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        if (fallback) {\n                            return [2 /*return*/, execute(fallback, scope)];\n                        }\n                        return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    InRange: function (_a, scope, execute) {\n        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;\n        return __awaiter(this, void 0, void 0, function () {\n            var value, leftValue, rightValue, leftCmp, _b, _c, rightCmp, _d, _e;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _f.sent();\n                        return [4 /*yield*/, execute(left, scope)];\n                    case 2:\n                        leftValue = _f.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 3:\n                        rightValue = _f.sent();\n                        _b = partialCompare;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _c = [_f.sent()];\n                        return [4 /*yield*/, leftValue.get()];\n                    case 5:\n                        leftCmp = _b.apply(void 0, _c.concat([_f.sent()]));\n                        if (leftCmp === null) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        _d = partialCompare;\n                        return [4 /*yield*/, value.get()];\n                    case 6:\n                        _e = [_f.sent()];\n                        return [4 /*yield*/, rightValue.get()];\n                    case 7:\n                        rightCmp = _d.apply(void 0, _e.concat([_f.sent()]));\n                        if (rightCmp === null) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        if (isInclusive) {\n                            return [2 /*return*/, leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE];\n                        }\n                        return [2 /*return*/, leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE];\n                }\n            });\n        });\n    },\n    Filter: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var baseValue_1, baseValue_1_1, elem, newScope, exprValue, e_1_1;\n                                    var e_1, _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                _b.trys.push([0, 8, 9, 14]);\n                                                baseValue_1 = __asyncValues(baseValue);\n                                                _b.label = 1;\n                                            case 1: return [4 /*yield*/, __await(baseValue_1.next())];\n                                            case 2:\n                                                if (!(baseValue_1_1 = _b.sent(), !baseValue_1_1.done)) return [3 /*break*/, 7];\n                                                elem = baseValue_1_1.value;\n                                                newScope = scope.createNested(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3:\n                                                exprValue = _b.sent();\n                                                if (!(exprValue.type === 'boolean' && exprValue.data === true)) return [3 /*break*/, 6];\n                                                return [4 /*yield*/, __await(elem)];\n                                            case 4: return [4 /*yield*/, _b.sent()];\n                                            case 5:\n                                                _b.sent();\n                                                _b.label = 6;\n                                            case 6: return [3 /*break*/, 1];\n                                            case 7: return [3 /*break*/, 14];\n                                            case 8:\n                                                e_1_1 = _b.sent();\n                                                e_1 = { error: e_1_1 };\n                                                return [3 /*break*/, 14];\n                                            case 9:\n                                                _b.trys.push([9, , 12, 13]);\n                                                if (!(baseValue_1_1 && !baseValue_1_1.done && (_a = baseValue_1[\"return\"]))) return [3 /*break*/, 11];\n                                                return [4 /*yield*/, __await(_a.call(baseValue_1))];\n                                            case 10:\n                                                _b.sent();\n                                                _b.label = 11;\n                                            case 11: return [3 /*break*/, 13];\n                                            case 12:\n                                                if (e_1) throw e_1.error;\n                                                return [7 /*endfinally*/];\n                                            case 13: return [7 /*endfinally*/];\n                                            case 14: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    },\n    Projection: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, newScope;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (baseValue.type !== 'object') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        newScope = scope.createNested(baseValue);\n                        return [2 /*return*/, execute(expr, newScope)];\n                }\n            });\n        });\n    },\n    FuncCall: function (_a, scope, execute) {\n        var func = _a.func, args = _a.args;\n        return func(args, scope, execute);\n    },\n    PipeFuncCall: function (_a, scope, execute) {\n        var func = _a.func, base = _a.base, args = _a.args;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        return [2 /*return*/, func(baseValue, args, scope, execute)];\n                }\n            });\n        });\n    },\n    AccessAttribute: function (_a, scope, execute) {\n        var base = _a.base, name = _a.name;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        value = scope.value;\n                        if (!base) return [3 /*break*/, 2];\n                        return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        _b.label = 2;\n                    case 2:\n                        if (value.type === 'object') {\n                            if (value.data.hasOwnProperty(name)) {\n                                return [2 /*return*/, fromJS(value.data[name])];\n                            }\n                        }\n                        return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    AccessElement: function (_a, scope, execute) {\n        var base = _a.base, index = _a.index;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, data, finalIndex;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [4 /*yield*/, baseValue.get()];\n                    case 2:\n                        data = _b.sent();\n                        finalIndex = index < 0 ? index + data.length : index;\n                        return [2 /*return*/, fromJS(data[finalIndex])];\n                }\n            });\n        });\n    },\n    Slice: function (_a, scope, execute) {\n        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, array, leftIdx, rightIdx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [4 /*yield*/, baseValue.get()];\n                    case 2:\n                        array = (_b.sent());\n                        leftIdx = left;\n                        rightIdx = right;\n                        // Handle negative index\n                        if (leftIdx < 0) {\n                            leftIdx = array.length + leftIdx;\n                        }\n                        if (rightIdx < 0) {\n                            rightIdx = array.length + rightIdx;\n                        }\n                        // Convert from inclusive to exclusive index\n                        if (isInclusive) {\n                            rightIdx++;\n                        }\n                        if (leftIdx < 0) {\n                            leftIdx = 0;\n                        }\n                        if (rightIdx < 0) {\n                            rightIdx = 0;\n                        }\n                        // Note: At this point the indices might point out-of-bound, but\n                        // .slice handles this correctly.\n                        return [2 /*return*/, fromJS(array.slice(leftIdx, rightIdx))];\n                }\n            });\n        });\n    },\n    Deref: function (_a, scope, execute) {\n        var e_2, _b;\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value, id, _c, _d, doc, e_2_1;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _e.sent();\n                        if (!scope.source.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        if (value.type !== 'object') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        id = value.data._ref;\n                        if (typeof id !== 'string') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        _e.label = 2;\n                    case 2:\n                        _e.trys.push([2, 7, 8, 13]);\n                        _c = __asyncValues(scope.source);\n                        _e.label = 3;\n                    case 3: return [4 /*yield*/, _c.next()];\n                    case 4:\n                        if (!(_d = _e.sent(), !_d.done)) return [3 /*break*/, 6];\n                        doc = _d.value;\n                        if (doc.type === 'object' && id === doc.data._id) {\n                            return [2 /*return*/, doc];\n                        }\n                        _e.label = 5;\n                    case 5: return [3 /*break*/, 3];\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        e_2_1 = _e.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 13];\n                    case 8:\n                        _e.trys.push([8, , 11, 12]);\n                        if (!(_d && !_d.done && (_b = _c[\"return\"]))) return [3 /*break*/, 10];\n                        return [4 /*yield*/, _b.call(_c)];\n                    case 9:\n                        _e.sent();\n                        _e.label = 10;\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        if (e_2) throw e_2.error;\n                        return [7 /*endfinally*/];\n                    case 12: return [7 /*endfinally*/];\n                    case 13: return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    Value: function (_a) {\n        var value = _a.value;\n        return fromJS(value);\n    },\n    Group: function (_a, scope, execute) {\n        var base = _a.base;\n        return execute(base, scope);\n    },\n    Object: function (_a, scope, execute) {\n        var attributes = _a.attributes;\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _i, attributes_1, attr, attrType, _b, value, _c, _d, cond, value, value;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        result = {};\n                        _i = 0, attributes_1 = attributes;\n                        _e.label = 1;\n                    case 1:\n                        if (!(_i < attributes_1.length)) return [3 /*break*/, 12];\n                        attr = attributes_1[_i];\n                        attrType = attr.type;\n                        _b = attr.type;\n                        switch (_b) {\n                            case 'ObjectAttributeValue': return [3 /*break*/, 2];\n                            case 'ObjectConditionalSplat': return [3 /*break*/, 5];\n                            case 'ObjectSplat': return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 10];\n                    case 2: return [4 /*yield*/, execute(attr.value, scope)];\n                    case 3:\n                        value = _e.sent();\n                        _c = result;\n                        _d = attr.name;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _c[_d] = _e.sent();\n                        return [3 /*break*/, 11];\n                    case 5: return [4 /*yield*/, execute(attr.condition, scope)];\n                    case 6:\n                        cond = _e.sent();\n                        if (cond.type !== 'boolean' || cond.data === false) {\n                            return [3 /*break*/, 11];\n                        }\n                        return [4 /*yield*/, execute(attr.value, scope)];\n                    case 7:\n                        value = _e.sent();\n                        if (value.type === 'object') {\n                            Object.assign(result, value.data);\n                        }\n                        return [3 /*break*/, 11];\n                    case 8: return [4 /*yield*/, execute(attr.value, scope)];\n                    case 9:\n                        value = _e.sent();\n                        if (value.type === 'object') {\n                            Object.assign(result, value.data);\n                        }\n                        return [3 /*break*/, 11];\n                    case 10: throw new Error(\"Unknown node type: \".concat(attrType));\n                    case 11:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 12: return [2 /*return*/, fromJS(result)];\n                }\n            });\n        });\n    },\n    Array: function (_a, scope, execute) {\n        var elements = _a.elements;\n        return new StreamValue(function () {\n            return __asyncGenerator(this, arguments, function () {\n                var _i, elements_1, element, value, value_1, value_1_1, v, e_3_1;\n                var e_3, _a;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _i = 0, elements_1 = elements;\n                            _b.label = 1;\n                        case 1:\n                            if (!(_i < elements_1.length)) return [3 /*break*/, 21];\n                            element = elements_1[_i];\n                            return [4 /*yield*/, __await(execute(element.value, scope))];\n                        case 2:\n                            value = _b.sent();\n                            if (!element.isSplat) return [3 /*break*/, 17];\n                            if (!value.isArray()) return [3 /*break*/, 16];\n                            _b.label = 3;\n                        case 3:\n                            _b.trys.push([3, 10, 11, 16]);\n                            value_1 = (e_3 = void 0, __asyncValues(value));\n                            _b.label = 4;\n                        case 4: return [4 /*yield*/, __await(value_1.next())];\n                        case 5:\n                            if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 9];\n                            v = value_1_1.value;\n                            return [4 /*yield*/, __await(v)];\n                        case 6: return [4 /*yield*/, _b.sent()];\n                        case 7:\n                            _b.sent();\n                            _b.label = 8;\n                        case 8: return [3 /*break*/, 4];\n                        case 9: return [3 /*break*/, 16];\n                        case 10:\n                            e_3_1 = _b.sent();\n                            e_3 = { error: e_3_1 };\n                            return [3 /*break*/, 16];\n                        case 11:\n                            _b.trys.push([11, , 14, 15]);\n                            if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 13];\n                            return [4 /*yield*/, __await(_a.call(value_1))];\n                        case 12:\n                            _b.sent();\n                            _b.label = 13;\n                        case 13: return [3 /*break*/, 15];\n                        case 14:\n                            if (e_3) throw e_3.error;\n                            return [7 /*endfinally*/];\n                        case 15: return [7 /*endfinally*/];\n                        case 16: return [3 /*break*/, 20];\n                        case 17: return [4 /*yield*/, __await(value)];\n                        case 18: return [4 /*yield*/, _b.sent()];\n                        case 19:\n                            _b.sent();\n                            _b.label = 20;\n                        case 20:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 21: return [2 /*return*/];\n                    }\n                });\n            });\n        });\n    },\n    Tuple: function () {\n        throw new Error('tuples can not be evaluated');\n    },\n    Or: function (_a, scope, execute) {\n        var left = _a.left, right = _a.right;\n        return __awaiter(this, void 0, void 0, function () {\n            var leftValue, rightValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(left, scope)];\n                    case 1:\n                        leftValue = _b.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 2:\n                        rightValue = _b.sent();\n                        if (leftValue.type === 'boolean') {\n                            if (leftValue.data === true) {\n                                return [2 /*return*/, TRUE_VALUE];\n                            }\n                        }\n                        if (rightValue.type === 'boolean') {\n                            if (rightValue.data === true) {\n                                return [2 /*return*/, TRUE_VALUE];\n                            }\n                        }\n                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, FALSE_VALUE];\n                }\n            });\n        });\n    },\n    And: function (_a, scope, execute) {\n        var left = _a.left, right = _a.right;\n        return __awaiter(this, void 0, void 0, function () {\n            var leftValue, rightValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(left, scope)];\n                    case 1:\n                        leftValue = _b.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 2:\n                        rightValue = _b.sent();\n                        if (leftValue.type === 'boolean') {\n                            if (leftValue.data === false) {\n                                return [2 /*return*/, FALSE_VALUE];\n                            }\n                        }\n                        if (rightValue.type === 'boolean') {\n                            if (rightValue.data === false) {\n                                return [2 /*return*/, FALSE_VALUE];\n                            }\n                        }\n                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, TRUE_VALUE];\n                }\n            });\n        });\n    },\n    Not: function (_a, scope, execute) {\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (value.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, value.data ? FALSE_VALUE : TRUE_VALUE];\n                }\n            });\n        });\n    },\n    Neg: function (_a, scope, execute) {\n        var base = _a.base;\n        return promiselessApply(execute(base, scope), function (value) {\n            if (value.type !== 'number') {\n                return NULL_VALUE;\n            }\n            return fromNumber(-value.data);\n        });\n    },\n    Pos: function (_a, scope, execute) {\n        var base = _a.base;\n        return promiselessApply(execute(base, scope), function (value) {\n            if (value.type !== 'number') {\n                return NULL_VALUE;\n            }\n            return fromNumber(value.data);\n        });\n    },\n    Asc: function () {\n        return NULL_VALUE;\n    },\n    Desc: function () {\n        return NULL_VALUE;\n    },\n    ArrayCoerce: function (_a, scope, execute) {\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        return [2 /*return*/, value.isArray() ? value : NULL_VALUE];\n                }\n            });\n        });\n    },\n    Map: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (!value.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var value_2, value_2_1, elem, newScope, e_4_1;\n                                    var e_4, _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                _b.trys.push([0, 8, 9, 14]);\n                                                value_2 = __asyncValues(value);\n                                                _b.label = 1;\n                                            case 1: return [4 /*yield*/, __await(value_2.next())];\n                                            case 2:\n                                                if (!(value_2_1 = _b.sent(), !value_2_1.done)) return [3 /*break*/, 7];\n                                                elem = value_2_1.value;\n                                                newScope = scope.createHidden(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3: return [4 /*yield*/, __await.apply(void 0, [_b.sent()])];\n                                            case 4: return [4 /*yield*/, _b.sent()];\n                                            case 5:\n                                                _b.sent();\n                                                _b.label = 6;\n                                            case 6: return [3 /*break*/, 1];\n                                            case 7: return [3 /*break*/, 14];\n                                            case 8:\n                                                e_4_1 = _b.sent();\n                                                e_4 = { error: e_4_1 };\n                                                return [3 /*break*/, 14];\n                                            case 9:\n                                                _b.trys.push([9, , 12, 13]);\n                                                if (!(value_2_1 && !value_2_1.done && (_a = value_2[\"return\"]))) return [3 /*break*/, 11];\n                                                return [4 /*yield*/, __await(_a.call(value_2))];\n                                            case 10:\n                                                _b.sent();\n                                                _b.label = 11;\n                                            case 11: return [3 /*break*/, 13];\n                                            case 12:\n                                                if (e_4) throw e_4.error;\n                                                return [7 /*endfinally*/];\n                                            case 13: return [7 /*endfinally*/];\n                                            case 14: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    },\n    FlatMap: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (!value.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var value_3, value_3_1, elem, newScope, innerValue, innerValue_1, innerValue_1_1, inner, e_5_1, e_6_1;\n                                    var e_6, _a, e_5, _b;\n                                    return __generator(this, function (_c) {\n                                        switch (_c.label) {\n                                            case 0:\n                                                _c.trys.push([0, 23, 24, 29]);\n                                                value_3 = __asyncValues(value);\n                                                _c.label = 1;\n                                            case 1: return [4 /*yield*/, __await(value_3.next())];\n                                            case 2:\n                                                if (!(value_3_1 = _c.sent(), !value_3_1.done)) return [3 /*break*/, 22];\n                                                elem = value_3_1.value;\n                                                newScope = scope.createHidden(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3:\n                                                innerValue = _c.sent();\n                                                if (!innerValue.isArray()) return [3 /*break*/, 18];\n                                                _c.label = 4;\n                                            case 4:\n                                                _c.trys.push([4, 11, 12, 17]);\n                                                innerValue_1 = (e_5 = void 0, __asyncValues(innerValue));\n                                                _c.label = 5;\n                                            case 5: return [4 /*yield*/, __await(innerValue_1.next())];\n                                            case 6:\n                                                if (!(innerValue_1_1 = _c.sent(), !innerValue_1_1.done)) return [3 /*break*/, 10];\n                                                inner = innerValue_1_1.value;\n                                                return [4 /*yield*/, __await(inner)];\n                                            case 7: return [4 /*yield*/, _c.sent()];\n                                            case 8:\n                                                _c.sent();\n                                                _c.label = 9;\n                                            case 9: return [3 /*break*/, 5];\n                                            case 10: return [3 /*break*/, 17];\n                                            case 11:\n                                                e_5_1 = _c.sent();\n                                                e_5 = { error: e_5_1 };\n                                                return [3 /*break*/, 17];\n                                            case 12:\n                                                _c.trys.push([12, , 15, 16]);\n                                                if (!(innerValue_1_1 && !innerValue_1_1.done && (_b = innerValue_1[\"return\"]))) return [3 /*break*/, 14];\n                                                return [4 /*yield*/, __await(_b.call(innerValue_1))];\n                                            case 13:\n                                                _c.sent();\n                                                _c.label = 14;\n                                            case 14: return [3 /*break*/, 16];\n                                            case 15:\n                                                if (e_5) throw e_5.error;\n                                                return [7 /*endfinally*/];\n                                            case 16: return [7 /*endfinally*/];\n                                            case 17: return [3 /*break*/, 21];\n                                            case 18: return [4 /*yield*/, __await(innerValue)];\n                                            case 19: return [4 /*yield*/, _c.sent()];\n                                            case 20:\n                                                _c.sent();\n                                                _c.label = 21;\n                                            case 21: return [3 /*break*/, 1];\n                                            case 22: return [3 /*break*/, 29];\n                                            case 23:\n                                                e_6_1 = _c.sent();\n                                                e_6 = { error: e_6_1 };\n                                                return [3 /*break*/, 29];\n                                            case 24:\n                                                _c.trys.push([24, , 27, 28]);\n                                                if (!(value_3_1 && !value_3_1.done && (_a = value_3[\"return\"]))) return [3 /*break*/, 26];\n                                                return [4 /*yield*/, __await(_a.call(value_3))];\n                                            case 25:\n                                                _c.sent();\n                                                _c.label = 26;\n                                            case 26: return [3 /*break*/, 28];\n                                            case 27:\n                                                if (e_6) throw e_6.error;\n                                                return [7 /*endfinally*/];\n                                            case 28: return [7 /*endfinally*/];\n                                            case 29: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    }\n};\n/**\n * Evaluates a query.\n */\nfunction evaluateQuery(tree, options) {\n    if (options === void 0) { options = {}; }\n    var root = fromJS(options.root);\n    var dataset = fromJS(options.dataset);\n    var params = __assign({}, options.params);\n    var scope = new Scope(params, dataset, root, {\n        timestamp: options.timestamp || new Date(),\n        identity: options.identity === undefined ? 'me' : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null\n    }, null);\n    return evaluate(tree, scope);\n}function canConstantEvaluate(node) {\n    switch (node.type) {\n        case 'Group':\n        case 'Value':\n        case 'Parameter':\n            return true;\n        case 'Pos':\n        case 'Neg':\n            return canConstantEvaluate(node.base);\n        case 'OpCall':\n            switch (node.op) {\n                case '+':\n                case '-':\n                case '*':\n                case '/':\n                case '%':\n                case '**':\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nvar DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: 'me', before: null, after: null }, null);\nfunction tryConstantEvaluate(node) {\n    if (!canConstantEvaluate(node)) {\n        return null;\n    }\n    return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n    var value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if ('then' in value) {\n        throw new Error('BUG: constant evaluate should never return a promise');\n    }\n    return value;\n}var ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    '\\\\': '\\\\',\n    '/': '/',\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n};\nfunction expandHex(str) {\n    var charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nvar GroqQueryError = /** @class */ (function (_super) {\n    __extends(GroqQueryError, _super);\n    function GroqQueryError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.name = 'GroqQueryError';\n        return _this;\n    }\n    return GroqQueryError;\n}(Error));\nvar EXPR_BUILDER = {\n    group: function (p) {\n        var inner = p.process(EXPR_BUILDER);\n        return {\n            type: 'Group',\n            base: inner\n        };\n    },\n    everything: function () {\n        return { type: 'Everything' };\n    },\n    \"this\": function () {\n        return { type: 'This' };\n    },\n    parent: function () {\n        return {\n            type: 'Parent',\n            n: 1\n        };\n    },\n    dblparent: function (p) {\n        var next = p.process(EXPR_BUILDER);\n        return {\n            type: 'Parent',\n            n: next.n + 1\n        };\n    },\n    traverse: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        var traversalList = [];\n        while (p.getMark().name !== 'traversal_end') {\n            traversalList.push(p.process(TRAVERSE_BUILDER));\n        }\n        p.shift();\n        var traversal = null;\n        for (var i = traversalList.length - 1; i >= 0; i--) {\n            traversal = traversalList[i](traversal);\n        }\n        if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n            traversal = traverseArray(function (val) { return val; }, traversal);\n        }\n        if (traversal === null)\n            throw new Error('BUG: unexpected empty traversal');\n        return traversal.build(base);\n    },\n    this_attr: function (p) {\n        var name = p.processString();\n        if (name === 'null') {\n            return { type: 'Value', value: null };\n        }\n        if (name === 'true') {\n            return { type: 'Value', value: true };\n        }\n        if (name === 'false') {\n            return { type: 'Value', value: false };\n        }\n        return {\n            type: 'AccessAttribute',\n            name: name\n        };\n    },\n    neg: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Neg',\n            base: base\n        };\n    },\n    pos: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Pos',\n            base: base\n        };\n    },\n    add: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '+',\n            left: left,\n            right: right\n        };\n    },\n    sub: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '-',\n            left: left,\n            right: right\n        };\n    },\n    mul: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '*',\n            left: left,\n            right: right\n        };\n    },\n    div: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '/',\n            left: left,\n            right: right\n        };\n    },\n    mod: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '%',\n            left: left,\n            right: right\n        };\n    },\n    pow: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '**',\n            left: left,\n            right: right\n        };\n    },\n    comp: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var op = p.processString();\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: op,\n            left: left,\n            right: right\n        };\n    },\n    in_range: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        var isInclusive = p.getMark().name === 'inc_range';\n        p.shift();\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'InRange',\n            base: base,\n            left: left,\n            right: right,\n            isInclusive: isInclusive\n        };\n    },\n    str: function (p) {\n        var value = '';\n        // eslint-disable-next-line no-labels\n        loop: while (p.hasMark()) {\n            var mark = p.getMark();\n            switch (mark.name) {\n                case 'str_end':\n                    value += p.processStringEnd();\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                case 'str_pause':\n                    value += p.processStringEnd();\n                    break;\n                case 'str_start':\n                    p.shift();\n                    break;\n                case 'single_escape': {\n                    var char = p.slice(1);\n                    p.shift();\n                    value += ESCAPE_SEQUENCE[char];\n                    break;\n                }\n                case 'unicode_hex':\n                    p.shift();\n                    value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(\"unexpected mark: \".concat(mark.name));\n            }\n        }\n        return { type: 'Value', value: value };\n    },\n    integer: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    float: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    sci: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    object: function (p) {\n        var attributes = [];\n        while (p.getMark().name !== 'object_end') {\n            attributes.push(p.process(OBJECT_BUILDER));\n        }\n        p.shift();\n        return {\n            type: 'Object',\n            attributes: attributes\n        };\n    },\n    array: function (p) {\n        var elements = [];\n        while (p.getMark().name !== 'array_end') {\n            var isSplat = false;\n            if (p.getMark().name === 'array_splat') {\n                isSplat = true;\n                p.shift();\n            }\n            var value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: 'ArrayElement',\n                value: value,\n                isSplat: isSplat\n            });\n        }\n        p.shift();\n        return {\n            type: 'Array',\n            elements: elements\n        };\n    },\n    tuple: function (p) {\n        var members = [];\n        while (p.getMark().name !== 'tuple_end') {\n            members.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        return {\n            type: 'Tuple',\n            members: members\n        };\n    },\n    func_call: function (p) {\n        var namespace = 'global';\n        if (p.getMark().name === 'namespace') {\n            p.shift();\n            namespace = p.processString();\n        }\n        var name = p.processString();\n        if (namespace === 'global' && name === 'select') {\n            var result = {\n                type: 'Select',\n                alternatives: []\n            };\n            while (p.getMark().name !== 'func_args_end') {\n                if (p.getMark().name === 'pair') {\n                    if (result.fallback)\n                        throw new GroqQueryError(\"unexpected argument to select()\");\n                    p.shift();\n                    var condition = p.process(EXPR_BUILDER);\n                    var value = p.process(EXPR_BUILDER);\n                    result.alternatives.push({\n                        type: 'SelectAlternative',\n                        condition: condition,\n                        value: value\n                    });\n                }\n                else {\n                    if (result.fallback)\n                        throw new GroqQueryError(\"unexpected argument to select()\");\n                    var value = p.process(EXPR_BUILDER);\n                    result.fallback = value;\n                }\n            }\n            p.shift();\n            return result;\n        }\n        var args = [];\n        while (p.getMark().name !== 'func_args_end') {\n            if (argumentShouldBeSelector(namespace, name, args.length)) {\n                // Since the diff/delta functions aren't validated yet we only want to validate the selector\n                // being used. We expect the null valued arg to throw an error at evaluation time.\n                p.process(SELECTOR_BUILDER);\n                args.push({ type: 'Selector' });\n            }\n            else {\n                args.push(p.process(EXPR_BUILDER));\n            }\n        }\n        p.shift();\n        if (namespace === 'global' && (name === 'before' || name === 'after')) {\n            if (p.parseOptions.mode === 'delta') {\n                return {\n                    type: 'Context',\n                    key: name\n                };\n            }\n        }\n        if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n            throw new GroqQueryError('unexpected boost');\n        var funcs = namespaces[namespace];\n        if (!funcs) {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        var func = funcs[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        if (func.arity !== undefined) {\n            validateArity(name, func.arity, args.length);\n        }\n        if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        return {\n            type: 'FuncCall',\n            func: func,\n            name: name,\n            args: args\n        };\n    },\n    pipecall: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        p.shift(); // Remove the func_call\n        var namespace = 'global';\n        if (p.getMark().name === 'namespace') {\n            p.shift();\n            namespace = p.processString();\n        }\n        if (namespace !== 'global') {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        var name = p.processString();\n        var args = [];\n        var oldAllowBoost = p.allowBoost;\n        if (name === 'score') {\n            // Only allow boost inside a score expression\n            p.allowBoost = true;\n        }\n        for (;;) {\n            var markName = p.getMark().name;\n            if (markName === 'func_args_end') {\n                break;\n            }\n            if (name === 'order') {\n                if (markName === 'asc') {\n                    p.shift();\n                    args.push({ type: 'Asc', base: p.process(EXPR_BUILDER) });\n                    continue;\n                }\n                else if (markName === 'desc') {\n                    p.shift();\n                    args.push({ type: 'Desc', base: p.process(EXPR_BUILDER) });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        p.allowBoost = oldAllowBoost;\n        var func = pipeFunctions[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n        }\n        if (func.arity) {\n            validateArity(name, func.arity, args.length);\n        }\n        return {\n            type: 'PipeFuncCall',\n            func: func,\n            base: base,\n            name: name,\n            args: args\n        };\n    },\n    pair: function (p) {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'And',\n            left: left,\n            right: right\n        };\n    },\n    or: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'Or',\n            left: left,\n            right: right\n        };\n    },\n    not: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Not',\n            base: base\n        };\n    },\n    asc: function (p) {\n        throw new GroqQueryError('unexpected asc');\n    },\n    desc: function (p) {\n        throw new GroqQueryError('unexpected desc');\n    },\n    param: function (p) {\n        var name = p.processString();\n        if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n            return {\n                type: 'Value',\n                value: p.parseOptions.params[name]\n            };\n        }\n        return {\n            type: 'Parameter',\n            name: name\n        };\n    }\n};\nvar OBJECT_BUILDER = {\n    object_expr: function (p) {\n        if (p.getMark().name === 'pair') {\n            p.shift();\n            var condition = p.process(EXPR_BUILDER);\n            var value_1 = p.process(EXPR_BUILDER);\n            return {\n                type: 'ObjectConditionalSplat',\n                condition: condition,\n                value: value_1\n            };\n        }\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectAttributeValue',\n            name: extractPropertyKey(value),\n            value: value\n        };\n    },\n    object_pair: function (p) {\n        var name = p.process(EXPR_BUILDER);\n        if (name.type !== 'Value')\n            throw new Error('name must be string');\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectAttributeValue',\n            name: name.value,\n            value: value\n        };\n    },\n    object_splat: function (p) {\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectSplat',\n            value: value\n        };\n    },\n    object_splat_this: function () {\n        return {\n            type: 'ObjectSplat',\n            value: { type: 'This' }\n        };\n    }\n};\nvar TRAVERSE_BUILDER = {\n    square_bracket: function (p) {\n        var expr = p.process(EXPR_BUILDER);\n        var value = tryConstantEvaluate(expr);\n        if (value && value.type === 'number') {\n            return function (right) {\n                return traverseElement(function (base) { return ({ type: 'AccessElement', base: base, index: value.data }); }, right);\n            };\n        }\n        if (value && value.type === 'string') {\n            return function (right) {\n                return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: value.data }); }, right);\n            };\n        }\n        return function (right) {\n            return traverseArray(function (base) { return ({\n                type: 'Filter',\n                base: base,\n                expr: expr\n            }); }, right);\n        };\n    },\n    slice: function (p) {\n        var isInclusive = p.getMark().name === 'inc_range';\n        p.shift();\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        var leftValue = tryConstantEvaluate(left);\n        var rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n            throw new GroqQueryError('slicing must use constant numbers');\n        }\n        return function (rhs) {\n            return traverseArray(function (base) { return ({\n                type: 'Slice',\n                base: base,\n                left: leftValue.data,\n                right: rightValue.data,\n                isInclusive: isInclusive\n            }); }, rhs);\n        };\n    },\n    projection: function (p) {\n        var obj = p.process(EXPR_BUILDER);\n        return function (right) {\n            return traverseProjection(function (base) { return ({ type: 'Projection', base: base, expr: obj }); }, right);\n        };\n    },\n    attr_access: function (p) {\n        var name = p.processString();\n        return function (right) { return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: name }); }, right); };\n    },\n    deref: function (p) {\n        var attr = null;\n        if (p.getMark().name === 'deref_attr') {\n            p.shift();\n            attr = p.processString();\n        }\n        var wrap = function (base) {\n            return attr ? { type: 'AccessAttribute', base: base, name: attr } : base;\n        };\n        return function (right) {\n            return traversePlain(function (base) {\n                return wrap({\n                    type: 'Deref',\n                    base: base\n                });\n            }, right);\n        };\n    },\n    array_postfix: function (p) {\n        return function (right) { return traverseArray(function (base) { return ({ type: 'ArrayCoerce', base: base }); }, right); };\n    }\n};\nvar SELECTOR_BUILDER = {\n    group: function (p) {\n        p.process(SELECTOR_BUILDER);\n        return null;\n    },\n    everything: function () {\n        throw new Error('Invalid selector syntax');\n    },\n    \"this\": function () {\n        throw new Error('Invalid selector syntax');\n    },\n    parent: function () {\n        throw new Error('Invalid selector syntax');\n    },\n    dblparent: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    traverse: function (p) {\n        p.process(SELECTOR_BUILDER);\n        while (p.getMark().name !== 'traversal_end') {\n            p.process(TRAVERSE_BUILDER);\n        }\n        p.shift();\n        return null;\n    },\n    this_attr: function (p) {\n        p.processString();\n        return null;\n    },\n    neg: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pos: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    add: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    sub: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    mul: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    div: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    mod: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pow: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    comp: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    in_range: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    str: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    integer: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    float: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    sci: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    object: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    array: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    tuple: function (p) {\n        // This should only throw an error until we add support for tuples in selectors.\n        throw new Error('Invalid selector syntax');\n    },\n    func_call: function (p, mark) {\n        var func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === 'anywhere' && func.args.length === 1)\n            return null;\n        throw new Error('Invalid selector syntax');\n    },\n    pipecall: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pair: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    and: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    or: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    not: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    asc: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    desc: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    param: function (p) {\n        throw new Error('Invalid selector syntax');\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === 'AccessAttribute' && !node.base) {\n        return node.name;\n    }\n    if (node.type === 'Deref' ||\n        node.type === 'Map' ||\n        node.type === 'Projection' ||\n        node.type === 'Slice' ||\n        node.type === 'Filter' ||\n        node.type === 'AccessElement' ||\n        node.type === 'ArrayCoerce') {\n        return extractPropertyKey(node.base);\n    }\n    throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity === 'number') {\n        if (count !== arity) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\"));\n        }\n    }\n    else if (arity) {\n        if (!arity(count)) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n        }\n    }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    var functionsRequiringSelectors = ['changedAny', 'changedOnly'];\n    return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nvar GroqSyntaxError = /** @class */ (function (_super) {\n    __extends(GroqSyntaxError, _super);\n    function GroqSyntaxError(position) {\n        var _this = _super.call(this, \"Syntax error in GROQ query at position \".concat(position)) || this;\n        _this.name = 'GroqSyntaxError';\n        _this.position = position;\n        return _this;\n    }\n    return GroqSyntaxError;\n}(Error));\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nfunction parse(input, options) {\n    if (options === void 0) { options = {}; }\n    var result = parse$1(input);\n    if (result.type === 'error') {\n        throw new GroqSyntaxError(result.position);\n    }\n    var processor = new MarkProcessor(input, result.marks, options);\n    return processor.process(EXPR_BUILDER);\n}exports.evaluate=evaluateQuery;exports.parse=parse;Object.defineProperty(exports,'__esModule',{value:true});}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEudW1kLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQXNELFlBQVksQ0FBZ0ksRUFBRSwwQkFBMEIsYUFBYTtBQUMxUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUZBQXVGLGNBQWM7QUFDdEgsdUJBQXVCLGdDQUFnQyxxQ0FBcUMsMkNBQTJDO0FBQ3ZJLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEgsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUkseUJBQXlCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxJQUFJLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlDQUFpQyxHQUFHO0FBQ3JDLDhDQUE4QyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5QkFBeUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQixzQ0FBc0Msd0JBQXdCLE9BQU87QUFDdkk7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtGQUErRjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNDQUFzQztBQUM3RztBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHdFQUF3RSxjQUFjO0FBQ3RGO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQixvQkFBb0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNkJBQTZCO0FBQy9FO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRCxRQUFRO0FBQ1IsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxXQUFXLHNDQUFzQztBQUNqRCxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFdBQVcsbUNBQW1DO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0NBQXNDO0FBQ3JELGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsaUNBQWlDO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQWlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQsd0JBQXdCLCtCQUErQixHQUFHLHVDQUF1QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RCxvQkFBb0IsK0JBQStCLEdBQUcsa0NBQWtDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQkFBK0I7QUFDeEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hELG9CQUFvQiwrQkFBK0IsR0FBRyx1Q0FBdUM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIscUNBQXFDO0FBQ2xFLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw2QkFBNkIsaUNBQWlDO0FBQzlELDBCQUEwQiwrQkFBK0IsR0FBRyx1Q0FBdUM7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQsd0JBQXdCLCtCQUErQixHQUFHLHVDQUF1QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0NBQXdDO0FBQ25ELFdBQVcsb0NBQW9DO0FBQy9DLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUEsb0JBQW9CLGtDQUFrQztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0MsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsaUJBQWlCLDJDQUEyQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw4QkFBOEIsdUNBQXVDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNDQUFzQzs7QUFFcEQ7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3RELGdCQUFnQixrQ0FBa0MsR0FBRyxpQ0FBaUM7QUFDdEY7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixnQkFBZ0IsNkJBQTZCLEdBQUcsMkNBQTJDO0FBQzNGO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsSUFBSTtBQUNKLGdCQUFnQixrQ0FBa0MsR0FBRyxpQ0FBaUM7QUFDdEY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGNBQWMseUNBQXlDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDOztBQUVBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIsWUFBWTtBQUNaOztBQUVBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0MsZ0JBQWdCO0FBQ2hCLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JEO0FBQ0EsaUNBQWlDO0FBQ2pDLHdCQUF3Qix1Q0FBdUM7QUFDL0QsZ0NBQWdDO0FBQ2hDLHdCQUF3Qix1Q0FBdUM7QUFDL0QsWUFBWTtBQUNaLHdCQUF3Qix1Q0FBdUM7QUFDL0Qsd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNCQUFzQix5Q0FBeUM7QUFDL0Q7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSx1Q0FBdUMsY0FBYyxHQUFHO0FBQy9GO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSwyQ0FBMkMsY0FBYyxHQUFHO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQ0FBMkMsZUFBZTtBQUMxRCwyQ0FBMkMsZUFBZTtBQUMxRCwyQ0FBMkMsZUFBZTtBQUMxRCw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQXNELFlBQVk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJLElBQUk7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEIsbUVBQW1FO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBNEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVSxzREFBc0QsSUFBSTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxVQUFVLHVEQUF1RCxJQUFJO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVLDJDQUEyQyxJQUFJO0FBQ2pIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0MsdUNBQXVDLFVBQVUsaURBQWlELElBQUk7QUFDeEksS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtEQUFrRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLHVDQUF1QyxVQUFVLGlDQUFpQyxJQUFJO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQixvQkFBb0IsNENBQTRDLFdBQVcsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEudW1kLmNqcz9kN2FhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihnLGYpe3R5cGVvZiBleHBvcnRzPT09J29iamVjdCcmJnR5cGVvZiBtb2R1bGUhPT0ndW5kZWZpbmVkJz9mKGV4cG9ydHMpOnR5cGVvZiBkZWZpbmU9PT0nZnVuY3Rpb24nJiZkZWZpbmUuYW1kP2RlZmluZShbJ2V4cG9ydHMnXSxmKTooZz10eXBlb2YgZ2xvYmFsVGhpcyE9PSd1bmRlZmluZWQnP2dsb2JhbFRoaXM6Z3x8c2VsZixmKGdbXCIxXCJdPXt9KSk7fSkodGhpcywoZnVuY3Rpb24oZXhwb3J0cyl7J3VzZSBzdHJpY3QnOy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufXZhciBNYXJrUHJvY2Vzc29yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcmtQcm9jZXNzb3Ioc3RyaW5nLCBtYXJrcywgcGFyc2VPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYWxsb3dCb29zdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XG4gICAgfVxuICAgIE1hcmtQcm9jZXNzb3IucHJvdG90eXBlLmhhc01hcmsgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT09IHZvaWQgMCkgeyBwb3MgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ICsgcG9zIDwgdGhpcy5tYXJrcy5sZW5ndGg7XG4gICAgfTtcbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5nZXRNYXJrID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICBpZiAocG9zID09PSB2b2lkIDApIHsgcG9zID0gMDsgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrc1t0aGlzLmluZGV4ICsgcG9zXTtcbiAgICB9O1xuICAgIE1hcmtQcm9jZXNzb3IucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluZGV4ICs9IDE7XG4gICAgfTtcbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgdmFyIG1hcmsgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgICAgICB0aGlzLnNoaWZ0KCk7XG4gICAgICAgIHZhciBmdW5jID0gdmlzaXRvclttYXJrLm5hbWVdO1xuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gaGFuZGxlcjogXCIuY29uY2F0KG1hcmsubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodmlzaXRvciwgdGhpcywgbWFyayk7XG4gICAgfTtcbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICB9O1xuICAgIE1hcmtQcm9jZXNzb3IucHJvdG90eXBlLnByb2Nlc3NTdHJpbmdFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4IC0gMV07XG4gICAgICAgIHZhciBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICAgICAgdGhpcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocHJldi5wb3NpdGlvbiwgY3Vyci5wb3NpdGlvbik7XG4gICAgfTtcbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShwb3MsIHBvcyArIGxlbik7XG4gICAgfTtcbiAgICByZXR1cm4gTWFya1Byb2Nlc3Nvcjtcbn0oKSk7dmFyIFJGQzMzMzlfUkVHRVggPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZCspPyhafChbLStdXFxkezJ9OlxcZHsyfSkpJC87XG5mdW5jdGlvbiBwYXJzZVJGQzMzMzkoc3RyKSB7XG4gICAgaWYgKFJGQzMzMzlfUkVHRVgudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJGQzMzMzkoZCkge1xuICAgIHZhciB5ZWFyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENGdWxsWWVhcigpLCA0KTtcbiAgICB2YXIgbW9udGggPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01vbnRoKCkgKyAxLCAyKTtcbiAgICB2YXIgZGF5ID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENEYXRlKCksIDIpO1xuICAgIHZhciBob3VyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENIb3VycygpLCAyKTtcbiAgICB2YXIgbWludXRlID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNaW51dGVzKCksIDIpO1xuICAgIHZhciBzZWNvbmQgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ1NlY29uZHMoKSwgMik7XG4gICAgdmFyIGZyYWN0aW9uYWxTZWNvbmQgPSAnJztcbiAgICB2YXIgbWlsbGlzID0gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICBpZiAobWlsbGlzICE9IDApIHtcbiAgICAgICAgZnJhY3Rpb25hbFNlY29uZCA9IFwiLlwiLmNvbmNhdChhZGRMZWFkaW5nWmVybyhtaWxsaXMsIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHllYXIsIFwiLVwiKS5jb25jYXQobW9udGgsIFwiLVwiKS5jb25jYXQoZGF5LCBcIlRcIikuY29uY2F0KGhvdXIsIFwiOlwiKS5jb25jYXQobWludXRlLCBcIjpcIikuY29uY2F0KHNlY29uZCkuY29uY2F0KGZyYWN0aW9uYWxTZWNvbmQsIFwiWlwiKTtcbn1cbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvKG51bSwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgIHN0ciA9IFwiMFwiLmNvbmNhdChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufWZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59XG5mdW5jdGlvbiBwYXRoUmVnRXhwKHBhdHRlcm4pIHtcbiAgICB2YXIgcmUgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcGF0dGVybi5zcGxpdCgnLicpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcGFydCA9IF9hW19pXTtcbiAgICAgICAgaWYgKHBhcnQgPT09ICcqJykge1xuICAgICAgICAgICAgcmUucHVzaCgnW14uXSsnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0ID09PSAnKionKSB7XG4gICAgICAgICAgICByZS5wdXNoKCcuKicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmUucHVzaChlc2NhcGVSZWdFeHAocGFydCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChyZS5qb2luKCcuJyksIFwiJFwiKSk7XG59XG52YXIgUGF0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXRoKHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5wYXR0ZXJuUmUgPSBwYXRoUmVnRXhwKHBhdHRlcm4pO1xuICAgIH1cbiAgICBQYXRoLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXR0ZXJuUmUudGVzdChzdHIpO1xuICAgIH07XG4gICAgUGF0aC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGg7XG59KCkpO3ZhciBTdHJlYW1WYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJlYW1WYWx1ZShnZW5lcmF0b3IpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0cmVhbSc7XG4gICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICB0aGlzLnRpY2tlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIFN0cmVhbVZhbHVlLnByb3RvdHlwZS5pc0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0cmVhbVZhbHVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBfYiwgX2MsIHZhbHVlLCBfZCwgX2UsIGVfMV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLnRyeXMucHVzaChbMSwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gX19hc3luY1ZhbHVlcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfYyA9IF9mLnNlbnQoKSwgIV9jLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZSA9IChfZCA9IHJlc3VsdCkucHVzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2UuYXBwbHkoX2QsIFtfZi5zZW50KCldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2YudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2JbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChfYildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdHJlYW1WYWx1ZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIF9hKCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgdGhpcy5kYXRhLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh0aGlzLmRhdGFbaV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEb25lKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodm9pZCAwKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh0aGlzLl9uZXh0VGljaygpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RyZWFtVmFsdWUucHJvdG90eXBlLl9uZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudGlja2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRSZXNvbHZlcjtcbiAgICAgICAgdmFyIHNldHVwVGlja2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudGlja2VyID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3VycmVudFJlc29sdmVyKCk7XG4gICAgICAgICAgICBzZXR1cFRpY2tlcigpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZmV0Y2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCB2YWx1ZSwgZV8yXzE7XG4gICAgICAgICAgICB2YXIgZV8yLCBfYztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLnRyeXMucHVzaChbMCwgNSwgNiwgMTFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX19hc3luY1ZhbHVlcyh0aGlzLmdlbmVyYXRvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfYiA9IF9kLnNlbnQoKSwgIV9iLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzJfMSA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLnRyeXMucHVzaChbNiwgLCA5LCAxMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2IgJiYgIV9iLmRvbmUgJiYgKF9jID0gX2FbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5jYWxsKF9hKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gODtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9O1xuICAgICAgICBzZXR1cFRpY2tlcigpO1xuICAgICAgICBmZXRjaCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgfTtcbiAgICByZXR1cm4gU3RyZWFtVmFsdWU7XG59KCkpO3ZhciBTdGF0aWNWYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNWYWx1ZShkYXRhLCB0eXBlKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIFN0YXRpY1ZhbHVlLnByb3RvdHlwZS5pc0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnYXJyYXknO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgICBTdGF0aWNWYWx1ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZGF0YV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdGF0aWNWYWx1ZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pLCBkYXRhXzEsIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBkYXRhXzEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGRhdGFfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZGF0YV8xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmcm9tSlMoZWxlbWVudCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpdGVyYXRlIG92ZXI6IFwiLmNvbmNhdCh0aGlzLnR5cGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNWYWx1ZTtcbn0oKSk7XG52YXIgTlVMTF9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShudWxsLCAnbnVsbCcpO1xudmFyIFRSVUVfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUodHJ1ZSwgJ2Jvb2xlYW4nKTtcbnZhciBGQUxTRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShmYWxzZSwgJ2Jvb2xlYW4nKTtcbnZhciBEYXRlVGltZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRlVGltZShkYXRlKSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IGRhdGU7XG4gICAgfVxuICAgIERhdGVUaW1lLnBhcnNlVG9WYWx1ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBwYXJzZVJGQzMzMzkoc3RyKTtcbiAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUobmV3IERhdGVUaW1lKGRhdGUpLCAnZGF0ZXRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9O1xuICAgIERhdGVUaW1lLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgPT0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHNlY3MpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgRGF0ZSh0aGlzLmRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgY29weS5zZXRUaW1lKGNvcHkuZ2V0VGltZSgpICsgc2VjcyAqIDEwMDApO1xuICAgICAgICByZXR1cm4gbmV3IERhdGVUaW1lKGNvcHkpO1xuICAgIH07XG4gICAgRGF0ZVRpbWUucHJvdG90eXBlLmRpZmZlcmVuY2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICB9O1xuICAgIERhdGVUaW1lLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgLSBvdGhlci5kYXRlLmdldFRpbWUoKTtcbiAgICB9O1xuICAgIERhdGVUaW1lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFJGQzMzMzkodGhpcy5kYXRlKTtcbiAgICB9O1xuICAgIERhdGVUaW1lLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZVRpbWU7XG59KCkpO1xuZnVuY3Rpb24gZnJvbU51bWJlcihudW0pIHtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShudW0sICdudW1iZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG59XG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCAnc3RyaW5nJyk7XG59XG5mdW5jdGlvbiBmcm9tRGF0ZVRpbWUoZHQpIHtcbiAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCAnZGF0ZXRpbWUnKTtcbn1cbmZ1bmN0aW9uIGZyb21QYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgsICdwYXRoJyk7XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5uZXh0ID09PSAnZnVuY3Rpb24nO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcbiAgICBpZiAoaXNJdGVyYXRvcih2YWwpKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbF8xLCB2YWxfMV8xLCB2YWx1ZSwgZV8xXzE7XG4gICAgICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbF8xID0gX19hc3luY1ZhbHVlcyh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2YWxfMS5uZXh0KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWxfMV8xID0gX2Iuc2VudCgpLCAhdmFsXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWxfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoZnJvbUpTKHZhbHVlKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbF8xXzEgJiYgIXZhbF8xXzEuZG9uZSAmJiAoX2EgPSB2YWxfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYS5jYWxsKHZhbF8xKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHZhbCwgZ2V0VHlwZSh2YWwpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBnZXRUeXBlKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgUGF0aCkge1xuICAgICAgICByZXR1cm4gJ3BhdGgnO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZXRpbWUnO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGRhdGE7XG59dmFyIFRZUEVfT1JERVIgPSB7XG4gICAgZGF0ZXRpbWU6IDEsXG4gICAgbnVtYmVyOiAyLFxuICAgIHN0cmluZzogMyxcbiAgICBib29sZWFuOiA0XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIHBhcnRpYWxDb21wYXJlKGEsIGIpIHtcbiAgICB2YXIgYVR5cGUgPSBnZXRUeXBlKGEpO1xuICAgIHZhciBiVHlwZSA9IGdldFR5cGUoYik7XG4gICAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoIChhVHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGlmIChhIDwgYilcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAoYSA+IGIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICAgICAgcmV0dXJuIGEuY29tcGFyZVRvKGIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIHRvdGFsQ29tcGFyZShhLCBiKSB7XG4gICAgdmFyIGFUeXBlID0gZ2V0VHlwZShhKTtcbiAgICB2YXIgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICAgIHZhciBhVHlwZU9yZGVyID0gVFlQRV9PUkRFUlthVHlwZV0gfHwgMTAwO1xuICAgIHZhciBiVHlwZU9yZGVyID0gVFlQRV9PUkRFUltiVHlwZV0gfHwgMTAwO1xuICAgIGlmIChhVHlwZU9yZGVyICE9PSBiVHlwZU9yZGVyKSB7XG4gICAgICAgIHJldHVybiBhVHlwZU9yZGVyIC0gYlR5cGVPcmRlcjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGEsIGIpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn12YXIgQ0hBUlMgPSAvKFteIUAjJCVeJiooKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbnZhciBDSEFSU19XSVRIX1dJTERDQVJEID0gLyhbXiFAIyQlXiYoKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbnZhciBFREdFX0NIQVJTID0gLyhcXGJcXC4rfFxcLitcXGIpL2c7XG52YXIgTUFYX1RFUk1fTEVOR1RIID0gMTAyNDtcbmZ1bmN0aW9uIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgcGF0dGVybnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm5zLmV2ZXJ5KGZ1bmN0aW9uIChwYXR0ZXJuKSB7IHJldHVybiBwYXR0ZXJuKHRva2Vucyk7IH0pO1xufVxuZnVuY3Rpb24gbWF0Y2hUb2tlbml6ZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZShFREdFX0NIQVJTLCAnJykubWF0Y2goQ0hBUlMpIHx8IFtdO1xufVxuZnVuY3Rpb24gbWF0Y2hBbmFseXplUGF0dGVybih0ZXh0KSB7XG4gICAgdmFyIHRlcm1zUmUgPSBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KTtcbiAgICByZXR1cm4gdGVybXNSZS5tYXAoZnVuY3Rpb24gKHJlKSB7IHJldHVybiBmdW5jdGlvbiAodG9rZW5zKSB7IHJldHVybiB0b2tlbnMuc29tZShmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHJlLnRlc3QodG9rZW4pOyB9KTsgfTsgfSk7XG59XG5mdW5jdGlvbiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KSB7XG4gICAgdmFyIHRlcm1zID0gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsICcnKS5tYXRjaChDSEFSU19XSVRIX1dJTERDQVJEKSB8fCBbXTtcbiAgICByZXR1cm4gdGVybXMubWFwKGZ1bmN0aW9uICh0ZXJtKSB7IHJldHVybiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdCh0ZXJtLnNsaWNlKDAsIE1BWF9URVJNX0xFTkdUSCkucmVwbGFjZSgvXFwqL2csICcuKicpLCBcIiRcIiksICdpJyk7IH0pO1xufVxuZnVuY3Rpb24gZ2F0aGVyVGV4dCh2YWx1ZSwgY2IpIHtcbiAgICB2YXIgdmFsdWVfMSwgdmFsdWVfMV8xO1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1Y2Nlc3MsIHBhcnQsIGVfMV8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDYsIDcsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXzEgPSBfX2FzeW5jVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsdWVfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMV8xID0gX2Iuc2VudCgpLCAhdmFsdWVfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IHZhbHVlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHBhcnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs3LCAsIDEwLCAxMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8xXzEgJiYgIXZhbHVlXzFfMS5kb25lICYmIChfYSA9IHZhbHVlXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwodmFsdWVfMSldO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHN1Y2Nlc3NdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufS8vIEJNMjUgc2ltaWxhcml0eSBjb25zdGFudHNcbnZhciBCTTI1ayA9IDEuMjtcbmZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lclNjb3JlLCBib29zdCwgX2EsIGxlZnRTY29yZSwgcmlnaHRTY29yZSwgbGVmdFNjb3JlLCByaWdodFNjb3JlLCByZXM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdPcENhbGwnICYmIG5vZGUub3AgPT09ICdtYXRjaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBldmFsdWF0ZU1hdGNoU2NvcmUobm9kZS5sZWZ0LCBub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG5vZGUudHlwZSA9PT0gJ0Z1bmNDYWxsJyAmJiBub2RlLm5hbWUgPT09ICdib29zdCcpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXZhbHVhdGVTY29yZShub2RlLmFyZ3NbMF0sIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpbm5lclNjb3JlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKG5vZGUuYXJnc1sxXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGJvb3N0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9vc3QudHlwZSA9PT0gJ251bWJlcicgJiYgaW5uZXJTY29yZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBpbm5lclNjb3JlICsgYm9vc3QuZGF0YV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIDBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBub2RlLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ09yJzogcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdBbmQnOiByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGxlZnRTY29yZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRTY29yZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxlZnRTY29yZSArIHJpZ2h0U2NvcmVdO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFs0IC8qeWllbGQqLywgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBsZWZ0U2NvcmUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0U2NvcmUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxlZnRTY29yZSArIHJpZ2h0U2NvcmVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUobm9kZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICByZXMgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXMudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIHJlcy5kYXRhID09PSB0cnVlID8gMSA6IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlTWF0Y2hTY29yZShsZWZ0LCByaWdodCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0LCBwYXR0ZXJuLCB0b2tlbnMsIHRlcm1zLCBkaWRTdWNjZWVkLCBzY29yZSwgX2xvb3BfMSwgX2ksIHRlcm1zXzEsIHJlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGxlZnQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKHJpZ2h0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRlcm1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdhdGhlclRleHQodGV4dCwgZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnYXRoZXJUZXh0KHBhdHRlcm4sIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybXMgPSB0ZXJtcy5jb25jYXQobWF0Y2hQYXR0ZXJuUmVnZXgocGFydCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgZGlkU3VjY2VlZCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xID0gZnVuY3Rpb24gKHJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJlcSA9IHRva2Vucy5yZWR1Y2UoZnVuY3Rpb24gKGMsIHRva2VuKSB7IHJldHVybiBjICsgKHJlLnRlc3QodG9rZW4pID8gMSA6IDApOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlICs9IChmcmVxICogKEJNMjVrICsgMSkpIC8gKGZyZXEgKyBCTTI1ayk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCB0ZXJtc18xID0gdGVybXM7IF9pIDwgdGVybXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlID0gdGVybXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKHJlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgc2NvcmVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1mdW5jdGlvbiBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGV4dHM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlLnR5cGUgPT09ICdvYmplY3QnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBibG9ja1RleHQodmFsdWUuZGF0YSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBhcnJheVRleHQodmFsdWUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRleHRzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRleHRzLmpvaW4oJ1xcblxcbicpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYXJyYXlUZXh0KHZhbHVlLCByZXN1bHQpIHtcbiAgICB2YXIgdmFsdWVfMSwgdmFsdWVfMV8xO1xuICAgIHZhciBlXzEsIF9hO1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSBbXTsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJsb2NrLCB0ZXh0LCBlXzFfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZV8xID0gX19hc3luY1ZhbHVlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlXzEubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzFfMSA9IF9iLnNlbnQoKSwgIXZhbHVlXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrID0gdmFsdWVfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShibG9jay50eXBlID09PSAnb2JqZWN0JykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gYmxvY2tUZXh0KGJsb2NrLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmxvY2suaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYXJyYXlUZXh0KGJsb2NrLCByZXN1bHQpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8xXzEgJiYgIXZhbHVlXzFfMS5kb25lICYmIChfYSA9IHZhbHVlXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKHZhbHVlXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYmxvY2tUZXh0KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIGNoaWxkcmVuID0gb2JqLmNoaWxkcmVuO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNoaWxkcmVuXzEgPSBjaGlsZHJlbjsgX2kgPCBjaGlsZHJlbl8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbl8xW19pXTtcbiAgICAgICAgaWYgKGNoaWxkICYmXG4gICAgICAgICAgICB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgY2hpbGQuX3R5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBjaGlsZC5fdHlwZSA9PT0gJ3NwYW4nICYmXG4gICAgICAgICAgICB0eXBlb2YgY2hpbGQudGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGlsZC50ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59ZnVuY3Rpb24gaGFzUmVmZXJlbmNlKHZhbHVlLCBwYXRoU2V0KSB7XG4gICAgc3dpdGNoIChnZXRUeXBlKHZhbHVlKSkge1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHZhbHVlXzEgPSB2YWx1ZTsgX2kgPCB2YWx1ZV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdmFsdWVfMVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICh2YWx1ZS5fcmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhTZXQuaGFzKHZhbHVlLl9yZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IE9iamVjdC52YWx1ZXModmFsdWUpOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gX2JbX2FdO1xuICAgICAgICAgICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvdW50VVRGOChzdHIpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gSGlnaCBzdXJyb2dhdGUuIERvbid0IGNvdW50IHRoaXMuXG4gICAgICAgICAgICAvLyBCeSBvbmx5IGNvdW50aW5nIHRoZSBsb3cgc3Vycm9nYXRlIHdlIHdpbGwgY29ycmVjdGx5XG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIFVURi04IGNvZGUgcG9pbnRzLlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxudmFyIGdsb2JhbCA9IHt9O1xuZ2xvYmFsLmFueXdoZXJlID0gZnVuY3Rpb24gYW55d2hlcmUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuYW55d2hlcmUuYXJpdHkgPSAxO1xuZ2xvYmFsLmNvYWxlc2NlID0gZnVuY3Rpb24gY29hbGVzY2UoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfaSwgYXJnc18xLCBhcmcsIHZhbHVlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIGFyZ3NfMSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgYXJnc18xLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZywgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuY291bnQgPSBmdW5jdGlvbiBjb3VudChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyLCBudW0sIGlubmVyXzEsIGlubmVyXzFfMSwgZV8xXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlubmVyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlubmVyLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG51bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMiwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJfMSA9IF9fYXN5bmNWYWx1ZXMoaW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBpbm5lcl8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpbm5lcl8xXzEgPSBfYi5zZW50KCksICFpbm5lcl8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBpbm5lcl8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG51bSsrO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGlubmVyXzFfMSAmJiAhaW5uZXJfMV8xLmRvbmUgJiYgKF9hID0gaW5uZXJfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwoaW5uZXJfMSldO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbU51bWJlcihudW0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmNvdW50LmFyaXR5ID0gMTtcbmdsb2JhbC5kYXRlVGltZSA9IGZ1bmN0aW9uIGRhdGVUaW1lKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBEYXRlVGltZS5wYXJzZVRvVmFsdWUodmFsLmRhdGEpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmRhdGVUaW1lLmFyaXR5ID0gMTtcbmdsb2JhbC5kZWZpbmVkID0gZnVuY3Rpb24gZGVmaW5lZChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGlubmVyLnR5cGUgPT09ICdudWxsJyA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5kZWZpbmVkLmFyaXR5ID0gMTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG5nbG9iYWwuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eShhcmdzLCBzY29wZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuaWRlbnRpdHkuYXJpdHkgPSAwO1xuZ2xvYmFsLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBlXzIsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyLCBudW0sIGlubmVyXzIsIGlubmVyXzJfMSwgZV8yXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlubmVyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5uZXIuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgIG51bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMiwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJfMiA9IF9fYXN5bmNWYWx1ZXMoaW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBpbm5lcl8yLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpbm5lcl8yXzEgPSBfYi5zZW50KCksICFpbm5lcl8yXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBpbm5lcl8yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG51bSsrO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGVfMl8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGlubmVyXzJfMSAmJiAhaW5uZXJfMl8xLmRvbmUgJiYgKF9hID0gaW5uZXJfMltcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwoaW5uZXJfMildO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbU51bWJlcihudW0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5sZW5ndGguYXJpdHkgPSAxO1xuZ2xvYmFsLnBhdGggPSBmdW5jdGlvbiBwYXRoKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlubmVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVBhdGgobmV3IFBhdGgoaW5uZXIuZGF0YSkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLnBhdGguYXJpdHkgPSAxO1xuZ2xvYmFsLnN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKFwiXCIuY29uY2F0KHZhbHVlLmRhdGEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5zdHJpbmcuYXJpdHkgPSAxO1xuZ2xvYmFsLnJlZmVyZW5jZXMgPSBmdW5jdGlvbiByZWZlcmVuY2VzKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgdmFyIGVfMywgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aFNldCwgX2ksIGFyZ3NfMiwgYXJnLCBwYXRoLCBwYXRoXzEsIHBhdGhfMV8xLCBlbGVtLCBlXzNfMSwgc2NvcGVWYWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcGF0aFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBhcmdzXzIgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGFyZ3NfMi5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NfMltfaV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGF0aC50eXBlID09PSAnc3RyaW5nJykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICBwYXRoU2V0LmFkZChwYXRoLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdGguaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbNCwgOSwgMTAsIDE1XSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhfMSA9IChlXzMgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMocGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQgLyp5aWVsZCovLCBwYXRoXzEubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhdGhfMV8xID0gX2Iuc2VudCgpLCAhcGF0aF8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtID0gcGF0aF8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoU2V0LmFkZChlbGVtLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNztcbiAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgZV8zXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMyA9IHsgZXJyb3I6IGVfM18xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEwLCAsIDEzLCAxNF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXRoXzFfMSAmJiAhcGF0aF8xXzEuZG9uZSAmJiAoX2EgPSBwYXRoXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKHBhdGhfMSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMjtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzY29wZS52YWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGhhc1JlZmVyZW5jZShzY29wZVZhbHVlLCBwYXRoU2V0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5yZWZlcmVuY2VzLmFyaXR5ID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPj0gMTsgfTtcbmdsb2JhbC5yb3VuZCA9IGZ1bmN0aW9uIHJvdW5kKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUsIG51bSwgcHJlYywgcHJlY1ZhbHVlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbnVtID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcHJlYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFyZ3MubGVuZ3RoID09PSAyKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHByZWNWYWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWNWYWx1ZS50eXBlICE9PSAnbnVtYmVyJyB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJlYyA9IHByZWNWYWx1ZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKYXZhU2NyaXB0J3Mgcm91bmQoKSBmdW5jdGlvbiB3aWxsIGFsd2F5cyByb3VuZHMgdG93YXJkcyBwb3NpdGl2ZSBpbmZpbml0eSAoLTMuNSAtPiAtMykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJlaGF2aW9yIHdlJ3JlIGludGVyZXN0ZWQgaW4gaXMgdG8gXCJyb3VuZCBoYWxmIGF3YXkgZnJvbSB6ZXJvXCIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21OdW1iZXIoLU1hdGgucm91bmQoLW51bSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tTnVtYmVyKE1hdGgucm91bmQobnVtKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tTnVtYmVyKE51bWJlcihudW0udG9GaXhlZChwcmVjKSkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLnJvdW5kLmFyaXR5ID0gZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiBjb3VudCA+PSAxICYmIGNvdW50IDw9IDI7IH07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuZ2xvYmFsLm5vdyA9IGZ1bmN0aW9uIG5vdyhhcmdzLCBzY29wZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC50aW1lc3RhbXAudG9JU09TdHJpbmcoKSldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwubm93LmFyaXR5ID0gMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG5nbG9iYWwuYm9vc3QgPSBmdW5jdGlvbiBib29zdCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhlIHNjb3JpbmcgZnVuY3Rpb24uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYm9vc3QgY2FsbCcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuYm9vc3QuYXJpdHkgPSAyO1xudmFyIHN0cmluZyA9IHt9O1xuc3RyaW5nLmxvd2VyID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvTG93ZXJDYXNlKCkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuc3RyaW5nLmxvd2VyLmFyaXR5ID0gMTtcbnN0cmluZy51cHBlciA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b1VwcGVyQ2FzZSgpKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbnN0cmluZy51cHBlci5hcml0eSA9IDE7XG5zdHJpbmcuc3BsaXQgPSBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHIsIHNlcDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhbXSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXAuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdXNlcyBhIFVuaWNvZGUgY29kZXBvaW50IHNwbGl0dGluZyBhbGdvcml0aG1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMoQXJyYXkuZnJvbShzdHIuZGF0YSkpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbUpTKHN0ci5kYXRhLnNwbGl0KHNlcC5kYXRhKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5zdHJpbmcuc3BsaXQuYXJpdHkgPSAyO1xuZ2xvYmFsLmxvd2VyID0gc3RyaW5nLmxvd2VyO1xuZ2xvYmFsLnVwcGVyID0gc3RyaW5nLnVwcGVyO1xuc3RyaW5nLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHIsIHByZWZpeDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZml4LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHN0ci5kYXRhLnN0YXJ0c1dpdGgocHJlZml4LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuc3RyaW5nLnN0YXJ0c1dpdGguYXJpdHkgPSAyO1xudmFyIGFycmF5ID0ge307XG5hcnJheS5qb2luID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgdmFyIGVfNCwgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyLCBzZXAsIGJ1ZiwgbmVlZFNlcCwgYXJyXzEsIGFycl8xXzEsIGVsZW0sIGVfNF8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhcnIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBuZWVkU2VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMywgOCwgOSwgMTRdKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyXzEgPSBfX2FzeW5jVmFsdWVzKGFycik7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIGFycl8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcnJfMV8xID0gX2Iuc2VudCgpLCAhYXJyXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBhcnJfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmICs9IHNlcC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZWxlbS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZiArPSBcIlwiLmNvbmNhdChlbGVtLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmVlZFNlcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgZV80XzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOSwgLCAxMiwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJyXzFfMSAmJiAhYXJyXzFfMS5kb25lICYmIChfYSA9IGFycl8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChhcnJfMSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhidWYpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuYXJyYXkuam9pbi5hcml0eSA9IDI7XG5hcnJheS5jb21wYWN0ID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhcnIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgU3RyZWFtVmFsdWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyXzIsIGFycl8yXzEsIGVsZW0sIGVfNV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV81LCBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJfMiA9IF9fYXN5bmNWYWx1ZXMoYXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChhcnJfMi5uZXh0KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGFycl8yXzEgPSBfYi5zZW50KCksICFhcnJfMl8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGFycl8yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGVsZW0udHlwZSAhPT0gJ251bGwnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoZWxlbSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzVfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV81ID0geyBlcnJvcjogZV81XzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhcnJfMl8xICYmICFhcnJfMl8xLmRvbmUgJiYgKF9hID0gYXJyXzJbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9hLmNhbGwoYXJyXzIpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmFycmF5LmNvbXBhY3QuYXJpdHkgPSAxO1xuYXJyYXkudW5pcXVlID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgU3RyZWFtVmFsdWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkZWQsIHZhbHVlXzIsIHZhbHVlXzJfMSwgaXRlciwgX2EsIGVfNl8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV82LCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgMTMsIDE0LCAxOV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV8yID0gX19hc3luY1ZhbHVlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodmFsdWVfMi5uZXh0KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzJfMSA9IF9jLnNlbnQoKSwgIXZhbHVlXzJfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyID0gdmFsdWVfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGl0ZXIudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGV0aW1lJzogcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFhZGRlZC5oYXMoaXRlci5kYXRhKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkLmFkZChpdGVyLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGl0ZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9jLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoaXRlcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNl8xID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzYgPSB7IGVycm9yOiBlXzZfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxNCwgLCAxNywgMThdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMl8xICYmICF2YWx1ZV8yXzEuZG9uZSAmJiAoX2IgPSB2YWx1ZV8yW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYi5jYWxsKHZhbHVlXzIpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxODogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5hcnJheS51bmlxdWUuYXJpdHkgPSAxO1xudmFyIHB0ID0ge307XG5wdC50ZXh0ID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUsIHRleHQ7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHRleHQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xucHQudGV4dC5hcml0eSA9IDE7XG52YXIgc2FuaXR5ID0ge307XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuc2FuaXR5LnByb2plY3RJZCA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG5zYW5pdHkuZGF0YXNldCA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkuZGF0YXNldCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG52YXIgcGlwZUZ1bmN0aW9ucyA9IHt9O1xucGlwZUZ1bmN0aW9ucy5vcmRlciA9IGZ1bmN0aW9uIG9yZGVyKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgdmFyIGJhc2VfMSwgYmFzZV8xXzE7XG4gICAgdmFyIGVfNywgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwcGVycywgZGlyZWN0aW9ucywgbiwgX2ksIGFyZ3NfMywgbWFwcGVyLCBkaXJlY3Rpb24sIGF1eCwgaWR4LCB2YWx1ZSwgbmV3U2NvcGUsIHR1cGxlLCBpLCByZXN1bHQsIF9iLCBfYywgZV83XzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ycGV0cmljaC9iYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWFzeW5jLXRvLXByb21pc2VzL2lzc3Vlcy81OVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRydWVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ycGV0cmljaC9iYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWFzeW5jLXRvLXByb21pc2VzL2lzc3Vlcy81OVxuICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXBwZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBhcmdzXzMgPSBhcmdzOyBfaSA8IGFyZ3NfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlciA9IGFyZ3NfM1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAnYXNjJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwZXIudHlwZSA9PT0gJ0Rlc2MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2Rlc2MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWFwcGVyLnR5cGUgPT09ICdBc2MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVyID0gbWFwcGVyLmJhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwZXJzLnB1c2gobWFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMucHVzaChkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF1eCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzIsIDEzLCAxNCwgMTldKTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZV8xID0gX19hc3luY1ZhbHVlcyhiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgYmFzZV8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlXzFfMSA9IF9kLnNlbnQoKSwgIWJhc2VfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmFzZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdHVwbGUgPSBbX2Quc2VudCgpLCBpZHhdO1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IG4pKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUobWFwcGVyc1tpXSwgbmV3U2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSAoX2IgPSB0dXBsZSkucHVzaDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzdWx0LmdldCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9jLmFwcGx5KF9iLCBbX2Quc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgYXV4LnB1c2godHVwbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAxMTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgZV83XzEgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfNyA9IHsgZXJyb3I6IGVfN18xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzE0LCAsIDE3LCAxOF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlXzFfMSAmJiAhYmFzZV8xXzEuZG9uZSAmJiAoX2EgPSBiYXNlXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGJhc2VfMSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAxNjtcbiAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfNykgdGhyb3cgZV83LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgYXV4LnNvcnQoZnVuY3Rpb24gKGFUdXBsZSwgYlR1cGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gdG90YWxDb21wYXJlKGFUdXBsZVtpICsgMl0sIGJUdXBsZVtpICsgMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSAnZGVzYycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IC1jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzb3J0aW5nIG9uIHRoZSBvcmlnaW5hbCBpbmRleCBmb3Igc3RhYmxlIHNvcnRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVR1cGxlWzFdIC0gYlR1cGxlWzFdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhhdXgubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2WzBdOyB9KSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5waXBlRnVuY3Rpb25zLm9yZGVyLmFyaXR5ID0gZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiBjb3VudCA+PSAxOyB9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbnBpcGVGdW5jdGlvbnMuc2NvcmUgPSBmdW5jdGlvbiBzY29yZShiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBiYXNlXzIsIGJhc2VfMl8xO1xuICAgIHZhciBlXzgsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVua25vd24sIHNjb3JlZCwgdmFsdWUsIF9iLCBfYywgbmV3U2NvcGUsIHZhbHVlU2NvcmUsIF9pLCBhcmdzXzQsIGFyZywgX2QsIG5ld09iamVjdCwgZV84XzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZS5pc0FycmF5KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFueXRoaW5nIHRoYXQgaXNuJ3QgYW4gb2JqZWN0IHNob3VsZCBiZSBzb3J0ZWQgZmlyc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB1bmtub3duID0gW107XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfZS50cnlzLnB1c2goWzEsIDEyLCAxMywgMThdKTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZV8yID0gX19hc3luY1ZhbHVlcyhiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgYmFzZV8yLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlXzJfMSA9IF9lLnNlbnQoKSwgIWJhc2VfMl8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmFzZV8yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlLnR5cGUgIT09ICdvYmplY3QnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIF9jID0gKF9iID0gdW5rbm93bikucHVzaDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgX2MuYXBwbHkoX2IsIFtfZS5zZW50KCldKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVNjb3JlID0gdHlwZW9mIHZhbHVlLmRhdGEuX3Njb3JlID09PSAnbnVtYmVyJyA/IHZhbHVlLmRhdGEuX3Njb3JlIDogMDtcbiAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBhcmdzXzQgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGFyZ3NfNC5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnc180W19pXTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSB2YWx1ZVNjb3JlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBldmFsdWF0ZVNjb3JlKGFyZywgbmV3U2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU2NvcmUgPSBfZCArIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVkLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgZV84XzEgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfOCA9IHsgZXJyb3I6IGVfOF8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBfZS50cnlzLnB1c2goWzEzLCAsIDE2LCAxN10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlXzJfMSAmJiAhYmFzZV8yXzEuZG9uZSAmJiAoX2EgPSBiYXNlXzJbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGJhc2VfMildO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxNTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OiByZXR1cm4gWzMgLypicmVhayovLCAxN107XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIuX3Njb3JlIC0gYS5fc2NvcmU7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbUpTKHNjb3JlZCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5waXBlRnVuY3Rpb25zLnNjb3JlLmFyaXR5ID0gZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiBjb3VudCA+PSAxOyB9O1xudmFyIGRlbHRhID0ge307XG5kZWx0YS5vcGVyYXRpb24gPSBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNCZWZvcmUsIGhhc0FmdGVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBoYXNCZWZvcmUgPSBzY29wZS5jb250ZXh0LmJlZm9yZSAhPT0gbnVsbDtcbiAgICAgICAgICAgIGhhc0FmdGVyID0gc2NvcGUuY29udGV4dC5hZnRlciAhPT0gbnVsbDtcbiAgICAgICAgICAgIGlmIChoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZygndXBkYXRlJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoJ2NyZWF0ZScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZygnZGVsZXRlJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5kZWx0YS5jaGFuZ2VkQW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuZGVsdGEuY2hhbmdlZEFueS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkQW55Lm1vZGUgPSAnZGVsdGEnO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gJ2RlbHRhJztcbnZhciBkaWZmID0ge307XG5kaWZmLmNoYW5nZWRBbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5kaWZmLmNoYW5nZWRBbnkuYXJpdHkgPSAzO1xuZGlmZi5jaGFuZ2VkT25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbmRpZmYuY2hhbmdlZE9ubHkuYXJpdHkgPSAzO1xudmFyIG1hdGggPSB7fTtcbm1hdGgubWluID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgdmFyIGVfOSwgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyLCBuLCBhcnJfMywgYXJyXzNfMSwgZWxlbSwgZV85XzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFyciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnIuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsyLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICBhcnJfMyA9IF9fYXN5bmNWYWx1ZXMoYXJyKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgYXJyXzMubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFycl8zXzEgPSBfYi5zZW50KCksICFhcnJfM18xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGFycl8zXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdudWxsJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgZWxlbS5kYXRhIDwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGVsZW0uZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGVfOV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzkgPSB7IGVycm9yOiBlXzlfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFycl8zXzEgJiYgIWFycl8zXzEuZG9uZSAmJiAoX2EgPSBhcnJfM1tcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwoYXJyXzMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfOSkgdGhyb3cgZV85LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhuKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbm1hdGgubWluLmFyaXR5ID0gMTtcbm1hdGgubWF4ID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgdmFyIGVfMTAsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyciwgbiwgYXJyXzQsIGFycl80XzEsIGVsZW0sIGVfMTBfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYXJyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgIGFycl80ID0gX19hc3luY1ZhbHVlcyhhcnIpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBhcnJfNC5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJyXzRfMSA9IF9iLnNlbnQoKSwgIWFycl80XzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtID0gYXJyXzRfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gJ251bGwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZCB8fCBlbGVtLmRhdGEgPiBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gZWxlbS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgZV8xMF8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzEwID0geyBlcnJvcjogZV8xMF8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJyXzRfMSAmJiAhYXJyXzRfMS5kb25lICYmIChfYSA9IGFycl80W1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChhcnJfNCldO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8xMCkgdGhyb3cgZV8xMC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMobildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5tYXRoLm1heC5hcml0eSA9IDE7XG5tYXRoLnN1bSA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBlXzExLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnIsIG4sIGFycl81LCBhcnJfNV8xLCBlbGVtLCBlXzExXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFyciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnIuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMiwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyXzUgPSBfX2FzeW5jVmFsdWVzKGFycik7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIGFycl81Lm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcnJfNV8xID0gX2Iuc2VudCgpLCAhYXJyXzVfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBhcnJfNV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS50eXBlID09PSAnbnVsbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0udHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuICs9IGVsZW0uZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBlXzExXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMTEgPSB7IGVycm9yOiBlXzExXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcnJfNV8xICYmICFhcnJfNV8xLmRvbmUgJiYgKF9hID0gYXJyXzVbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGFycl81KV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzExKSB0aHJvdyBlXzExLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhuKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbm1hdGguc3VtLmFyaXR5ID0gMTtcbm1hdGguYXZnID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgdmFyIGVfMTIsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyciwgbiwgYywgYXJyXzYsIGFycl82XzEsIGVsZW0sIGVfMTJfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYXJyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMiwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyXzYgPSBfX2FzeW5jVmFsdWVzKGFycik7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIGFycl82Lm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcnJfNl8xID0gX2Iuc2VudCgpLCAhYXJyXzZfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBhcnJfNl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS50eXBlID09PSAnbnVsbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0udHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuICs9IGVsZW0uZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGVfMTJfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8xMiA9IHsgZXJyb3I6IGVfMTJfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFycl82XzEgJiYgIWFycl82XzEuZG9uZSAmJiAoX2EgPSBhcnJfNltcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwoYXJyXzYpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMTIpIHRocm93IGVfMTIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMobiAvIGMpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xubWF0aC5hdmcuYXJpdHkgPSAxO1xudmFyIG5hbWVzcGFjZXMgPSB7XG4gICAgZ2xvYmFsOiBnbG9iYWwsXG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgYXJyYXk6IGFycmF5LFxuICAgIHB0OiBwdCxcbiAgICBkZWx0YTogZGVsdGEsXG4gICAgZGlmZjogZGlmZixcbiAgICBzYW5pdHk6IHNhbml0eSxcbiAgICBtYXRoOiBtYXRoXG59O2NvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvO1xuY29uc3QgTlVNID0gL15cXGQrLztcbmNvbnN0IElERU5UID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qLztcblxuLy8gUHJlY2VkZW5jZSBsZXZlbHMgZm9yIGJpbmFyeSBvcGVyYXRvcnM6XG5jb25zdCBQUkVDX1BBSVIgPSAxO1xuY29uc3QgUFJFQ19PUiA9IDI7XG5jb25zdCBQUkVDX0FORCA9IDM7XG5jb25zdCBQUkVDX0NPTVAgPSA0O1xuY29uc3QgUFJFQ19PUkRFUiA9IDQ7XG5jb25zdCBQUkVDX0FERCA9IDY7XG5jb25zdCBQUkVDX1NVQiA9IDY7XG5jb25zdCBQUkVDX01VTCA9IDc7XG5jb25zdCBQUkVDX0RJViA9IDc7XG5jb25zdCBQUkVDX01PRCA9IDc7XG5jb25zdCBQUkVDX1BPVyA9IDg7XG5cbi8vIFByZWNlZGVuY2UgbGV2ZWxzIGZvciBwcmVmaXggb3BlcmF0b3JzOlxuY29uc3QgUFJFQ19QT1MgPSAxMDtcbmNvbnN0IFBSRUNfTk9UID0gMTA7XG5jb25zdCBQUkVDX05FRyA9IDg7XG5cbmZ1bmN0aW9uIHBhcnNlJDEoc3RyKSB7XG4gIGxldCBwb3MgPSAwO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gIGlmIChwb3MgIT09IHN0ci5sZW5ndGgpIHtcbiAgICBpZiAocmVzdWx0LmZhaWxQb3NpdGlvbikge1xuICAgICAgcG9zID0gcmVzdWx0LmZhaWxQb3NpdGlvbiAtIDE7XG4gICAgfVxuICAgIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgfVxuICBkZWxldGUgcmVzdWx0LnBvc2l0aW9uO1xuICBkZWxldGUgcmVzdWx0LmZhaWxQb3NpdGlvbjtcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyLCBwb3MsIGxldmVsKSB7XG4gIC8vIEluIHRoaXMgZnVuY3Rpb24gd2UgcGFyc2UgcHJlY2VkZW5jZSBcIm1hbnVhbGx5XCIgYnkgaGF2aW5nIHR3byB2YXJpYWJsZXM6XG4gIC8vXG4gIC8vIGBsZXZlbGAgaXMgdGhlIG1pbmltdW0gcHJlY2VkZW5jZSBsZXZlbCB3ZSB3YW50IHRvIHBhcnNlIGF0LiBJZiB0aGlzIGlzXG4gIC8vIGUuZy4gNyB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgcGFyc2UgYDMgKyA0YCAoc2luY2UgYWRkaXRpb24gaXMgYXQgNiksXG4gIC8vIGJ1dCBpbnN0ZWFkIGp1c3QgcmV0dXJuIGAxYCBhbmQgbGVhdmUgYCArIDVgIHJlbWFpbmluZy4gV2UgdXNlIHRoaXMgc28gdGhhdFxuICAvLyB3aGlsZSBoYW5kbGluZyB0aGUgUkhTIG9mIHRoZSBtdWx0aXBsaWNhdGlvbiBpbiBgMSArIDIgKiAzICsgNGAgd2Ugb25seSBwYXJzZSBgM2AuXG4gIC8vXG4gIC8vIGBsaHNMZXZlbGAgaXMgdGhlIHByZWNlZGVuY2UgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBwYXJzZWQgZXhwcmVzc2lvbiBvblxuICAvLyB0aGUgbGVmdC1oYW5kIHNpZGUuIFRoaXMgaXMgbWFpbmx5IHVzZWQgdG8gaGFuZGxlIG5vbi1hc3NvY2ljYXRpdmVuZXNzLlxuXG4gIC8vIFRoaXMgbWVhbnMgdGhhdCB5b3UnbGwgc2VlIGNvZGUgbGlrZTpcbiAgLy8gLSBgaWYgKGxldmVsID4gUFJFQ19YWFgpIGJyZWFrYDogT3BlcmF0b3IgaXMgYXQgdGhpcyBwcmVjZWRlbmNlIGxldmVsLlxuICAvLyAtIGBpZiAobGhzTGV2ZWwgPCBQUkVDX1hYWCkgYnJlYWtgOiBPcGVyYXRvciBpcyBsZWZ0LWFzc29jaWF0aXZlLlxuICAvLyAtIGBpZiAobGhzTGV2ZWwgPD0gUFJFQ19YWFgpIGJyZWFrYDogT3BlcmF0b3IgaXMgcmlnaHQvbm9uLWFzc29jaWF0aXZlLlxuICAvLyAtIGBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfWFhYICsgMSlgOiBPcGVyYXRvciBpcyBsZWZ0L25vbi1hc3NvaWNhdGUuXG4gIC8vIC0gYHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19YWFgpYDogT3BlcmF0b3IgaXMgcmlnaHQtYXNzb2ljYXRlLlxuXG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIGxldCBtYXJrcztcblxuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSAnKyc6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19QT1MpO1xuICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICBtYXJrcyA9IFt7bmFtZTogJ3BvcycsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnLSc6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19ORUcpO1xuICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICBtYXJrcyA9IFt7bmFtZTogJ25lZycsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnKCc6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgIGNhc2UgJywnOiB7XG4gICAgICAgICAgLy8gVHVwbGVzXG4gICAgICAgICAgbWFya3MgPSBbe25hbWU6ICd0dXBsZScsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHN0cltwb3NdICE9PSAnLCcpIGJyZWFrXG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSAnKScpIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAndHVwbGVfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnKSc6IHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBtYXJrcyA9IFt7bmFtZTogJ2dyb3VwJywgcG9zaXRpb246IHN0YXJ0UG9zfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJyEnOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTk9UKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgbWFya3MgPSBbe25hbWU6ICdub3QnLCBwb3NpdGlvbjogc3RhcnRQb3N9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ3snOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ1snOlxuICAgICAgbWFya3MgPSBbe25hbWU6ICdhcnJheScsIHBvc2l0aW9uOiBwb3N9XTtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuXG4gICAgICBpZiAoc3RyW3Bvc10gIT09ICddJykge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gJy4uLicpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdhcnJheV9zcGxhdCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCByZXMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgIGlmIChyZXMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlcy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmVzLnBvc2l0aW9uO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSAnLCcpIGJyZWFrXG4gICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgaWYgKHN0cltwb3NdID09PSAnXScpIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0cltwb3NdID09PSAnXScpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdhcnJheV9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzO1xuICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnXic6IHtcbiAgICAgIHBvcysrO1xuICAgICAgbWFya3MgPSBbXTtcbiAgICAgIHdoaWxlIChzdHJbcG9zXSA9PT0gJy4nICYmIHN0cltwb3MgKyAxXSA9PT0gJ14nKSB7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdkYmxwYXJlbnQnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKHtuYW1lOiAncGFyZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdAJzpcbiAgICAgIG1hcmtzID0gW3tuYW1lOiAndGhpcycsIHBvc2l0aW9uOiBzdGFydFBvc31dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVha1xuICAgIGNhc2UgJyonOlxuICAgICAgbWFya3MgPSBbe25hbWU6ICdldmVyeXRoaW5nJywgcG9zaXRpb246IHN0YXJ0UG9zfV07XG4gICAgICBwb3MrKztcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnJCc6IHtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zICs9IDEgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAge25hbWU6ICdwYXJhbScsIHBvc2l0aW9uOiBzdGFydFBvc30sXG4gICAgICAgICAge25hbWU6ICdpZGVudCcsIHBvc2l0aW9uOiBzdGFydFBvcyArIDF9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvc30sXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgIGlmIChudW1MZW4pIHtcbiAgICAgICAgcG9zICs9IG51bUxlbjtcbiAgICAgICAgbGV0IG5hbWUgPSAnaW50ZWdlcic7XG5cbiAgICAgICAgaWYgKHN0cltwb3NdID09PSAnLicpIHtcbiAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgIGlmIChmcmFjTGVuKSB7XG4gICAgICAgICAgICBuYW1lID0gJ2Zsb2F0JztcbiAgICAgICAgICAgIHBvcyArPSAxICsgZnJhY0xlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyW3Bvc10gPT09ICdlJyB8fCBzdHJbcG9zXSA9PT0gJ0UnKSB7XG4gICAgICAgICAgbmFtZSA9ICdzY2knO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJysnIHx8IHN0cltwb3NdID09PSAnLScpIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICBpZiAoIWV4cExlbikgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgICAgIHBvcyArPSBleHBMZW47XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICB7bmFtZSwgcG9zaXRpb246IHN0YXJ0UG9zfSxcbiAgICAgICAgICB7bmFtZTogbmFtZSArICdfZW5kJywgcG9zaXRpb246IHBvc30sXG4gICAgICAgIF07XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyArPSBpZGVudExlbjtcbiAgICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgIGNhc2UgJygnOiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgICAgICB7bmFtZTogJ3RoaXNfYXR0cicsIHBvc2l0aW9uOiBzdGFydFBvc30sXG4gICAgICAgICAgICAgIHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogc3RhcnRQb3N9LFxuICAgICAgICAgICAgICB7bmFtZTogJ2lkZW50X2VuZCcsIHBvc2l0aW9uOiBwb3N9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghbWFya3MpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gIH1cblxuICBsZXQgbGhzTGV2ZWwgPSAxMjtcbiAgbGV0IHRyYXY7XG5cbiAgbG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgcG9zID0gaW5uZXJQb3M7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIGlubmVyUG9zKTtcbiAgICBpZiAodHJhdi50eXBlID09PSAnc3VjY2VzcycpIHtcbiAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICd0cmF2ZXJzZScsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgd2hpbGUgKHRyYXYudHlwZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHRyYXYubWFya3MpO1xuICAgICAgICBwb3MgPSB0cmF2LnBvc2l0aW9uO1xuICAgICAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBza2lwV1Moc3RyLCBwb3MpKTtcbiAgICAgIH1cbiAgICAgIG1hcmtzLnB1c2goe25hbWU6ICd0cmF2ZXJzYWxfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBsZXQgdG9rZW4gPSBzdHJbaW5uZXJQb3NdO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJz0nOiB7XG4gICAgICAgIGxldCBuZXh0VG9rZW4gPSBzdHJbaW5uZXJQb3MgKyAxXTtcbiAgICAgICAgc3dpdGNoIChuZXh0VG9rZW4pIHtcbiAgICAgICAgICBjYXNlICc+Jzoge1xuICAgICAgICAgICAgLy8gPT5cbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUEFJUiB8fCBsaHNMZXZlbCA8PSBQUkVDX1BBSVIpIGJyZWFrIGxvb3BcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX1BBSVIpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ3BhaXInLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QQUlSO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnPSc6IHtcbiAgICAgICAgICAgIC8vID09XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wXG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBpbm5lclBvcyArIDJ9KTtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJysnOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQUREIHx8IGxoc0xldmVsIDwgUFJFQ19BREQpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfQUREICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnYWRkJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FERDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJy0nOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfU1VCIHx8IGxoc0xldmVsIDwgUFJFQ19TVUIpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfU1VCICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnc3ViJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1NVQjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJyonOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gJyonKSB7XG4gICAgICAgICAgLy8gKipcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BPVyB8fCBsaHNMZXZlbCA8PSBQUkVDX1BPVykgYnJlYWsgbG9vcFxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX1BPVyk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAncG93JywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QT1c7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICpcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NVUwgfHwgbGhzTGV2ZWwgPCBQUkVDX01VTCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19NVUwgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdtdWwnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfTVVMO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnLyc6IHtcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19ESVYgfHwgbGhzTGV2ZWwgPCBQUkVDX0RJVikgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19ESVYgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdkaXYnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfRElWO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnJSc6IHtcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NT0QgfHwgbGhzTGV2ZWwgPCBQUkVDX01PRCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19NT0QgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdtb2QnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfTU9EO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnPCc6XG4gICAgICBjYXNlICc+Jzoge1xuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wXG4gICAgICAgIGxldCBuZXh0UG9zID0gaW5uZXJQb3MgKyAxO1xuICAgICAgICBpZiAoc3RyW25leHRQb3NdID09PSAnPScpIHtcbiAgICAgICAgICBuZXh0UG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvcCcsIHBvc2l0aW9uOiBpbm5lclBvc30sIHtuYW1lOiAnb3BfZW5kJywgcG9zaXRpb246IG5leHRQb3N9KTtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3wnOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gJ3wnKSB7XG4gICAgICAgICAgLy8gfHxcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SIHx8IGxoc0xldmVsIDwgUFJFQ19PUikgYnJlYWsgbG9vcFxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX09SICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnb3InLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDExIHx8IGxoc0xldmVsIDwgMTEpIGJyZWFrIGxvb3BcbiAgICAgICAgICAvLyBwaXBlIGNhbGxcbiAgICAgICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpO1xuICAgICAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgICAgIGlmICghaWRlbnRMZW4pIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IGlkZW50UG9zfVxuICAgICAgICAgIHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW47XG4gICAgICAgICAgaWYgKHN0cltwb3NdID09PSAnKCcgfHwgc3RyW3Bvc10gPT09ICc6Jykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBpZGVudFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdwaXBlY2FsbCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSAxMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJyYnOiB7XG4gICAgICAgIC8vICYmXG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPSAnJicpIGJyZWFrIGxvb3BcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19BTkQgfHwgbGhzTGV2ZWwgPCBQUkVDX0FORCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19BTkQgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdhbmQnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQU5EO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnISc6IHtcbiAgICAgICAgLy8gIT1cbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9PSAnPScpIGJyZWFrIGxvb3BcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDwgUFJFQ19DT01QKSBicmVhayBsb29wXG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvcCcsIHBvc2l0aW9uOiBpbm5lclBvc30sIHtuYW1lOiAnb3BfZW5kJywgcG9zaXRpb246IGlubmVyUG9zICsgMn0pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnZCc6IHtcbiAgICAgICAgLy8gYXNjXG4gICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09ICdkZXNjJykgYnJlYWsgbG9vcFxuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUikgYnJlYWsgbG9vcFxuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnZGVzYycsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBwb3MgPSBpbm5lclBvcyArIDQ7XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19PUkRFUjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2EnOiB7XG4gICAgICAgIC8vIGFzY1xuICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDMpICE9PSAnYXNjJykgYnJlYWsgbG9vcFxuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUikgYnJlYWsgbG9vcFxuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnYXNjJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IGlubmVyUG9zICsgMztcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBsZXQgaWRlbnQgPSBwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKTtcbiAgICAgICAgc3dpdGNoIChpZGVudCkge1xuICAgICAgICAgIGNhc2UgJ2luJzoge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuXG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpO1xuXG4gICAgICAgICAgICBsZXQgaXNHcm91cCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09ICcoJykge1xuICAgICAgICAgICAgICBpc0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG5cbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJy4nICYmIHN0cltwb3MgKyAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgIC8vIExIUyBpbiBSQU5HRVxuICAgICAgICAgICAgICBsZXQgdHlwZSA9ICdpbmNfcmFuZ2UnO1xuICAgICAgICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2V4Y19yYW5nZSc7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdpbl9yYW5nZScsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7bmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zfSwgcmVzdWx0Lm1hcmtzLCByaHMubWFya3MpO1xuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMSFMgaW4gUkhTXG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvcCcsIHBvc2l0aW9uOiBpbm5lclBvc30sIHtuYW1lOiAnb3BfZW5kJywgcG9zaXRpb246IGlubmVyUG9zICsgMn0pO1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09ICcpJykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdtYXRjaCc6IHtcbiAgICAgICAgICAgIC8vIG1hdGNoIG9wZXJhdG9yXG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wXG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyA1KSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBpbm5lclBvcyArIDV9KTtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGZhaWxQb3NpdGlvbiA9IHRyYXY/LnR5cGUgPT09ICdlcnJvcicgJiYgdHJhdi5wb3NpdGlvbjtcblxuICByZXR1cm4ge3R5cGU6ICdzdWNjZXNzJywgbWFya3MsIHBvc2l0aW9uOiBwb3MsIGZhaWxQb3NpdGlvbn1cbn1cblxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgY2FzZSAnLic6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgbGV0IGlkZW50U3RhcnQgPSBwb3M7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICBpZiAoIWlkZW50TGVuKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICBwb3MgKz0gaWRlbnRMZW47XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICB7bmFtZTogJ2F0dHJfYWNjZXNzJywgcG9zaXRpb246IHN0YXJ0UG9zfSxcbiAgICAgICAgICB7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IGlkZW50U3RhcnR9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvc30sXG4gICAgICAgIF0sXG4gICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICB9XG4gICAgfVxuICAgIGNhc2UgJy0nOlxuICAgICAgaWYgKHN0cltwb3MgKyAxXSAhPT0gJz4nKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICAvLyAtPlxuXG4gICAgICBsZXQgbWFya3MgPSBbe25hbWU6ICdkZXJlZicsIHBvc2l0aW9uOiBzdGFydFBvc31dO1xuICAgICAgcG9zICs9IDI7XG5cbiAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xuICAgICAgICBtYXJrcy5wdXNoKFxuICAgICAgICAgIHtuYW1lOiAnZGVyZWZfYXR0cicsIHBvc2l0aW9uOiBpZGVudFBvc30sXG4gICAgICAgICAge25hbWU6ICdpZGVudCcsIHBvc2l0aW9uOiBpZGVudFBvc30sXG4gICAgICAgICAge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgIG1hcmtzLFxuICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgfVxuICAgIGNhc2UgJ1snOiB7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcblxuICAgICAgaWYgKHN0cltwb3NdID09PSAnXScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgbWFya3M6IFt7bmFtZTogJ2FycmF5X3Bvc3RmaXgnLCBwb3NpdGlvbjogc3RhcnRQb3N9XSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuXG4gICAgICBpZiAoc3RyW3Bvc10gPT09ICcuJyAmJiBzdHJbcG9zICsgMV0gPT09ICcuJykge1xuICAgICAgICBsZXQgdHlwZSA9ICdpbmNfcmFuZ2UnO1xuICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSAnLicpIHtcbiAgICAgICAgICB0eXBlID0gJ2V4Y19yYW5nZSc7XG4gICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICAgIGlmIChzdHJbcG9zXSAhPT0gJ10nKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnc2xpY2UnLCBwb3NpdGlvbjogc3RhcnRQb3N9LFxuICAgICAgICAgICAge25hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvc30sXG4gICAgICAgICAgXS5jb25jYXQocmVzdWx0Lm1hcmtzLCByaHMubWFya3MpLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gJ10nKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgbWFya3M6IFt7bmFtZTogJ3NxdWFyZV9icmFja2V0JywgcG9zaXRpb246IHN0YXJ0UG9zfV0uY29uY2F0KHJlc3VsdC5tYXJrcyksXG4gICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxLFxuICAgICAgfVxuICAgIH1cbiAgICBjYXNlICd8Jzoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gPT09ICd7Jykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcbiAgICAgICAgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoe25hbWU6ICdwcm9qZWN0aW9uJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ3snOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7bmFtZTogJ3Byb2plY3Rpb24nLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuXG4gIG1hcmtzLnB1c2goe25hbWU6ICdmdW5jX2NhbGwnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcblxuICBpZiAoc3RyW3Bvc10gPT09ICc6JyAmJiBzdHJbcG9zICsgMV0gPT09ICc6Jykge1xuICAgIG1hcmtzLnB1c2goe25hbWU6ICduYW1lc3BhY2UnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICBtYXJrcy5wdXNoKHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogc3RhcnRQb3N9LCB7bmFtZTogJ2lkZW50X2VuZCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAyKTtcbiAgICBsZXQgbmFtZUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICBpZiAoIW5hbWVMZW4pIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICBtYXJrcy5wdXNoKHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogcG9zfSwge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zICsgbmFtZUxlbn0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVMZW4pO1xuICAgIGlmIChzdHJbcG9zXSAhPT0gJygnKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgcG9zKys7XG4gIH0gZWxzZSB7XG4gICAgbWFya3MucHVzaCh7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSwge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIH1cblxuICBsZXQgbGFzdFBvcyA9IHBvcztcblxuICBpZiAoc3RyW3Bvc10gIT09ICcpJykge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgIGxhc3RQb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSAnLCcpIGJyZWFrXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIC8vIEFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzXG4gICAgICBpZiAoc3RyW3Bvc10gPT09ICcpJykgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyW3Bvc10gIT09ICcpJykge1xuICAgIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgfVxuXG4gIC8vIE5PVEU6IGEgYml0IGFyYml0cmFyeSB0aGUgZnVuY19hcmdzX2VuZCBwb2ludHMgY29tZXMgYmVmb3JlIHRoZSB3aGl0ZXNwYWNlLlxuICBtYXJrcy5wdXNoKHtuYW1lOiAnZnVuY19hcmdzX2VuZCcsIHBvc2l0aW9uOiBsYXN0UG9zfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvcyArIDEsXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VPYmplY3Qoc3RyLCBwb3MpIHtcbiAgbGV0IG1hcmtzID0gW3tuYW1lOiAnb2JqZWN0JywgcG9zaXRpb246IHBvc31dO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcblxuICB3aGlsZSAoc3RyW3Bvc10gIT09ICd9Jykge1xuICAgIGxldCBwYWlyUG9zID0gcG9zO1xuXG4gICAgaWYgKHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSAnLi4uJykge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09ICd9JyAmJiBzdHJbcG9zXSAhPT0gJywnKSB7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIGV4cHJcbiAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ29iamVjdF9zcGxhdCcsIHBvc2l0aW9uOiBwYWlyUG9zfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MpO1xuICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ29iamVjdF9zcGxhdF90aGlzJywgcG9zaXRpb246IHBhaXJQb3N9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKGV4cHIudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIGV4cHJcbiAgICAgIGxldCBuZXh0UG9zID0gc2tpcFdTKHN0ciwgZXhwci5wb3NpdGlvbik7XG4gICAgICBpZiAoZXhwci5tYXJrc1swXS5uYW1lID09PSAnc3RyJyAmJiBzdHJbbmV4dFBvc10gPT09ICc6Jykge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHZhbHVlXG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvYmplY3RfcGFpcicsIHBvc2l0aW9uOiBwYWlyUG9zfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKTtcbiAgICAgICAgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7bmFtZTogJ29iamVjdF9leHByJywgcG9zaXRpb246IHBvc30sIGV4cHIubWFya3MpO1xuICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgIGlmIChzdHJbcG9zXSAhPT0gJywnKSBicmVha1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG5cbiAgaWYgKHN0cltwb3NdICE9PSAnfScpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gIH1cblxuICBwb3MrKztcbiAgbWFya3MucHVzaCh7bmFtZTogJ29iamVjdF9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gIHJldHVybiB7dHlwZTogJ3N1Y2Nlc3MnLCBtYXJrcywgcG9zaXRpb246IHBvc31cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBwb3MpIHtcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIHBvcyA9IHBvcyArIDE7XG4gIGNvbnN0IG1hcmtzID0gW3tuYW1lOiAnc3RyJywgcG9zaXRpb246IHBvc31dO1xuICBzdHI6IGZvciAoOyA7IHBvcysrKSB7XG4gICAgaWYgKHBvcyA+IHN0ci5sZW5ndGgpIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cblxuICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgIGNhc2UgdG9rZW46IHtcbiAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3N0cl9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBicmVhayBzdHJcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1xcXFwnOiB7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdzdHJfcGF1c2UnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgIGlmIChzdHJbcG9zICsgMV0gPT09ICd1Jykge1xuICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09ICd7Jykge1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3VuaWNvZGVfaGV4JywgcG9zaXRpb246IHBvcyArIDN9KTtcbiAgICAgICAgICAgIHBvcyA9IHN0ci5pbmRleE9mKCd9JywgcG9zICsgMyk7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAndW5pY29kZV9oZXhfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAndW5pY29kZV9oZXgnLCBwb3NpdGlvbjogcG9zICsgMn0pO1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3VuaWNvZGVfaGV4X2VuZCcsIHBvc2l0aW9uOiBwb3MgKyA2fSk7XG4gICAgICAgICAgICBwb3MgKz0gNTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3NpbmdsZV9lc2NhcGUnLCBwb3NpdGlvbjogcG9zICsgMX0pO1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdzdHJfc3RhcnQnLCBwb3NpdGlvbjogcG9zICsgMX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7dHlwZTogJ3N1Y2Nlc3MnLCBtYXJrcywgcG9zaXRpb246IHBvc31cbn1cblxuZnVuY3Rpb24gc2tpcFdTKHN0ciwgcG9zKSB7XG4gIHJldHVybiBwb3MgKyBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBXUylcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSByZWdleCBhdCBhIHBvc2l0aW9uIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdhcyBtYXRjaGVkLlxuICovXG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0ubGVuZ3RoIDogMFxufVxuXG4vKipcbiAqIFBhcnNlcyBhIHJlZ2V4IGF0IGEgcG9zaXRpb24gYW5kIHJldHVybnMgbWF0Y2hlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUmVnZXhTdHIoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGxcbn0vKipcbiAqIEpvaW4gY29tYmluZXMgdHdvIHRyYXZlcnNhbHMsIHJldHVybmluZyBhIG1hcHBlciB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIGZpcnN0XG4gKiBhcHBseWluZyBgYWAgYW5kIHRoZW4gYXBwbHlpbmcgYGJgLlxuICovXG5mdW5jdGlvbiBqb2luKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuIGIoYShiYXNlKSk7IH07XG59XG4vKipcbiAqIE1hcCByZXR1cm5zIGEgbmV3IG1hcHBlciB3aGljaCB3aWxsIHRoZSBpbm5lciBtYXBwZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBtYXAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdNYXAnLCBiYXNlOiBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6ICdUaGlzJyB9KSB9KTsgfTtcbn1cbmZ1bmN0aW9uIGZsYXRNYXAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdGbGF0TWFwJywgYmFzZTogYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiAnVGhpcycgfSkgfSk7IH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUFycmF5KGJ1aWxkLCByaWdodCkge1xuICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdhLWEnLFxuICAgICAgICAgICAgYnVpbGQ6IGJ1aWxkXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgICAgICBjYXNlICdhLWEnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdhLWInOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1iJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdiLWInOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihidWlsZCwgbWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2ItYSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhLWEnLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBmbGF0TWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiLmNvbmNhdChyaWdodC50eXBlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQbGFpbihtYXBwZXIsIHJpZ2h0KSB7XG4gICAgaWYgKCFyaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2ItYicsXG4gICAgICAgICAgICBidWlsZDogbWFwcGVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgICAgICBjYXNlICdhLWEnOlxuICAgICAgICBjYXNlICdiLWEnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYi1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYS1iJzpcbiAgICAgICAgY2FzZSAnYi1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ItYicsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiLmNvbmNhdChyaWdodC50eXBlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcbiAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnYS1iJyxcbiAgICAgICAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2EtYSc6XG4gICAgICAgIGNhc2UgJ2ItYSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhLWEnLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdhLWInOlxuICAgICAgICBjYXNlICdiLWInOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1iJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVByb2plY3Rpb24obWFwcGVyLCByaWdodCkge1xuICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdiLWInLFxuICAgICAgICAgICAgYnVpbGQ6IG1hcHBlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYS1hJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYS1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYicsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYi1hJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ItYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2ItYic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdiLWInLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICAgIH1cbn12YXIgaXNFcXVhbCA9IGVxdWFsaXR5O1xuZnVuY3Rpb24gZXF1YWxpdHkoYSwgYikge1xuICAgIGlmICgoYS50eXBlID09PSAnc3RyaW5nJyAmJiBiLnR5cGUgPT09ICdzdHJpbmcnKSB8fFxuICAgICAgICAoYS50eXBlID09PSAnYm9vbGVhbicgJiYgYi50eXBlID09PSAnYm9vbGVhbicpIHx8XG4gICAgICAgIChhLnR5cGUgPT09ICdudWxsJyAmJiBiLnR5cGUgPT09ICdudWxsJykgfHxcbiAgICAgICAgKGEudHlwZSA9PT0gJ251bWJlcicgJiYgYi50eXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgcmV0dXJuIGEuZGF0YSA9PT0gYi5kYXRhO1xuICAgIH1cbiAgICBpZiAoYS50eXBlID09PSAnZGF0ZXRpbWUnICYmIGIudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICByZXR1cm4gYS5kYXRhLmVxdWFscyhiLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59dmFyIG9wZXJhdG9ycyA9IHtcbiAgICAnPT0nOiBmdW5jdGlvbiBlcShsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfSxcbiAgICAnIT0nOiBmdW5jdGlvbiBuZXEobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICAgIH0sXG4gICAgJz4nOiBmdW5jdGlvbiBndChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnc3RyZWFtJyB8fCByaWdodC50eXBlID09PSAnc3RyZWFtJylcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfSxcbiAgICAnPj0nOiBmdW5jdGlvbiBndGUobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ3N0cmVhbScgfHwgcmlnaHQudHlwZSA9PT0gJ3N0cmVhbScpXG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPj0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9LFxuICAgICc8JzogZnVuY3Rpb24gbHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ3N0cmVhbScgfHwgcmlnaHQudHlwZSA9PT0gJ3N0cmVhbScpXG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH0sXG4gICAgJzw9JzogZnVuY3Rpb24gbHRlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdzdHJlYW0nIHx8IHJpZ2h0LnR5cGUgPT09ICdzdHJlYW0nKVxuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgXCJpblwiOiBmdW5jdGlvbiBpbm9wKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciByaWdodF8xLCByaWdodF8xXzE7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYiwgZV8xXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQudHlwZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyaWdodC5pc0FycmF5KCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCA2LCA3LCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRfMSA9IF9fYXN5bmNWYWx1ZXMocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHJpZ2h0XzEubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmlnaHRfMV8xID0gX2Iuc2VudCgpLCAhcmlnaHRfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSByaWdodF8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbChsZWZ0LCBiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUUlVFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs3LCAsIDEwLCAxMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmlnaHRfMV8xICYmICFyaWdodF8xXzEuZG9uZSAmJiAoX2EgPSByaWdodF8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChyaWdodF8xKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbnMsIHBhdHRlcm5zLCBkaWRTdWNjZWVkLCBtYXRjaGVkO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2F0aGVyVGV4dChsZWZ0LCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2F0aGVyVGV4dChyaWdodCwgZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihwYXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTdWNjZWVkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbWF0Y2hlZCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgJysnOiBmdW5jdGlvbiBwbHVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdkYXRldGltZScgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ251bWJlcicgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdzdHJpbmcnICYmIHJpZ2h0LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhsZWZ0LmRhdGEgKyByaWdodC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnb2JqZWN0JyAmJiByaWdodC50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21KUyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbGVmdC5kYXRhKSwgcmlnaHQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdhcnJheScgJiYgcmlnaHQudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21KUyhsZWZ0LmRhdGEuY29uY2F0KHJpZ2h0LmRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdC5pc0FycmF5KCkgJiYgcmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRfMSwgbGVmdF8xXzEsIHZhbCwgZV8yXzEsIHJpZ2h0XzIsIHJpZ2h0XzJfMSwgdmFsLCBlXzNfMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVfMiwgX2EsIGVfMywgX2I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMCwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdF8xID0gX19hc3luY1ZhbHVlcyhsZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChsZWZ0XzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShsZWZ0XzFfMSA9IF9jLnNlbnQoKSwgIWxlZnRfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbGVmdF8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodmFsKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMl8xID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGxlZnRfMV8xICYmICFsZWZ0XzFfMS5kb25lICYmIChfYSA9IGxlZnRfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbChsZWZ0XzEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMTMsIDIwLCAyMSwgMjZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRfMiA9IF9fYXN5bmNWYWx1ZXMocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQocmlnaHRfMi5uZXh0KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyaWdodF8yXzEgPSBfYy5zZW50KCksICFyaWdodF8yXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmlnaHRfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9jLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzMgLypicmVhayovLCAyNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8zXzEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMyA9IHsgZXJyb3I6IGVfM18xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDI2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzIxLCAsIDI0LCAyNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyaWdodF8yXzEgJiYgIXJpZ2h0XzJfMS5kb25lICYmIChfYiA9IHJpZ2h0XzJbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9iLmNhbGwocmlnaHRfMikpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzogcmV0dXJuIFszIC8qYnJlYWsqLywgMjVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI1OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgICctJzogZnVuY3Rpb24gbWludXMobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiByaWdodC50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21EYXRlVGltZShsZWZ0LmRhdGEuYWRkKC1yaWdodC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiByaWdodC50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEuZGlmZmVyZW5jZShyaWdodC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ251bWJlcicgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSAtIHJpZ2h0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgJyonOiBudW1lcmljT3BlcmF0b3IoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKiBiOyB9KSxcbiAgICAnLyc6IG51bWVyaWNPcGVyYXRvcihmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAvIGI7IH0pLFxuICAgICclJzogbnVtZXJpY09wZXJhdG9yKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICUgYjsgfSksXG4gICAgJyoqJzogbnVtZXJpY09wZXJhdG9yKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLnBvdyhhLCBiKTsgfSlcbn07XG5mdW5jdGlvbiBudW1lcmljT3BlcmF0b3IoaW1wbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ251bWJlcicgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbXBsKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH07XG59dmFyIFNjb3BlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgZnVuY3Rpb24gU2NvcGUocGFyYW1zLCBzb3VyY2UsIHZhbHVlLCBjb250ZXh0LCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIFNjb3BlLnByb3RvdHlwZS5jcmVhdGVOZXN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMpO1xuICAgIH07XG4gICAgU2NvcGUucHJvdG90eXBlLmNyZWF0ZUhpZGRlbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgICAgICByZXN1bHQuaXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFNjb3BlO1xufSgpKTtmdW5jdGlvbiBldmFsdWF0ZShub2RlLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGlmIChleGVjdXRlID09PSB2b2lkIDApIHsgZXhlY3V0ZSA9IGV2YWx1YXRlOyB9XG4gICAgdmFyIGZ1bmMgPSBFWEVDVVRPUlNbbm9kZS50eXBlXTtcbiAgICByZXR1cm4gZnVuYyhub2RlLCBzY29wZSwgZXhlY3V0ZSk7XG59XG4vKipcbiAqIEFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGEgdmFsdWUsIGJ1dCB0cmllcyB0byBhdm9pZCBjcmVhdGluZyB1bm5lY2Vzc2FyeSBwcm9taXNlcy5cbiAqL1xuZnVuY3Rpb24gcHJvbWlzZWxlc3NBcHBseSh2YWx1ZSwgY2IpIHtcbiAgICBpZiAoJ3RoZW4nIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50aGVuKGNiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNiKHZhbHVlKTtcbn1cbnZhciBFWEVDVVRPUlMgPSB7XG4gICAgVGhpczogZnVuY3Rpb24gKF8sIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBzY29wZS52YWx1ZTtcbiAgICB9LFxuICAgIFNlbGVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoZXNlIHNob3VsZCBiZSBldmFsdWF0ZWQgc2VwYXJlbHkgdXNpbmcgYSBkaWZmZXJlbnQgZXZhbHVhdG9yLlxuICAgICAgICAvLyBBdCB0aGUgbW9vbWVudCB3ZSBoYXZlbid0IGltcGxlbWVudGVkIHRoaXMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0b3JzIGNhbiBub3QgYmUgZXZhbHVhdGVkJyk7XG4gICAgfSxcbiAgICBFdmVyeXRoaW5nOiBmdW5jdGlvbiAoXywgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlLnNvdXJjZTtcbiAgICB9LFxuICAgIFBhcmFtZXRlcjogZnVuY3Rpb24gKF9hLCBzY29wZSkge1xuICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgIHJldHVybiBmcm9tSlMoc2NvcGUucGFyYW1zW25hbWVdKTtcbiAgICB9LFxuICAgIENvbnRleHQ6IGZ1bmN0aW9uIChfYSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGtleSA9IF9hLmtleTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2JlZm9yZScgfHwga2V5ID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzY29wZS5jb250ZXh0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgfHwgTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbnRleHQga2V5OiBcIi5jb25jYXQoa2V5KSk7XG4gICAgfSxcbiAgICBQYXJlbnQ6IGZ1bmN0aW9uIChfYSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIG4gPSBfYS5uO1xuICAgICAgICB2YXIgY3VycmVudCA9IHNjb3BlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICAgIH0sXG4gICAgT3BDYWxsOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcCA9IF9hLm9wLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICAgICAgdmFyIGZ1bmMgPSBvcGVyYXRvcnNbb3BdO1xuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3I6IFwiLmNvbmNhdChvcCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0VmFsdWUgPSBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICAgICAgdmFyIHJpZ2h0VmFsdWUgPSBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgICAgIC8vIEF2b2lkIHVuZWNjZXNhcnkgcHJvbWlzZXNcbiAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBmb3IgY29uc3RhbnQgZXZhbHVhdGlvbiB0byB3b3JrIGNvcnJlY3RseS5cbiAgICAgICAgaWYgKCd0aGVuJyBpbiBsZWZ0VmFsdWUgfHwgJ3RoZW4nIGluIHJpZ2h0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgeyB2YXIgX2EsIF9iOyByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGZ1bmM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsZWZ0VmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IFtfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmlnaHRWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHZvaWQgMCwgX2IuY29uY2F0KFtfYy5zZW50KCldKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pOyB9KTsgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgIH0sXG4gICAgU2VsZWN0OiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZXMgPSBfYS5hbHRlcm5hdGl2ZXMsIGZhbGxiYWNrID0gX2EuZmFsbGJhY2s7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfaSwgYWx0ZXJuYXRpdmVzXzEsIGFsdCwgYWx0Q29uZDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgYWx0ZXJuYXRpdmVzXzEgPSBhbHRlcm5hdGl2ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgYWx0ZXJuYXRpdmVzXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHQgPSBhbHRlcm5hdGl2ZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFsdC5jb25kaXRpb24sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdENvbmQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWx0Q29uZC50eXBlID09PSAnYm9vbGVhbicgJiYgYWx0Q29uZC5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBleGVjdXRlKGZhbGxiYWNrLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEluUmFuZ2U6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodCwgaXNJbmNsdXNpdmUgPSBfYS5pc0luY2x1c2l2ZTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlLCBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUsIGxlZnRDbXAsIF9iLCBfYywgcmlnaHRDbXAsIF9kLCBfZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUobGVmdCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFZhbHVlID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShyaWdodCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRWYWx1ZSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gcGFydGlhbENvbXBhcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gW19mLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsZWZ0VmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0Q21wID0gX2IuYXBwbHkodm9pZCAwLCBfYy5jb25jYXQoW19mLnNlbnQoKV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0Q21wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBwYXJ0aWFsQ29tcGFyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2UgPSBbX2Yuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJpZ2h0VmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodENtcCA9IF9kLmFwcGx5KHZvaWQgMCwgX2UuY29uY2F0KFtfZi5zZW50KCldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRDbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbmNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEZpbHRlcjogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2UsIGV4cHIgPSBfYS5leHByO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZVZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgU3RyZWFtVmFsdWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVmFsdWVfMSwgYmFzZVZhbHVlXzFfMSwgZWxlbSwgbmV3U2NvcGUsIGV4cHJWYWx1ZSwgZV8xXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgOCwgOSwgMTRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZV8xID0gX19hc3luY1ZhbHVlcyhiYXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoYmFzZVZhbHVlXzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJhc2VWYWx1ZV8xXzEgPSBfYi5zZW50KCksICFiYXNlVmFsdWVfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBiYXNlVmFsdWVfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGV4cHJWYWx1ZS50eXBlID09PSAnYm9vbGVhbicgJiYgZXhwclZhbHVlLmRhdGEgPT09IHRydWUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoZWxlbSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs5LCAsIDEyLCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZVZhbHVlXzFfMSAmJiAhYmFzZVZhbHVlXzFfMS5kb25lICYmIChfYSA9IGJhc2VWYWx1ZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbChiYXNlVmFsdWVfMSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFByb2plY3Rpb246IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBleHByID0gX2EuZXhwcjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZSwgbmV3U2NvcGU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZXhlY3V0ZShleHByLCBuZXdTY29wZSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEZ1bmNDYWxsOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBmdW5jID0gX2EuZnVuYywgYXJncyA9IF9hLmFyZ3M7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgICB9LFxuICAgIFBpcGVGdW5jQ2FsbDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgZnVuYyA9IF9hLmZ1bmMsIGJhc2UgPSBfYS5iYXNlLCBhcmdzID0gX2EuYXJncztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnVuYyhiYXNlVmFsdWUsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgQWNjZXNzQXR0cmlidXRlOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2NvcGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyh2YWx1ZS5kYXRhW25hbWVdKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEFjY2Vzc0VsZW1lbnQ6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZVZhbHVlLCBkYXRhLCBmaW5hbEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VWYWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhkYXRhW2ZpbmFsSW5kZXhdKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgU2xpY2U6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodCwgaXNJbmNsdXNpdmUgPSBfYS5pc0luY2x1c2l2ZTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZSwgYXJyYXksIGxlZnRJZHgsIHJpZ2h0SWR4O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VWYWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5ID0gKF9iLnNlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0SWR4ID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SWR4ID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbmVnYXRpdmUgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRJZHggPSBhcnJheS5sZW5ndGggKyBsZWZ0SWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SWR4ID0gYXJyYXkubGVuZ3RoICsgcmlnaHRJZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gaW5jbHVzaXZlIHRvIGV4Y2x1c2l2ZSBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRJZHgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRJZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IEF0IHRoaXMgcG9pbnQgdGhlIGluZGljZXMgbWlnaHQgcG9pbnQgb3V0LW9mLWJvdW5kLCBidXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zbGljZSBoYW5kbGVzIHRoaXMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhhcnJheS5zbGljZShsZWZ0SWR4LCByaWdodElkeCkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBEZXJlZjogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgZV8yLCBfYjtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsIGlkLCBfYywgX2QsIGRvYywgZV8yXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLnNvdXJjZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmRhdGEuX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IF9fYXN5bmNWYWx1ZXMoc2NvcGUuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfZCA9IF9lLnNlbnQoKSwgIV9kLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvYy50eXBlID09PSAnb2JqZWN0JyAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRvY107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzJfMSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9kICYmICFfZC5kb25lICYmIChfYiA9IF9jW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLmNhbGwoX2MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFZhbHVlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgIHJldHVybiBmcm9tSlModmFsdWUpO1xuICAgIH0sXG4gICAgR3JvdXA6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlO1xuICAgICAgICByZXR1cm4gZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgfSxcbiAgICBPYmplY3Q6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBfYS5hdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBfaSwgYXR0cmlidXRlc18xLCBhdHRyLCBhdHRyVHlwZSwgX2IsIHZhbHVlLCBfYywgX2QsIGNvbmQsIHZhbHVlLCB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBhdHRyaWJ1dGVzXzEgPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGF0dHJpYnV0ZXNfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBhdHRyLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnT2JqZWN0QXR0cmlidXRlVmFsdWUnOiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdPYmplY3RDb25kaXRpb25hbFNwbGF0JzogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnT2JqZWN0U3BsYXQnOiByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGF0dHIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NbX2RdID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXR0ci5jb25kaXRpb24sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmQgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSAnYm9vbGVhbicgfHwgY29uZC5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiLmNvbmNhdChhdHRyVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbUpTKHJlc3VsdCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEFycmF5OiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IF9hLmVsZW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfaSwgZWxlbWVudHNfMSwgZWxlbWVudCwgdmFsdWUsIHZhbHVlXzEsIHZhbHVlXzFfMSwgdiwgZV8zXzE7XG4gICAgICAgICAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBlbGVtZW50c18xID0gZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgZWxlbWVudHNfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAyMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoZXhlY3V0ZShlbGVtZW50LnZhbHVlLCBzY29wZSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuaXNTcGxhdCkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMywgMTAsIDExLCAxNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXzEgPSAoZV8zID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlXzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMV8xID0gX2Iuc2VudCgpLCAhdmFsdWVfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdmFsdWVfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodildO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfM18xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMyA9IHsgZXJyb3I6IGVfM18xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzExLCAsIDE0LCAxNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzFfMSAmJiAhdmFsdWVfMV8xLmRvbmUgJiYgKF9hID0gdmFsdWVfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYS5jYWxsKHZhbHVlXzEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzMgLypicmVhayovLCAyMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgVHVwbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0dXBsZXMgY2FuIG5vdCBiZSBldmFsdWF0ZWQnKTtcbiAgICB9LFxuICAgIE9yOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShsZWZ0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0VmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKHJpZ2h0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodFZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFZhbHVlLnR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBBbmQ6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBfYS5sZWZ0LCByaWdodCA9IF9hLnJpZ2h0O1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVmdFZhbHVlLCByaWdodFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGxlZnQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUocmlnaHQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIE5vdDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2U7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWUuZGF0YSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgTmVnOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgUG9zOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWx1ZS5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBBc2M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfSxcbiAgICBEZXNjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgQXJyYXlDb2VyY2U6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWUuaXNBcnJheSgpID8gdmFsdWUgOiBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBNYXA6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBleHByID0gX2EuZXhwcjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMiwgdmFsdWVfMl8xLCBlbGVtLCBuZXdTY29wZSwgZV80XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV80LCBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgOCwgOSwgMTRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXzIgPSBfX2FzeW5jVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlXzIubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzJfMSA9IF9iLnNlbnQoKSwgIXZhbHVlXzJfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gdmFsdWVfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdC5hcHBseSh2b2lkIDAsIFtfYi5zZW50KCldKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV80XzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzQgPSB7IGVycm9yOiBlXzRfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzksICwgMTIsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8yXzEgJiYgIXZhbHVlXzJfMS5kb25lICYmIChfYSA9IHZhbHVlXzJbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYS5jYWxsKHZhbHVlXzIpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBGbGF0TWFwOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgZXhwciA9IF9hLmV4cHI7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBTdHJlYW1WYWx1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlXzMsIHZhbHVlXzNfMSwgZWxlbSwgbmV3U2NvcGUsIGlubmVyVmFsdWUsIGlubmVyVmFsdWVfMSwgaW5uZXJWYWx1ZV8xXzEsIGlubmVyLCBlXzVfMSwgZV82XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV82LCBfYSwgZV81LCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMCwgMjMsIDI0LCAyOV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVfMyA9IF9fYXN5bmNWYWx1ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodmFsdWVfMy5uZXh0KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfM18xID0gX2Muc2VudCgpLCAhdmFsdWVfM18xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAyMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gdmFsdWVfM18xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVmFsdWUgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlubmVyVmFsdWUuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbNCwgMTEsIDEyLCAxN10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJWYWx1ZV8xID0gKGVfNSA9IHZvaWQgMCwgX19hc3luY1ZhbHVlcyhpbm5lclZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChpbm5lclZhbHVlXzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGlubmVyVmFsdWVfMV8xID0gX2Muc2VudCgpLCAhaW5uZXJWYWx1ZV8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyID0gaW5uZXJWYWx1ZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGlubmVyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzVfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEyLCAsIDE1LCAxNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5uZXJWYWx1ZV8xXzEgJiYgIWlubmVyVmFsdWVfMV8xLmRvbmUgJiYgKF9iID0gaW5uZXJWYWx1ZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2IuY2FsbChpbm5lclZhbHVlXzEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzMgLypicmVhayovLCAyMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoaW5uZXJWYWx1ZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDI5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNl8xID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV82ID0geyBlcnJvcjogZV82XzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDI5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMjQsICwgMjcsIDI4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8zXzEgJiYgIXZhbHVlXzNfMS5kb25lICYmIChfYSA9IHZhbHVlXzNbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYS5jYWxsKHZhbHVlXzMpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OiByZXR1cm4gWzMgLypicmVhayovLCAyOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI4OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI5OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogRXZhbHVhdGVzIGEgcXVlcnkuXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KTtcbiAgICB2YXIgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpO1xuICAgIHZhciBwYXJhbXMgPSBfX2Fzc2lnbih7fSwgb3B0aW9ucy5wYXJhbXMpO1xuICAgIHZhciBzY29wZSA9IG5ldyBTY29wZShwYXJhbXMsIGRhdGFzZXQsIHJvb3QsIHtcbiAgICAgICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpLFxuICAgICAgICBpZGVudGl0eTogb3B0aW9ucy5pZGVudGl0eSA9PT0gdW5kZWZpbmVkID8gJ21lJyA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgICAgIHNhbml0eTogb3B0aW9ucy5zYW5pdHksXG4gICAgICAgIGFmdGVyOiBvcHRpb25zLmFmdGVyID8gZnJvbUpTKG9wdGlvbnMuYWZ0ZXIpIDogbnVsbCxcbiAgICAgICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsXG4gICAgfSwgbnVsbCk7XG4gICAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1mdW5jdGlvbiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdHcm91cCc6XG4gICAgICAgIGNhc2UgJ1ZhbHVlJzpcbiAgICAgICAgY2FzZSAnUGFyYW1ldGVyJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdQb3MnOlxuICAgICAgICBjYXNlICdOZWcnOlxuICAgICAgICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICAgICAgY2FzZSAnT3BDYWxsJzpcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJyoqJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5sZWZ0KSAmJiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG52YXIgRFVNTVlfU0NPUEUgPSBuZXcgU2NvcGUoe30sIE5VTExfVkFMVUUsIE5VTExfVkFMVUUsIHsgdGltZXN0YW1wOiBuZXcgRGF0ZSgwKSwgaWRlbnRpdHk6ICdtZScsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSwgbnVsbCk7XG5mdW5jdGlvbiB0cnlDb25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgICBpZiAoIWNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb25zdGFudEV2YWx1YXRlKG5vZGUpO1xufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gZXZhbHVhdGUobm9kZSwgRFVNTVlfU0NPUEUsIGNvbnN0YW50RXZhbHVhdGUpO1xuICAgIGlmICgndGhlbicgaW4gdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCVUc6IGNvbnN0YW50IGV2YWx1YXRlIHNob3VsZCBuZXZlciByZXR1cm4gYSBwcm9taXNlJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn12YXIgRVNDQVBFX1NFUVVFTkNFID0ge1xuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXCInOiAnXCInLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICcvJzogJy8nLFxuICAgIGI6ICdcXGInLFxuICAgIGY6ICdcXGYnLFxuICAgIG46ICdcXG4nLFxuICAgIHI6ICdcXHInLFxuICAgIHQ6ICdcXHQnXG59O1xuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xuICAgIHZhciBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn1cbnZhciBHcm9xUXVlcnlFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JvcVF1ZXJ5RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvcVF1ZXJ5RXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ0dyb3FRdWVyeUVycm9yJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gR3JvcVF1ZXJ5RXJyb3I7XG59KEVycm9yKSk7XG52YXIgRVhQUl9CVUlMREVSID0ge1xuICAgIGdyb3VwOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgaW5uZXIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdHcm91cCcsXG4gICAgICAgICAgICBiYXNlOiBpbm5lclxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZXZlcnl0aGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnRXZlcnl0aGluZycgfTtcbiAgICB9LFxuICAgIFwidGhpc1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdUaGlzJyB9O1xuICAgIH0sXG4gICAgcGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUGFyZW50JyxcbiAgICAgICAgICAgIG46IDFcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRibHBhcmVudDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG5leHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdQYXJlbnQnLFxuICAgICAgICAgICAgbjogbmV4dC5uICsgMVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciB0cmF2ZXJzYWxMaXN0ID0gW107XG4gICAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSAndHJhdmVyc2FsX2VuZCcpIHtcbiAgICAgICAgICAgIHRyYXZlcnNhbExpc3QucHVzaChwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUikpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgdmFyIHRyYXZlcnNhbCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSB0cmF2ZXJzYWxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzYWxMaXN0W2ldKHRyYXZlcnNhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UudHlwZSA9PT0gJ0V2ZXJ5dGhpbmcnIHx8IGJhc2UudHlwZSA9PT0gJ0FycmF5JyB8fCBiYXNlLnR5cGUgPT09ICdQaXBlRnVuY0NhbGwnKSB7XG4gICAgICAgICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbDsgfSwgdHJhdmVyc2FsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhdmVyc2FsID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCVUc6IHVuZXhwZWN0ZWQgZW1wdHkgdHJhdmVyc2FsJyk7XG4gICAgICAgIHJldHVybiB0cmF2ZXJzYWwuYnVpbGQoYmFzZSk7XG4gICAgfSxcbiAgICB0aGlzX2F0dHI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIGlmIChuYW1lID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdWYWx1ZScsIHZhbHVlOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ1ZhbHVlJywgdmFsdWU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ1ZhbHVlJywgdmFsdWU6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdBY2Nlc3NBdHRyaWJ1dGUnLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbmVnOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ05lZycsXG4gICAgICAgICAgICBiYXNlOiBiYXNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwb3M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUG9zJyxcbiAgICAgICAgICAgIGJhc2U6IGJhc2VcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiAnKycsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdWI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogJy0nLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbXVsOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPcENhbGwnLFxuICAgICAgICAgICAgb3A6ICcqJyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRpdjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiAnLycsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBtb2Q6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogJyUnLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcG93OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPcENhbGwnLFxuICAgICAgICAgICAgb3A6ICcqKicsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiBvcCxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGluX3JhbmdlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSAnaW5jX3JhbmdlJztcbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdJblJhbmdlJyxcbiAgICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgaXNJbmNsdXNpdmU6IGlzSW5jbHVzaXZlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdHI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICAgIGxvb3A6IHdoaWxlIChwLmhhc01hcmsoKSkge1xuICAgICAgICAgICAgdmFyIG1hcmsgPSBwLmdldE1hcmsoKTtcbiAgICAgICAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyX2VuZCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyX3BhdXNlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cl9zdGFydCc6XG4gICAgICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlX2VzY2FwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IEVTQ0FQRV9TRVFVRU5DRVtjaGFyXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3VuaWNvZGVfaGV4JzpcbiAgICAgICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBleHBhbmRIZXgocC5wcm9jZXNzU3RyaW5nRW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIG1hcms6IFwiLmNvbmNhdChtYXJrLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAnVmFsdWUnLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9LFxuICAgIGludGVnZXI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBmbG9hdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnVmFsdWUnLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNjaTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnVmFsdWUnLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICdvYmplY3RfZW5kJykge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKHAucHJvY2VzcyhPQkpFQ1RfQlVJTERFUikpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPYmplY3QnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlc1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYXJyYXk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ2FycmF5X2VuZCcpIHtcbiAgICAgICAgICAgIHZhciBpc1NwbGF0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gJ2FycmF5X3NwbGF0Jykge1xuICAgICAgICAgICAgICAgIGlzU3BsYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0FycmF5RWxlbWVudCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGlzU3BsYXQ6IGlzU3BsYXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdBcnJheScsXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHR1cGxlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IFtdO1xuICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ3R1cGxlX2VuZCcpIHtcbiAgICAgICAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgICAgIH1cbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1R1cGxlJyxcbiAgICAgICAgICAgIG1lbWJlcnM6IG1lbWJlcnNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGZ1bmNfY2FsbDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9ICdnbG9iYWwnO1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gJ25hbWVzcGFjZScpIHtcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09ICdnbG9iYWwnICYmIG5hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdTZWxlY3QnLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ2Z1bmNfYXJnc19lbmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICdwYWlyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NlbGVjdEFsdGVybmF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSAnZnVuY19hcmdzX2VuZCcpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBuYW1lLCBhcmdzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgZGlmZi9kZWx0YSBmdW5jdGlvbnMgYXJlbid0IHZhbGlkYXRlZCB5ZXQgd2Ugb25seSB3YW50IHRvIHZhbGlkYXRlIHRoZSBzZWxlY3RvclxuICAgICAgICAgICAgICAgIC8vIGJlaW5nIHVzZWQuIFdlIGV4cGVjdCB0aGUgbnVsbCB2YWx1ZWQgYXJnIHRvIHRocm93IGFuIGVycm9yIGF0IGV2YWx1YXRpb24gdGltZS5cbiAgICAgICAgICAgICAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHsgdHlwZTogJ1NlbGVjdG9yJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICBpZiAobmFtZXNwYWNlID09PSAnZ2xvYmFsJyAmJiAobmFtZSA9PT0gJ2JlZm9yZScgfHwgbmFtZSA9PT0gJ2FmdGVyJykpIHtcbiAgICAgICAgICAgIGlmIChwLnBhcnNlT3B0aW9ucy5tb2RlID09PSAnZGVsdGEnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NvbnRleHQnLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5hbWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09ICdnbG9iYWwnICYmIG5hbWUgPT09ICdib29zdCcgJiYgIXAuYWxsb3dCb29zdClcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcigndW5leHBlY3RlZCBib29zdCcpO1xuICAgICAgICB2YXIgZnVuY3MgPSBuYW1lc3BhY2VzW25hbWVzcGFjZV07XG4gICAgICAgIGlmICghZnVuY3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBuYW1lc3BhY2U6IFwiLmNvbmNhdChuYW1lc3BhY2UpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW25hbWVdO1xuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuYy5hcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuYy5tb2RlICE9PSB1bmRlZmluZWQgJiYgZnVuYy5tb2RlICE9PSBwLnBhcnNlT3B0aW9ucy5tb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgZnVuY3Rpb246IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdGdW5jQ2FsbCcsXG4gICAgICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBpcGVjYWxsOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICBwLnNoaWZ0KCk7IC8vIFJlbW92ZSB0aGUgZnVuY19jYWxsXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSAnZ2xvYmFsJztcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICduYW1lc3BhY2UnKSB7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlICE9PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIG5hbWVzcGFjZTogXCIuY29uY2F0KG5hbWVzcGFjZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIHZhciBvbGRBbGxvd0Jvb3N0ID0gcC5hbGxvd0Jvb3N0O1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3Njb3JlJykge1xuICAgICAgICAgICAgLy8gT25seSBhbGxvdyBib29zdCBpbnNpZGUgYSBzY29yZSBleHByZXNzaW9uXG4gICAgICAgICAgICBwLmFsbG93Qm9vc3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHZhciBtYXJrTmFtZSA9IHAuZ2V0TWFyaygpLm5hbWU7XG4gICAgICAgICAgICBpZiAobWFya05hbWUgPT09ICdmdW5jX2FyZ3NfZW5kJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdvcmRlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya05hbWUgPT09ICdhc2MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHsgdHlwZTogJ0FzYycsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFya05hbWUgPT09ICdkZXNjJykge1xuICAgICAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6ICdEZXNjJywgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgICAgIH1cbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICBwLmFsbG93Qm9vc3QgPSBvbGRBbGxvd0Jvb3N0O1xuICAgICAgICB2YXIgZnVuYyA9IHBpcGVGdW5jdGlvbnNbbmFtZV07XG4gICAgICAgIGlmICghZnVuYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIHBpcGUgZnVuY3Rpb246IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmMuYXJpdHkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUGlwZUZ1bmNDYWxsJyxcbiAgICAgICAgICAgIGZ1bmM6IGZ1bmMsXG4gICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhaXI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgPT5cIik7XG4gICAgfSxcbiAgICBhbmQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0FuZCcsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3InLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbm90OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ05vdCcsXG4gICAgICAgICAgICBiYXNlOiBiYXNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhc2M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcigndW5leHBlY3RlZCBhc2MnKTtcbiAgICB9LFxuICAgIGRlc2M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcigndW5leHBlY3RlZCBkZXNjJyk7XG4gICAgfSxcbiAgICBwYXJhbTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgaWYgKHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcC5wYXJzZU9wdGlvbnMucGFyYW1zW25hbWVdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUGFyYW1ldGVyJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICB9XG59O1xudmFyIE9CSkVDVF9CVUlMREVSID0ge1xuICAgIG9iamVjdF9leHByOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gJ3BhaXInKSB7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgICB2YXIgdmFsdWVfMSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnT2JqZWN0Q29uZGl0aW9uYWxTcGxhdCcsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBjb25kaXRpb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXzFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0QXR0cmlidXRlVmFsdWUnLFxuICAgICAgICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb2JqZWN0X3BhaXI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIGlmIChuYW1lLnR5cGUgIT09ICdWYWx1ZScpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0QXR0cmlidXRlVmFsdWUnLFxuICAgICAgICAgICAgbmFtZTogbmFtZS52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb2JqZWN0X3NwbGF0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPYmplY3RTcGxhdCcsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdF9zcGxhdF90aGlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0U3BsYXQnLFxuICAgICAgICAgICAgdmFsdWU6IHsgdHlwZTogJ1RoaXMnIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xudmFyIFRSQVZFUlNFX0JVSUxERVIgPSB7XG4gICAgc3F1YXJlX2JyYWNrZXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBleHByID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUoZXhwcik7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZUVsZW1lbnQoZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdBY2Nlc3NFbGVtZW50JywgYmFzZTogYmFzZSwgaW5kZXg6IHZhbHVlLmRhdGEgfSk7IH0sIHJpZ2h0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlUGxhaW4oZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdBY2Nlc3NBdHRyaWJ1dGUnLCBiYXNlOiBiYXNlLCBuYW1lOiB2YWx1ZS5kYXRhIH0pOyB9LCByaWdodCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZUFycmF5KGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGaWx0ZXInLFxuICAgICAgICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgICAgICAgZXhwcjogZXhwclxuICAgICAgICAgICAgfSk7IH0sIHJpZ2h0KTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNsaWNlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSAnaW5jX3JhbmdlJztcbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIGxlZnRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUobGVmdCk7XG4gICAgICAgIHZhciByaWdodFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShyaWdodCk7XG4gICAgICAgIGlmICghbGVmdFZhbHVlIHx8ICFyaWdodFZhbHVlIHx8IGxlZnRWYWx1ZS50eXBlICE9PSAnbnVtYmVyJyB8fCByaWdodFZhbHVlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoJ3NsaWNpbmcgbXVzdCB1c2UgY29uc3RhbnQgbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VBcnJheShmdW5jdGlvbiAoYmFzZSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU2xpY2UnLFxuICAgICAgICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdFZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0VmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICBpc0luY2x1c2l2ZTogaXNJbmNsdXNpdmVcbiAgICAgICAgICAgIH0pOyB9LCByaHMpO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgcHJvamVjdGlvbjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG9iaiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VQcm9qZWN0aW9uKGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnUHJvamVjdGlvbicsIGJhc2U6IGJhc2UsIGV4cHI6IG9iaiB9KTsgfSwgcmlnaHQpO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYXR0cl9hY2Nlc3M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmlnaHQpIHsgcmV0dXJuIHRyYXZlcnNlUGxhaW4oZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdBY2Nlc3NBdHRyaWJ1dGUnLCBiYXNlOiBiYXNlLCBuYW1lOiBuYW1lIH0pOyB9LCByaWdodCk7IH07XG4gICAgfSxcbiAgICBkZXJlZjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGF0dHIgPSBudWxsO1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gJ2RlcmVmX2F0dHInKSB7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXAgPSBmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHIgPyB7IHR5cGU6ICdBY2Nlc3NBdHRyaWJ1dGUnLCBiYXNlOiBiYXNlLCBuYW1lOiBhdHRyIH0gOiBiYXNlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VQbGFpbihmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0RlcmVmJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogYmFzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgcmlnaHQpO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYXJyYXlfcG9zdGZpeDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkgeyByZXR1cm4gdHJhdmVyc2VBcnJheShmdW5jdGlvbiAoYmFzZSkgeyByZXR1cm4gKHsgdHlwZTogJ0FycmF5Q29lcmNlJywgYmFzZTogYmFzZSB9KTsgfSwgcmlnaHQpOyB9O1xuICAgIH1cbn07XG52YXIgU0VMRUNUT1JfQlVJTERFUiA9IHtcbiAgICBncm91cDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGV2ZXJ5dGhpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgXCJ0aGlzXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGRibHBhcmVudDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICd0cmF2ZXJzYWxfZW5kJykge1xuICAgICAgICAgICAgcC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICB0aGlzX2F0dHI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIG5lZzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcG9zOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHN1YjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgbXVsOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBkaXY6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIG1vZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcG93OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBjb21wOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBpbl9yYW5nZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgc3RyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBmbG9hdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgc2NpOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBvYmplY3Q6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGFycmF5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICB0dXBsZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSB0aHJvdyBhbiBlcnJvciB1bnRpbCB3ZSBhZGQgc3VwcG9ydCBmb3IgdHVwbGVzIGluIHNlbGVjdG9ycy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgZnVuY19jYWxsOiBmdW5jdGlvbiAocCwgbWFyaykge1xuICAgICAgICB2YXIgZnVuYyA9IEVYUFJfQlVJTERFUi5mdW5jX2NhbGwocCwgbWFyayk7XG4gICAgICAgIGlmIChmdW5jLm5hbWUgPT09ICdhbnl3aGVyZScgJiYgZnVuYy5hcmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBwaXBlY2FsbDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcGFpcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgYW5kOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBvcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgbm90OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBhc2M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGRlc2M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBhcmFtOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0FjY2Vzc0F0dHJpYnV0ZScgJiYgIW5vZGUuYmFzZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5uYW1lO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAnRGVyZWYnIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ01hcCcgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAnUHJvamVjdGlvbicgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAnU2xpY2UnIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ0ZpbHRlcicgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAnQWNjZXNzRWxlbWVudCcgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAnQXJyYXlDb2VyY2UnKSB7XG4gICAgICAgIHJldHVybiBleHRyYWN0UHJvcGVydHlLZXkobm9kZS5iYXNlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6IFwiLmNvbmNhdChub2RlLnR5cGUpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJpdHkobmFtZSwgYXJpdHksIGNvdW50KSB7XG4gICAgaWYgKHR5cGVvZiBhcml0eSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGNvdW50ICE9PSBhcml0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gXCIuY29uY2F0KG5hbWUsIFwiKCkuIEV4cGVjdGVkIFwiKS5jb25jYXQoYXJpdHksIFwiLCBnb3QgXCIpLmNvbmNhdChjb3VudCwgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhcml0eSkge1xuICAgICAgICBpZiAoIWFyaXR5KGNvdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gXCIuY29uY2F0KG5hbWUsIFwiKCkuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvcihuYW1lc3BhY2UsIGZ1bmN0aW9uTmFtZSwgYXJnQ291bnQpIHtcbiAgICB2YXIgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzID0gWydjaGFuZ2VkQW55JywgJ2NoYW5nZWRPbmx5J107XG4gICAgcmV0dXJuIG5hbWVzcGFjZSA9PSAnZGlmZicgJiYgYXJnQ291bnQgPT0gMiAmJiBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMuaW5jbHVkZXMoZnVuY3Rpb25OYW1lKTtcbn1cbnZhciBHcm9xU3ludGF4RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3FTeW50YXhFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm9xU3ludGF4RXJyb3IocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJTeW50YXggZXJyb3IgaW4gR1JPUSBxdWVyeSBhdCBwb3NpdGlvbiBcIi5jb25jYXQocG9zaXRpb24pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ0dyb3FTeW50YXhFcnJvcic7XG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEdyb3FTeW50YXhFcnJvcjtcbn0oRXJyb3IpKTtcbi8qKlxuICogUGFyc2VzIGEgR1JPUSBxdWVyeSBhbmQgcmV0dXJucyBhIHRyZWUgc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHJlc3VsdCA9IHBhcnNlJDEoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgR3JvcVN5bnRheEVycm9yKHJlc3VsdC5wb3NpdGlvbik7XG4gICAgfVxuICAgIHZhciBwcm9jZXNzb3IgPSBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcHJvY2Vzc29yLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbn1leHBvcnRzLmV2YWx1YXRlPWV2YWx1YXRlUXVlcnk7ZXhwb3J0cy5wYXJzZT1wYXJzZTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnX19lc01vZHVsZScse3ZhbHVlOnRydWV9KTt9KSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/groq-js/dist/1.umd.cjs\n"));

/***/ }),

/***/ "./node_modules/throttle-debounce/cjs/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/throttle-debounce/cjs/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\r\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\r\n\r\n/**\r\n * Throttle execution of a function. Especially useful for rate limiting\r\n * execution of handlers on events like resize and scroll.\r\n *\r\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\r\n *                                            are most useful.\r\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\r\n *                                            as-is, to `callback` when the throttled-function is executed.\r\n * @param {object} [options] -              An object to configure options.\r\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\r\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\r\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\r\n *                                            `delay` milliseconds, the internal counter is reset).\r\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\r\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\r\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\r\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\r\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\r\n *\r\n * @returns {Function} A new, throttled, function.\r\n */\r\nfunction throttle (delay, callback, options) {\r\n  var _ref = options || {},\r\n      _ref$noTrailing = _ref.noTrailing,\r\n      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,\r\n      _ref$noLeading = _ref.noLeading,\r\n      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,\r\n      _ref$debounceMode = _ref.debounceMode,\r\n      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;\r\n  /*\r\n   * After wrapper has stopped being called, this timeout ensures that\r\n   * `callback` is executed at the proper times in `throttle` and `end`\r\n   * debounce modes.\r\n   */\r\n\r\n\r\n  var timeoutID;\r\n  var cancelled = false; // Keep track of the last time `callback` was executed.\r\n\r\n  var lastExec = 0; // Function to clear existing timeout\r\n\r\n  function clearExistingTimeout() {\r\n    if (timeoutID) {\r\n      clearTimeout(timeoutID);\r\n    }\r\n  } // Function to cancel next exec\r\n\r\n\r\n  function cancel(options) {\r\n    var _ref2 = options || {},\r\n        _ref2$upcomingOnly = _ref2.upcomingOnly,\r\n        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;\r\n\r\n    clearExistingTimeout();\r\n    cancelled = !upcomingOnly;\r\n  }\r\n  /*\r\n   * The `wrapper` function encapsulates all of the throttling / debouncing\r\n   * functionality and when executed will limit the rate at which `callback`\r\n   * is executed.\r\n   */\r\n\r\n\r\n  function wrapper() {\r\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      arguments_[_key] = arguments[_key];\r\n    }\r\n\r\n    var self = this;\r\n    var elapsed = Date.now() - lastExec;\r\n\r\n    if (cancelled) {\r\n      return;\r\n    } // Execute `callback` and update the `lastExec` timestamp.\r\n\r\n\r\n    function exec() {\r\n      lastExec = Date.now();\r\n      callback.apply(self, arguments_);\r\n    }\r\n    /*\r\n     * If `debounceMode` is true (at begin) this is used to clear the flag\r\n     * to allow future `callback` executions.\r\n     */\r\n\r\n\r\n    function clear() {\r\n      timeoutID = undefined;\r\n    }\r\n\r\n    if (!noLeading && debounceMode && !timeoutID) {\r\n      /*\r\n       * Since `wrapper` is being called for the first time and\r\n       * `debounceMode` is true (at begin), execute `callback`\r\n       * and noLeading != true.\r\n       */\r\n      exec();\r\n    }\r\n\r\n    clearExistingTimeout();\r\n\r\n    if (debounceMode === undefined && elapsed > delay) {\r\n      if (noLeading) {\r\n        /*\r\n         * In throttle mode with noLeading, if `delay` time has\r\n         * been exceeded, update `lastExec` and schedule `callback`\r\n         * to execute after `delay` ms.\r\n         */\r\n        lastExec = Date.now();\r\n\r\n        if (!noTrailing) {\r\n          timeoutID = setTimeout(debounceMode ? clear : exec, delay);\r\n        }\r\n      } else {\r\n        /*\r\n         * In throttle mode without noLeading, if `delay` time has been exceeded, execute\r\n         * `callback`.\r\n         */\r\n        exec();\r\n      }\r\n    } else if (noTrailing !== true) {\r\n      /*\r\n       * In trailing throttle mode, since `delay` time has not been\r\n       * exceeded, schedule `callback` to execute `delay` ms after most\r\n       * recent execution.\r\n       *\r\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\r\n       * after `delay` ms.\r\n       *\r\n       * If `debounceMode` is false (at end), schedule `callback` to\r\n       * execute after `delay` ms.\r\n       */\r\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\r\n    }\r\n  }\r\n\r\n  wrapper.cancel = cancel; // Return the wrapper function.\r\n\r\n  return wrapper;\r\n}\r\n\r\n/* eslint-disable no-undefined */\r\n/**\r\n * Debounce execution of a function. Debouncing, unlike throttling,\r\n * guarantees that a function is only executed a single time, either at the\r\n * very beginning of a series of calls, or at the very end.\r\n *\r\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\r\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\r\n *                                        to `callback` when the debounced-function is executed.\r\n * @param {object} [options] -           An object to configure options.\r\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\r\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\r\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\r\n *\r\n * @returns {Function} A new, debounced function.\r\n */\r\n\r\nfunction debounce (delay, callback, options) {\r\n  var _ref = options || {},\r\n      _ref$atBegin = _ref.atBegin,\r\n      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;\r\n\r\n  return throttle(delay, callback, {\r\n    debounceMode: atBegin !== false\r\n  });\r\n}\r\n\r\nexports.debounce = debounce;\r\nexports.throttle = throttle;\r\n//# sourceMappingURL=index.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvY2pzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsYUFBYTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJvdHRsZS1kZWJvdW5jZS9janMvaW5kZXguanM/NzJmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkLG5vLXBhcmFtLXJlYXNzaWduLG5vLXNoYWRvdyAqL1xyXG5cclxuLyoqXHJcbiAqIFRocm90dGxlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmF0ZSBsaW1pdGluZ1xyXG4gKiBleGVjdXRpb24gb2YgaGFuZGxlcnMgb24gZXZlbnRzIGxpa2UgcmVzaXplIGFuZCBzY3JvbGwuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtICAgICAgICAgICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG1vc3QgdXNlZnVsLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtICAgICAgICAgICAgICAgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMuIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcy1pcywgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSAgICAgICAgICAgICAgQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSBvcHRpb25zLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5vVHJhaWxpbmddIC0gICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIG5vVHJhaWxpbmcgaXMgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBvbmx5IGV4ZWN1dGUgZXZlcnkgYGRlbGF5YCBtaWxsaXNlY29uZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub1RyYWlsaW5nIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmUgZmluYWwgdGltZSBhZnRlciB0aGUgbGFzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbC4gKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3JcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBkZWxheWAgbWlsbGlzZWNvbmRzLCB0aGUgaW50ZXJuYWwgY291bnRlciBpcyByZXNldCkuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9MZWFkaW5nXSAtICAgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBub0xlYWRpbmcgaXMgZmFsc2UsIHRoZSBmaXJzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbCB3aWxsIGV4ZWN1dGUgY2FsbGJhY2tcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5LiBJZiBub0xlYWRpbmcgaXMgdHJ1ZSwgdGhlIGZpcnN0IHRoZSBjYWxsYmFjayBleGVjdXRpb24gd2lsbCBiZSBza2lwcGVkLiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgd2lsbCBuZXZlciBleGVjdXRlZCBpZiBib3RoIG5vTGVhZGluZyA9IHRydWUgYW5kIG5vVHJhaWxpbmcgPSB0cnVlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlYm91bmNlTW9kZV0gLSBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLiBJZiBgZGVib3VuY2VNb2RlYCBpc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UgKGF0IGVuZCksIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3LCB0aHJvdHRsZWQsIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3R0bGUgKGRlbGF5LCBjYWxsYmFjaywgb3B0aW9ucykge1xyXG4gIHZhciBfcmVmID0gb3B0aW9ucyB8fCB7fSxcclxuICAgICAgX3JlZiRub1RyYWlsaW5nID0gX3JlZi5ub1RyYWlsaW5nLFxyXG4gICAgICBub1RyYWlsaW5nID0gX3JlZiRub1RyYWlsaW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkbm9UcmFpbGluZyxcclxuICAgICAgX3JlZiRub0xlYWRpbmcgPSBfcmVmLm5vTGVhZGluZyxcclxuICAgICAgbm9MZWFkaW5nID0gX3JlZiRub0xlYWRpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRub0xlYWRpbmcsXHJcbiAgICAgIF9yZWYkZGVib3VuY2VNb2RlID0gX3JlZi5kZWJvdW5jZU1vZGUsXHJcbiAgICAgIGRlYm91bmNlTW9kZSA9IF9yZWYkZGVib3VuY2VNb2RlID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmJGRlYm91bmNlTW9kZTtcclxuICAvKlxyXG4gICAqIEFmdGVyIHdyYXBwZXIgaGFzIHN0b3BwZWQgYmVpbmcgY2FsbGVkLCB0aGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0XHJcbiAgICogYGNhbGxiYWNrYCBpcyBleGVjdXRlZCBhdCB0aGUgcHJvcGVyIHRpbWVzIGluIGB0aHJvdHRsZWAgYW5kIGBlbmRgXHJcbiAgICogZGVib3VuY2UgbW9kZXMuXHJcbiAgICovXHJcblxyXG5cclxuICB2YXIgdGltZW91dElEO1xyXG4gIHZhciBjYW5jZWxsZWQgPSBmYWxzZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB0aW1lIGBjYWxsYmFja2Agd2FzIGV4ZWN1dGVkLlxyXG5cclxuICB2YXIgbGFzdEV4ZWMgPSAwOyAvLyBGdW5jdGlvbiB0byBjbGVhciBleGlzdGluZyB0aW1lb3V0XHJcblxyXG4gIGZ1bmN0aW9uIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCkge1xyXG4gICAgaWYgKHRpbWVvdXRJRCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcclxuICAgIH1cclxuICB9IC8vIEZ1bmN0aW9uIHRvIGNhbmNlbCBuZXh0IGV4ZWNcclxuXHJcblxyXG4gIGZ1bmN0aW9uIGNhbmNlbChvcHRpb25zKSB7XHJcbiAgICB2YXIgX3JlZjIgPSBvcHRpb25zIHx8IHt9LFxyXG4gICAgICAgIF9yZWYyJHVwY29taW5nT25seSA9IF9yZWYyLnVwY29taW5nT25seSxcclxuICAgICAgICB1cGNvbWluZ09ubHkgPSBfcmVmMiR1cGNvbWluZ09ubHkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkdXBjb21pbmdPbmx5O1xyXG5cclxuICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XHJcbiAgICBjYW5jZWxsZWQgPSAhdXBjb21pbmdPbmx5O1xyXG4gIH1cclxuICAvKlxyXG4gICAqIFRoZSBgd3JhcHBlcmAgZnVuY3Rpb24gZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgdGhyb3R0bGluZyAvIGRlYm91bmNpbmdcclxuICAgKiBmdW5jdGlvbmFsaXR5IGFuZCB3aGVuIGV4ZWN1dGVkIHdpbGwgbGltaXQgdGhlIHJhdGUgYXQgd2hpY2ggYGNhbGxiYWNrYFxyXG4gICAqIGlzIGV4ZWN1dGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNfID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICBhcmd1bWVudHNfW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHZhciBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGxhc3RFeGVjO1xyXG5cclxuICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSAvLyBFeGVjdXRlIGBjYWxsYmFja2AgYW5kIHVwZGF0ZSB0aGUgYGxhc3RFeGVjYCB0aW1lc3RhbXAuXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XHJcbiAgICAgIGxhc3RFeGVjID0gRGF0ZS5ub3coKTtcclxuICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJndW1lbnRzXyk7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pIHRoaXMgaXMgdXNlZCB0byBjbGVhciB0aGUgZmxhZ1xyXG4gICAgICogdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cclxuICAgICAqL1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhcigpIHtcclxuICAgICAgdGltZW91dElEID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbm9MZWFkaW5nICYmIGRlYm91bmNlTW9kZSAmJiAhdGltZW91dElEKSB7XHJcbiAgICAgIC8qXHJcbiAgICAgICAqIFNpbmNlIGB3cmFwcGVyYCBpcyBiZWluZyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxyXG4gICAgICAgKiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIGV4ZWN1dGUgYGNhbGxiYWNrYFxyXG4gICAgICAgKiBhbmQgbm9MZWFkaW5nICE9IHRydWUuXHJcbiAgICAgICAqL1xyXG4gICAgICBleGVjKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJFeGlzdGluZ1RpbWVvdXQoKTtcclxuXHJcbiAgICBpZiAoZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgJiYgZWxhcHNlZCA+IGRlbGF5KSB7XHJcbiAgICAgIGlmIChub0xlYWRpbmcpIHtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIEluIHRocm90dGxlIG1vZGUgd2l0aCBub0xlYWRpbmcsIGlmIGBkZWxheWAgdGltZSBoYXNcclxuICAgICAgICAgKiBiZWVuIGV4Y2VlZGVkLCB1cGRhdGUgYGxhc3RFeGVjYCBhbmQgc2NoZWR1bGUgYGNhbGxiYWNrYFxyXG4gICAgICAgICAqIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsYXN0RXhlYyA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIGlmICghbm9UcmFpbGluZykge1xyXG4gICAgICAgICAgdGltZW91dElEID0gc2V0VGltZW91dChkZWJvdW5jZU1vZGUgPyBjbGVhciA6IGV4ZWMsIGRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBJbiB0aHJvdHRsZSBtb2RlIHdpdGhvdXQgbm9MZWFkaW5nLCBpZiBgZGVsYXlgIHRpbWUgaGFzIGJlZW4gZXhjZWVkZWQsIGV4ZWN1dGVcclxuICAgICAgICAgKiBgY2FsbGJhY2tgLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV4ZWMoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChub1RyYWlsaW5nICE9PSB0cnVlKSB7XHJcbiAgICAgIC8qXHJcbiAgICAgICAqIEluIHRyYWlsaW5nIHRocm90dGxlIG1vZGUsIHNpbmNlIGBkZWxheWAgdGltZSBoYXMgbm90IGJlZW5cclxuICAgICAgICogZXhjZWVkZWQsIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBgZGVsYXlgIG1zIGFmdGVyIG1vc3RcclxuICAgICAgICogcmVjZW50IGV4ZWN1dGlvbi5cclxuICAgICAgICpcclxuICAgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBzY2hlZHVsZSBgY2xlYXJgIHRvIGV4ZWN1dGVcclxuICAgICAgICogYWZ0ZXIgYGRlbGF5YCBtcy5cclxuICAgICAgICpcclxuICAgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgZmFsc2UgKGF0IGVuZCksIHNjaGVkdWxlIGBjYWxsYmFja2AgdG9cclxuICAgICAgICogZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxyXG4gICAgICAgKi9cclxuICAgICAgdGltZW91dElEID0gc2V0VGltZW91dChkZWJvdW5jZU1vZGUgPyBjbGVhciA6IGV4ZWMsIGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkID8gZGVsYXkgLSBlbGFwc2VkIDogZGVsYXkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgd3JhcHBlci5jYW5jZWwgPSBjYW5jZWw7IC8vIFJldHVybiB0aGUgd3JhcHBlciBmdW5jdGlvbi5cclxuXHJcbiAgcmV0dXJuIHdyYXBwZXI7XHJcbn1cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xyXG4vKipcclxuICogRGVib3VuY2UgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIERlYm91bmNpbmcsIHVubGlrZSB0aHJvdHRsaW5nLFxyXG4gKiBndWFyYW50ZWVzIHRoYXQgYSBmdW5jdGlvbiBpcyBvbmx5IGV4ZWN1dGVkIGEgc2luZ2xlIHRpbWUsIGVpdGhlciBhdCB0aGVcclxuICogdmVyeSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgY2FsbHMsIG9yIGF0IHRoZSB2ZXJ5IGVuZC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gICAgICAgICAgICAgICBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudCBjYWxsYmFja3MsIHZhbHVlcyBhcm91bmQgMTAwIG9yIDI1MCAob3IgZXZlbiBoaWdoZXIpIGFyZSBtb3N0IHVzZWZ1bC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGBjYWxsYmFja2Agd2hlbiB0aGUgZGVib3VuY2VkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gICAgICAgICAgIEFuIG9iamVjdCB0byBjb25maWd1cmUgb3B0aW9ucy5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdEJlZ2luXSAtICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIGF0QmVnaW4gaXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBgZGVsYXlgIG1pbGxpc2Vjb25kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC4gSWYgYXRCZWdpbiBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgYXQgdGhlIGZpcnN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQWZ0ZXIgdGhlIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBgZGVsYXlgIG1pbGxpc2Vjb25kcywgdGhlIGludGVybmFsIGNvdW50ZXIgaXMgcmVzZXQpLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3LCBkZWJvdW5jZWQgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZGVib3VuY2UgKGRlbGF5LCBjYWxsYmFjaywgb3B0aW9ucykge1xyXG4gIHZhciBfcmVmID0gb3B0aW9ucyB8fCB7fSxcclxuICAgICAgX3JlZiRhdEJlZ2luID0gX3JlZi5hdEJlZ2luLFxyXG4gICAgICBhdEJlZ2luID0gX3JlZiRhdEJlZ2luID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkYXRCZWdpbjtcclxuXHJcbiAgcmV0dXJuIHRocm90dGxlKGRlbGF5LCBjYWxsYmFjaywge1xyXG4gICAgZGVib3VuY2VNb2RlOiBhdEJlZ2luICE9PSBmYWxzZVxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnRzLmRlYm91bmNlID0gZGVib3VuY2U7XHJcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/throttle-debounce/cjs/index.js\n"));

/***/ })

}]);